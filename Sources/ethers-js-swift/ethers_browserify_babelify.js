(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZeroHash = exports.ZeroAddress = exports.WordlistOwlA = exports.WordlistOwl = exports.Wordlist = exports.WeiPerEther = exports.WebSocketProvider = exports.Wallet = exports.VoidSigner = exports.Utf8ErrorFuncs = exports.TypedDataEncoder = exports.Typed = exports.TransactionResponse = exports.TransactionReceipt = exports.TransactionDescription = exports.Transaction = exports.SocketProvider = exports.SigningKey = exports.Signature = exports.Result = exports.QuickNodeProvider = exports.PocketProvider = exports.ParamType = exports.NonceManager = exports.Network = exports.N = exports.Mnemonic = exports.MinInt256 = exports.MessagePrefix = exports.MaxUint256 = exports.MaxInt256 = exports.LogDescription = exports.Log = exports.LangEn = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.IpcSocketProvider = exports.Interface = exports.InfuraProvider = exports.Indexed = exports.HDNodeWallet = exports.HDNodeVoidWallet = exports.FunctionFragment = exports.Fragment = exports.FixedNumber = exports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = exports.FeeData = exports.FallbackProvider = exports.EventLog = exports.EventFragment = exports.EtherscanProvider = exports.EtherSymbol = exports.ErrorFragment = exports.EnsResolver = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractFactory = exports.ContractEventPayload = exports.Contract = exports.ConstructorFragment = exports.CloudflareProvider = exports.BrowserProvider = exports.Block = exports.BaseWallet = exports.BaseContract = exports.AnkrProvider = exports.AlchemyProvider = exports.AbstractSigner = exports.AbstractProvider = exports.AbiCoder = void 0;
exports.accessListify = accessListify;
exports.assert = assert$1;
exports.assertArgument = assertArgument;
exports.assertArgumentCount = assertArgumentCount;
exports.assertNormalize = assertNormalize;
exports.assertPrivate = assertPrivate;
exports.checkResultErrors = checkResultErrors;
exports.computeAddress = computeAddress;
exports.computeHmac = computeHmac;
exports.concat = concat;
exports.dataLength = dataLength;
exports.dataSlice = dataSlice;
exports.decodeBase58 = decodeBase58;
exports.decodeBase64 = decodeBase64;
exports.decodeBytes32String = decodeBytes32String;
exports.decodeRlp = decodeRlp;
exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
exports.decryptKeystoreJson = decryptKeystoreJson;
exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
exports.defaultPath = void 0;
exports.defineProperties = defineProperties;
exports.dnsEncode = dnsEncode;
exports.encodeBase58 = encodeBase58;
exports.encodeBase64 = encodeBase64;
exports.encodeBytes32String = encodeBytes32String;
exports.encodeRlp = encodeRlp;
exports.encryptKeystoreJson = encryptKeystoreJson;
exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
exports.ensNormalize = ensNormalize;
exports.ethers = void 0;
exports.formatEther = formatEther;
exports.formatUnits = formatUnits;
exports.fromTwos = fromTwos;
exports.getAccountPath = getAccountPath;
exports.getAddress = getAddress;
exports.getBigInt = getBigInt;
exports.getBytes = getBytes;
exports.getBytesCopy = getBytesCopy;
exports.getCreate2Address = getCreate2Address;
exports.getCreateAddress = getCreateAddress;
exports.getDefaultProvider = getDefaultProvider;
exports.getIcapAddress = getIcapAddress;
exports.getNumber = getNumber;
exports.getUint = getUint;
exports.hashMessage = hashMessage;
exports.hexlify = hexlify;
exports.id = id;
exports.isAddress = isAddress;
exports.isAddressable = isAddressable;
exports.isBytesLike = isBytesLike;
exports.isCallException = isCallException;
exports.isCrowdsaleJson = isCrowdsaleJson;
exports.isError = isError;
exports.isHexString = isHexString;
exports.isKeystoreJson = isKeystoreJson;
exports.isValidName = isValidName;
exports.keccak256 = keccak256;
exports.lock = lock;
exports.makeError = makeError;
exports.mask = mask;
exports.namehash = namehash;
exports.parseEther = parseEther;
exports.parseUnits = parseUnits;
exports.pbkdf2 = pbkdf2;
exports.randomBytes = randomBytes;
exports.recoverAddress = recoverAddress;
exports.resolveAddress = resolveAddress;
exports.ripemd160 = ripemd160;
exports.scrypt = scrypt;
exports.scryptSync = scryptSync;
exports.sha256 = sha256;
exports.sha512 = sha512;
exports.solidityPacked = solidityPacked;
exports.solidityPackedKeccak256 = solidityPackedKeccak256;
exports.solidityPackedSha256 = solidityPackedSha256;
exports.stripZerosLeft = stripZerosLeft;
exports.toBeArray = toBeArray;
exports.toBeHex = toBeHex;
exports.toBigInt = toBigInt;
exports.toNumber = toNumber;
exports.toQuantity = toQuantity;
exports.toTwos = toTwos;
exports.toUtf8Bytes = toUtf8Bytes;
exports.toUtf8CodePoints = toUtf8CodePoints;
exports.toUtf8String = toUtf8String;
exports.verifyMessage = verifyMessage;
exports.version = void 0;
exports.zeroPadBytes = zeroPadBytes;
exports.zeroPadValue = zeroPadValue;
var _Symbol$iterator, _Symbol$iterator2, _Symbol$for, _Symbol$iterator3, _Symbol$iterator4;
function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
/**
 *  The current version of Ethers.
 */
var version = "6.0.5";

/**
 *  Property helper functions.
 *
 *  @_subsection api/utils:Properties  [about-properties]
 */
exports.version = version;
function checkType(value, type, name) {
  var types = type.split("|").map(function (t) {
    return t.trim();
  });
  for (var i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (_typeof(value) === type) {
          return;
        }
    }
  }
  var error = new Error("invalid value for type ".concat(type));
  error.code = "INVALID_ARGUMENT";
  error.argument = "value.".concat(name);
  error.value = value;
  throw error;
}
/**
 *  Resolves to a new object that is a copy of %%value%%, but with all
 *  values resolved.
 */
function resolveProperties(_x) {
  return _resolveProperties.apply(this, arguments);
}
/**
 *  Assigns the %%values%% to %%target%% as read-only values.
 *
 *  It %%types%% is specified, the values are checked.
 */
function _resolveProperties() {
  _resolveProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee195(value) {
    var keys, results;
    return _regeneratorRuntime().wrap(function _callee195$(_context195) {
      while (1) switch (_context195.prev = _context195.next) {
        case 0:
          keys = Object.keys(value);
          _context195.next = 3;
          return Promise.all(keys.map(function (k) {
            return Promise.resolve(value[k]);
          }));
        case 3:
          results = _context195.sent;
          return _context195.abrupt("return", results.reduce(function (accum, v, index) {
            accum[keys[index]] = v;
            return accum;
          }, {}));
        case 5:
        case "end":
          return _context195.stop();
      }
    }, _callee195);
  }));
  return _resolveProperties.apply(this, arguments);
}
function defineProperties(target, values, types) {
  for (var key in values) {
    var value = values[key];
    var type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, {
      enumerable: true,
      value: value,
      writable: false
    });
  }
}

/**
 *  About Errors.
 *
 *  @_section: api/utils/errors:Errors  [about-errors]
 */
function stringify$1(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify$1).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    var HEX = "0123456789abcdef";
    var result = "0x";
    for (var i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 0xf];
    }
    return result;
  }
  if (_typeof(value) === "object" && typeof value.toJSON === "function") {
    return stringify$1(value.toJSON());
  }
  switch (_typeof(value)) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object":
      {
        var keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map(function (k) {
          return "".concat(stringify$1(k), ": ").concat(stringify$1(value[k]));
        }).join(", ") + " }";
      }
  }
  return "[ COULD NOT SERIALIZE ]";
}
/**
 *  Returns true if the %%error%% matches an error thrown by ethers
 *  that matches the error %%code%%.
 *
 *  In TypeScript envornoments, this can be used to check that %%error%%
 *  matches an EthersError type, which means the expected properties will
 *  be set.
 *
 *  @See [ErrorCodes](api:ErrorCode)
 *  @example
 *    try {
 *      // code....
 *    } catch (e) {
 *      if (isError(e, "CALL_EXCEPTION")) {
 *          // The Type Guard has validated this object
 *          console.log(e.data);
 *      }
 *    }
 */
function isError(error, code) {
  return error && error.code === code;
}
/**
 *  Returns true if %%error%% is a [[CallExceptionError].
 */
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
/**
 *  Returns a new Error configured to the format ethers emits errors, with
 *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties
 *  for the corresponding EthersError.
 *
 *  Each error in ethers includes the version of ethers, a
 *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional
 *  required properties. The error message will also include the %%meeage%%,
 *  ethers version, %%code%% and all aditional properties, serialized.
 */
function makeError(message, code, info) {
  {
    var details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error("value will overwrite populated values: ".concat(stringify$1(info)));
      }
      for (var key in info) {
        var value = info[key];
        //                try {
        details.push(key + "=" + stringify$1(value));
        //                } catch (error: any) {
        //                console.log("MMM", error.message);
        //                    details.push(key + "=[could not serialize object]");
        //                }
      }
    }

    details.push("code=".concat(code));
    details.push("version=".concat(version));
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  var error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, {
    code: code
  });
  if (info) {
    Object.assign(error, info);
  }
  return error;
}
/**
 *  Throws an EthersError with %%message%%, %%code%% and additional error
 *  %%info%% when %%check%% is falsish..
 *
 *  @see [[api:makeError]]
 */
function assert$1(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
/**
 *  A simple helper to simply ensuring provided arguments match expected
 *  constraints, throwing if not.
 *
 *  In TypeScript environments, the %%check%% has been asserted true, so
 *  any further code does not need additional compile-time checks.
 */
function assertArgument(check, message, name, value) {
  assert$1(check, message, "INVALID_ARGUMENT", {
    argument: name,
    value: value
  });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert$1(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count: count,
    expectedCount: expectedCount
  });
  assert$1(count <= expectedCount, "too many arguemnts" + message, "UNEXPECTED_ARGUMENT", {
    count: count,
    expectedCount: expectedCount
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce(function (accum, form) {
  try {
    // General test for normalize
    /* c8 ignore start */
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    /* c8 ignore stop */
    if (form === "NFD") {
      var check = String.fromCharCode(0xe9).normalize("NFD");
      var expected = String.fromCharCode(0x65, 0x0301);
      /* c8 ignore start */
      if (check !== expected) {
        throw new Error("broken");
      }
      /* c8 ignore stop */
    }

    accum.push(form);
  } catch (error) {}
  return accum;
}, []);
/**
 *  Throws if the normalization %%form%% is not supported.
 */
function assertNormalize(form) {
  assert$1(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: {
      form: form
    }
  });
}
/**
 *  Many classes use file-scoped values to guard the constructor,
 *  making it effectively private. This facilitates that pattern
 *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
 *  throwing if not, indicating the %%className%% if provided.
 */
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    var method = className,
      operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert$1(false, "private constructor; use ".concat(method, "from* methods"), "UNSUPPORTED_OPERATION", {
      operation: operation
    });
  }
}

/**
 *  Some data helpers.
 *
 *
 *  @_subsection api/utils:Data Helpers  [about-data]
 */
function _getBytes(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    var result = new Uint8Array((value.length - 2) / 2);
    var offset = 2;
    for (var i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
/**
 *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
 *  the original %%value%% is returned; if a copy is required use
 *  [[getBytesCopy]].
 *
 *  @see: getBytesCopy
 */
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
/**
 *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
 *  to prevent any modifications of the returned value from being
 *  reflected elsewhere.
 *
 *  @see: getBytes
 */
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
/**
 *  Returns true if %%value%% is a valid [[HexString]].
 *
 *  If %%length%% is ``true`` or a //number//, it also checks that
 *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
 *  bytes of data (e.g. ``0x1234`` is 2 bytes).
 */
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
/**
 *  Returns true if %%value%% is a valid representation of arbitrary
 *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
 */
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
var HexCharacters = "0123456789abcdef";
/**
 *  Returns a [[DataHexString]] representation of %%data%%.
 */
function hexlify(data) {
  var bytes = getBytes(data);
  var result = "0x";
  for (var i = 0; i < bytes.length; i++) {
    var v = bytes[i];
    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
  }
  return result;
}
/**
 *  Returns a [[DataHexString]] by concatenating all values
 *  within %%data%%.
 */
function concat(datas) {
  return "0x" + datas.map(function (d) {
    return hexlify(d).substring(2);
  }).join("");
}
/**
 *  Returns the length of %%data%%, in bytes.
 */
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
/**
 *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
 *  offset to the %%end%% offset.
 *
 *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
 */
function dataSlice(data, start, end) {
  var bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    assert$1(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
/**
 *  Return the [[DataHexString]] result by stripping all **leading**
 ** zero bytes from %%data%%.
 */
function stripZerosLeft(data) {
  var bytes = hexlify(data).substring(2);
  while (bytes.startsWith("00")) {
    bytes = bytes.substring(2);
  }
  return "0x" + bytes;
}
function zeroPad(data, length, left) {
  var bytes = getBytes(data);
  assert$1(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes),
    length: length,
    offset: length + 1
  });
  var result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes, length - bytes.length);
  } else {
    result.set(bytes, 0);
  }
  return hexlify(result);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **left**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **values** are in Solidity
 *  (e.g. ``uint128``).
 */
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **right**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **bytes** are in Solidity
 *  (e.g. ``bytes16``).
 */
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}

/**
 *  Some mathematic operations.
 *
 *  @_subsection: api/utils:Math Helpers  [about-maths]
 */
var BN_0$a = BigInt(0);
var BN_1$5 = BigInt(1);
//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
// IEEE 754 support 53-bits of mantissa
var maxValue = 0x1fffffffffffff;
/**
 *  Convert %%value%% from a twos-compliment representation of %%width%%
 *  bits to its value.
 *
 *  If the highest bit is ``1``, the result will be negative.
 */
function fromTwos(_value, _width) {
  var value = getUint(_value, "value");
  var width = BigInt(getNumber(_width, "width"));
  assert$1(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  // Top bit set; treat as a negative value
  if (value >> width - BN_1$5) {
    var _mask = (BN_1$5 << width) - BN_1$5;
    return -((~value & _mask) + BN_1$5);
  }
  return value;
}
/**
 *  Convert %%value%% to a twos-compliment representation of
 *  %%width%% bits.
 *
 *  The result will always be positive.
 */
function toTwos(_value, _width) {
  var value = getBigInt(_value, "value");
  var width = BigInt(getNumber(_width, "width"));
  var limit = BN_1$5 << width - BN_1$5;
  if (value < BN_0$a) {
    value = -value;
    assert$1(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    var _mask2 = (BN_1$5 << width) - BN_1$5;
    return (~value & _mask2) + BN_1$5;
  } else {
    assert$1(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
/**
 *  Mask %%value%% with a bitmask of %%bits%% ones.
 */
function mask(_value, _bits) {
  var value = getUint(_value, "value");
  var bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$5 << bits) - BN_1$5;
}
/**
 *  Gets a BigInt from %%value%%. If it is an invalid value for
 *  a BigInt, then an ArgumentError will be thrown for %%name%%.
 */
function getBigInt(value, name) {
  switch (_typeof(value)) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, "invalid BigNumberish string: ".concat(e.message), name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  var result = getBigInt(value, name);
  assert$1(result >= BN_0$a, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: value
  });
  return result;
}
var Nibbles$1 = "0123456789abcdef";
/*
 * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
 * is treated as Big Endian data.
 */
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    var result = "0x0";
    var _iterator = _createForOfIteratorHelper(value),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var v = _step.value;
        result += Nibbles$1[v >> 4];
        result += Nibbles$1[v & 0x0f];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
/**
 *  Gets a //number// from %%value%%. If it is an invalid value for
 *  a //number//, then an ArgumentError will be thrown for %%name%%.
 */
function getNumber(value, name) {
  switch (_typeof(value)) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, "invalid numeric string: ".concat(e.message), name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
/**
 *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
 *  is treated as Big Endian data. Throws if the value is not safe.
 */
function toNumber(value) {
  return getNumber(toBigInt(value));
}
/**
 *  Converts %%value%% to a Big Endian hexstring, optionally padded to
 *  %%width%% bytes.
 */
function toBeHex(_value, _width) {
  var value = getUint(_value, "value");
  var result = value.toString(16);
  if (_width == null) {
    // Ensure the value is of even length
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    var width = getNumber(_width, "width");
    assert$1(width * 2 >= result.length, "value exceeds width (".concat(width, " bits)"), "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    // Pad the value to the required width
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
/**
 *  Converts %%value%% to a Big Endian Uint8Array.
 */
function toBeArray(_value) {
  var value = getUint(_value, "value");
  if (value === BN_0$a) {
    return new Uint8Array([]);
  }
  var hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  var result = new Uint8Array(hex.length / 2);
  for (var i = 0; i < result.length; i++) {
    var offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
/**
 *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
 *
 *  A //Quantity// does not have and leading 0 values unless the value is
 *  the literal value `0x0`. This is most commonly used for JSSON-RPC
 *  numeric values.
 */
function toQuantity(value) {
  var result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}

/**
 *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value
 *  to be encoded as a compact string using a radix of 58 using only
 *  alpha-numeric characters. Confusingly similar characters are omitted
 *  (i.e. ``"l0O"``).
 *
 *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,
 *  since any zero-bytes on the left would get removed. To mitigate this
 *  issue most schemes that use Base58 choose specific high-order values
 *  to ensure non-zero prefixes.
 *
 *  @_subsection: api/utils:Base58 Encoding [about-base58]
 */
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (var i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  var result = Lookup[letter];
  assertArgument(result != null, "invalid base58 value", "letter", letter);
  return result;
}
var BN_0$9 = BigInt(0);
var BN_58 = BigInt(58);
/**
 *  Encode %%value%% as a Base58-encoded string.
 */
function encodeBase58(_value) {
  var value = toBigInt(getBytes(_value));
  var result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  return result;
}
/**
 *  Decode the Base58-encoded %%value%%.
 */
function decodeBase58(value) {
  var result = BN_0$9;
  for (var i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}

// utils/base64-browser
function decodeBase64(textData) {
  textData = atob(textData);
  var data = new Uint8Array(textData.length);
  for (var i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data) {
  var data = getBytes(_data);
  var textData = "";
  for (var i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

/**
 *  Explain events...
 *
 *  @_section api/utils/events:Events  [about-events]
 */
/**
 *  When an [[EventEmitterable]] triggers a [[Listener]], the
 *  callback always ahas one additional argument passed, which is
 *  an **EventPayload**.
 */
var _listener = /*#__PURE__*/new WeakMap();
var EventPayload = /*#__PURE__*/function () {
  /**
   *  The event filter.
   */

  /**
   *  The **EventEmitterable**.
   */

  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  function EventPayload(emitter, listener, filter) {
    _classCallCheck(this, EventPayload);
    _defineProperty(this, "filter", void 0);
    _defineProperty(this, "emitter", void 0);
    _classPrivateFieldInitSpec(this, _listener, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _listener, listener);
    defineProperties(this, {
      emitter: emitter,
      filter: filter
    });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  _createClass(EventPayload, [{
    key: "removeListener",
    value: function () {
      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(_classPrivateFieldGet(this, _listener) == null)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _context.next = 4;
              return this.emitter.off(this.filter, _classPrivateFieldGet(this, _listener));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function removeListener() {
        return _removeListener.apply(this, arguments);
      }
      return removeListener;
    }()
  }]);
  return EventPayload;
}();
/**
 *  Using strings in Ethereum (or any security-basd system) requires
 *  additional care. These utilities attempt to mitigate some of the
 *  safety issues as well as provide the ability to recover and analyse
 *  strings.
 *
 *  @_subsection api/utils:Strings and UTF-8  [about-strings]
 */
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  assertArgument(false, "invalid codepoint at offset ".concat(offset, "; ").concat(reason), "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    var i = 0;
    for (var o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 0x02) {
        break;
      }
      i++;
    }
    return i;
  }
  // This byte runs us past the end of the string, so just jump to the end
  // (but the first byte was read already read and therefore skipped)
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  // Nothing to skip
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  // Overlong representations are otherwise "valid" code points; just non-deistingtished
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  // Put the replacement character into the output
  output.push(0xfffd);
  // Otherwise, process as if ignoring errors
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
/**
 *  A handful of popular, built-in UTF-8 error handling strategies.
 *
 *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
 *  non-canonical (overlong) codepoints (this is the default)
 *
 *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
 *  and accepts non-canonical (overlong) codepoints
 *
 *  **``"replace"``** - replace any illegal UTF-8 sequence with the
 *  UTF-8 replacement character (i.e. `\ufffd`) and accepts
 *  non-canonical (overlong) codepoints
 *
 *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
 */
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
exports.Utf8ErrorFuncs = Utf8ErrorFuncs;
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  var bytes = getBytes(_bytes, "bytes");
  var result = [];
  var i = 0;
  // Invalid bytes are ignored
  while (i < bytes.length) {
    var c = bytes[i++];
    // 0xxx xxxx
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    // Multibyte; how many bytes left for this character?
    var extraLength = null;
    var overlongMask = null;
    // 110x xxxx 10xx xxxx
    if ((c & 0xe0) === 0xc0) {
      extraLength = 1;
      overlongMask = 0x7f;
      // 1110 xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf0) === 0xe0) {
      extraLength = 2;
      overlongMask = 0x7ff;
      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf8) === 0xf0) {
      extraLength = 3;
      overlongMask = 0xffff;
    } else {
      if ((c & 0xc0) === 0x80) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    // Do we have enough bytes in our data?
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    // Remove the length prefix from the char
    var res = c & (1 << 8 - extraLength - 1) - 1;
    for (var j = 0; j < extraLength; j++) {
      var nextChar = bytes[i];
      // Invalid continuation byte
      if ((nextChar & 0xc0) != 0x80) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 0x3f;
      i++;
    }
    // See above loop for invalid continuation byte
    if (res === null) {
      continue;
    }
    // Maximum code point
    if (res > 0x10ffff) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Reserved for UTF-16 surrogate halves
    if (res >= 0xd800 && res <= 0xdfff) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Check for overlong sequences (more bytes than needed)
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
/**
 *  Returns the UTF-8 byte representation of %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8Bytes(str, form) {
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 0x80) {
      result.push(c);
    } else if (c < 0x800) {
      result.push(c >> 6 | 0xc0);
      result.push(c & 0x3f | 0x80);
    } else if ((c & 0xfc00) == 0xd800) {
      i++;
      var c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 0xfc00) === 0xdc00, "invalid surrogate pair", "str", str);
      // Surrogate Pair
      var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
      result.push(pair >> 18 | 0xf0);
      result.push(pair >> 12 & 0x3f | 0x80);
      result.push(pair >> 6 & 0x3f | 0x80);
      result.push(pair & 0x3f | 0x80);
    } else {
      result.push(c >> 12 | 0xe0);
      result.push(c >> 6 & 0x3f | 0x80);
      result.push(c & 0x3f | 0x80);
    }
  }
  return new Uint8Array(result);
}
;
//export 
function _toUtf8String(codePoints) {
  return codePoints.map(function (codePoint) {
    if (codePoint <= 0xffff) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 0x10000;
    return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
  }).join("");
}
/**
 *  Returns the string represented by the UTF-8 data %%bytes%%.
 *
 *  When %%onError%% function is specified, it is called on UTF-8
 *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
 *  (default: [error](Utf8ErrorFuncs))
 */
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
/**
 *  Returns the UTF-8 code-points for %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// @TODO: timeout is completely ignored; start a Promise.any with a reject?
function getUrl(_x2, _x3) {
  return _getUrl.apply(this, arguments);
}
/**
 *  Explain fetching here...
 *
 *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]
 */
function _getUrl() {
  _getUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee196(req, _signal) {
    var protocol, signal, controller, init, resp, headers, respBody, body;
    return _regeneratorRuntime().wrap(function _callee196$(_context196) {
      while (1) switch (_context196.prev = _context196.next) {
        case 0:
          protocol = req.url.split(":")[0].toLowerCase();
          assert$1(protocol === "http" || protocol === "https", "unsupported protocol ".concat(protocol), "UNSUPPORTED_OPERATION", {
            info: {
              protocol: protocol
            },
            operation: "request"
          });
          assert$1(!req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
          });
          signal = undefined;
          if (_signal) {
            controller = new AbortController();
            signal = controller.signal;
            _signal.addListener(function () {
              controller.abort();
            });
          }
          init = {
            method: req.method,
            headers: new Headers(Array.from(req)),
            body: req.body || undefined,
            signal: signal
          };
          _context196.next = 8;
          return fetch(req.url, init);
        case 8:
          resp = _context196.sent;
          headers = {};
          resp.headers.forEach(function (value, key) {
            headers[key.toLowerCase()] = value;
          });
          _context196.next = 13;
          return resp.arrayBuffer();
        case 13:
          respBody = _context196.sent;
          body = respBody == null ? null : new Uint8Array(respBody);
          return _context196.abrupt("return", {
            statusCode: resp.status,
            statusMessage: resp.statusText,
            headers: headers,
            body: body
          });
        case 16:
        case "end":
          return _context196.stop();
      }
    }, _callee196);
  }));
  return _getUrl.apply(this, arguments);
}
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
// The global FetchGetUrlFunc implementation.
var getUrlFunc = getUrl;
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
// If locked, new Gateways cannot be added
var locked$5 = false;
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
function dataGatewayFunc(_x4, _x5) {
  return _dataGatewayFunc.apply(this, arguments);
}
/**
 *  Returns a [[FetchGatewayFunc]] for fetching content from a standard
 *  IPFS gateway hosted at %%baseUrl%%.
 */
function _dataGatewayFunc() {
  _dataGatewayFunc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee197(url, signal) {
    var match;
    return _regeneratorRuntime().wrap(function _callee197$(_context197) {
      while (1) switch (_context197.prev = _context197.next) {
        case 0:
          _context197.prev = 0;
          match = url.match(reData);
          if (match) {
            _context197.next = 4;
            break;
          }
          throw new Error("invalid data");
        case 4:
          return _context197.abrupt("return", new FetchResponse(200, "OK", {
            "content-type": match[1] || "text/plain"
          }, match[2] ? decodeBase64(match[3]) : unpercent(match[3])));
        case 7:
          _context197.prev = 7;
          _context197.t0 = _context197["catch"](0);
          return _context197.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url)));
        case 10:
        case "end":
          return _context197.stop();
      }
    }, _callee197, null, [[0, 7]]);
  }));
  return _dataGatewayFunc.apply(this, arguments);
}
function getIpfsGatewayFunc(baseUrl) {
  function gatewayIpfs(_x6, _x7) {
    return _gatewayIpfs.apply(this, arguments);
  }
  function _gatewayIpfs() {
    _gatewayIpfs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, signal) {
      var match;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            match = url.match(reIpfs);
            if (match) {
              _context2.next = 4;
              break;
            }
            throw new Error("invalid link");
          case 4:
            return _context2.abrupt("return", new FetchRequest("".concat(baseUrl).concat(match[2])));
          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            return _context2.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url)));
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 7]]);
    }));
    return _gatewayIpfs.apply(this, arguments);
  }
  return gatewayIpfs;
}
var Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
};
var fetchSignals = new WeakMap();
/**
 *  @_ignore
 */
var _listeners = /*#__PURE__*/new WeakMap();
var _cancelled = /*#__PURE__*/new WeakMap();
var FetchCancelSignal = /*#__PURE__*/function () {
  function FetchCancelSignal(request) {
    var _this2 = this;
    _classCallCheck(this, FetchCancelSignal);
    _classPrivateFieldInitSpec(this, _listeners, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _cancelled, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _listeners, []);
    _classPrivateFieldSet(this, _cancelled, false);
    fetchSignals.set(request, function () {
      if (_classPrivateFieldGet(_this2, _cancelled)) {
        return;
      }
      _classPrivateFieldSet(_this2, _cancelled, true);
      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_this2, _listeners)),
        _step2;
      try {
        var _loop = function _loop() {
          var listener = _step2.value;
          setTimeout(function () {
            listener();
          }, 0);
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _classPrivateFieldSet(_this2, _listeners, []);
    });
  }
  _createClass(FetchCancelSignal, [{
    key: "addListener",
    value: function addListener(listener) {
      assert$1(!_classPrivateFieldGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
        operation: "fetchCancelSignal.addCancelListener"
      });
      _classPrivateFieldGet(this, _listeners).push(listener);
    }
  }, {
    key: "cancelled",
    get: function get() {
      return _classPrivateFieldGet(this, _cancelled);
    }
  }, {
    key: "checkSignal",
    value: function checkSignal() {
      assert$1(!this.cancelled, "cancelled", "CANCELLED", {});
    }
  }]);
  return FetchCancelSignal;
}(); // Check the signal, throwing if it is cancelled
exports.FetchCancelSignal = FetchCancelSignal;
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
/**
 *  Represents a request for a resource using a URI.
 *
 *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
 *  and ``IPFS:``.
 *
 *  Additional schemes can be added globally using [[registerGateway]].
 *
 *  @example:
 *    req = new FetchRequest("https://www.ricmoo.com")
 *    resp = await req.send()
 *    resp.body.length
 *    //_result:
 */
var _allowInsecure = /*#__PURE__*/new WeakMap();
var _gzip = /*#__PURE__*/new WeakMap();
var _headers = /*#__PURE__*/new WeakMap();
var _method = /*#__PURE__*/new WeakMap();
var _timeout2 = /*#__PURE__*/new WeakMap();
var _url = /*#__PURE__*/new WeakMap();
var _body = /*#__PURE__*/new WeakMap();
var _bodyType = /*#__PURE__*/new WeakMap();
var _creds = /*#__PURE__*/new WeakMap();
var _preflight = /*#__PURE__*/new WeakMap();
var _process = /*#__PURE__*/new WeakMap();
var _retry = /*#__PURE__*/new WeakMap();
var _signal2 = /*#__PURE__*/new WeakMap();
var _throttle = /*#__PURE__*/new WeakMap();
var _send = /*#__PURE__*/new WeakSet();
_Symbol$iterator = Symbol.iterator;
var FetchRequest = /*#__PURE__*/function () {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make teh request.
   */
  function FetchRequest(url) {
    _classCallCheck(this, FetchRequest);
    _classPrivateMethodInitSpec(this, _send);
    _classPrivateFieldInitSpec(this, _allowInsecure, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _gzip, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _headers, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _method, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _timeout2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _url, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _body, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _bodyType, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _creds, {
      writable: true,
      value: void 0
    });
    // Hooks
    _classPrivateFieldInitSpec(this, _preflight, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _process, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _retry, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _signal2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _throttle, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _url, String(url));
    _classPrivateFieldSet(this, _allowInsecure, false);
    _classPrivateFieldSet(this, _gzip, true);
    _classPrivateFieldSet(this, _headers, {});
    _classPrivateFieldSet(this, _method, "");
    _classPrivateFieldSet(this, _timeout2, 300000);
    _classPrivateFieldSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
  }
  _createClass(FetchRequest, [{
    key: "url",
    get:
    /**
     *  The fetch URI to requrest.
     */
    function get() {
      return _classPrivateFieldGet(this, _url);
    },
    set: function set(url) {
      _classPrivateFieldSet(this, _url, String(url));
    }
    /**
     *  The fetch body, if any, to send as the request body. //(default: null)//
     *
     *  When setting a body, the intrinsic ``Content-Type`` is automatically
     *  set and will be used if **not overridden** by setting a custom
     *  header.
     *
     *  If %%body%% is null, the body is cleared (along with the
     *  intrinsic ``Content-Type``) and the .
     *
     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to
     *  ``text/plain``.
     *
     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to
     *  ``application/octet-stream``.
     *
     *  If %%body%% is any other object, the intrincis ``Content-Type`` is
     *  set to ``application/json``.
     */
  }, {
    key: "body",
    get: function get() {
      if (_classPrivateFieldGet(this, _body) == null) {
        return null;
      }
      return new Uint8Array(_classPrivateFieldGet(this, _body));
    },
    set: function set(body) {
      if (body == null) {
        _classPrivateFieldSet(this, _body, undefined);
        _classPrivateFieldSet(this, _bodyType, undefined);
      } else if (typeof body === "string") {
        _classPrivateFieldSet(this, _body, toUtf8Bytes(body));
        _classPrivateFieldSet(this, _bodyType, "text/plain");
      } else if (body instanceof Uint8Array) {
        _classPrivateFieldSet(this, _body, body);
        _classPrivateFieldSet(this, _bodyType, "application/octet-stream");
      } else if (_typeof(body) === "object") {
        _classPrivateFieldSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
        _classPrivateFieldSet(this, _bodyType, "application/json");
      } else {
        throw new Error("invalid body");
      }
    }
    /**
     *  Returns true if the request has a body.
     */
  }, {
    key: "hasBody",
    value: function hasBody() {
      return _classPrivateFieldGet(this, _body) != null;
    }
    /**
     *  The HTTP method to use when requesting the URI. If no method
     *  has been explicitly set, then ``GET`` is used if the body is
     *  null and ``POST`` otherwise.
     */
  }, {
    key: "method",
    get: function get() {
      if (_classPrivateFieldGet(this, _method)) {
        return _classPrivateFieldGet(this, _method);
      }
      if (this.hasBody()) {
        return "POST";
      }
      return "GET";
    },
    set: function set(method) {
      if (method == null) {
        method = "";
      }
      _classPrivateFieldSet(this, _method, String(method).toUpperCase());
    }
    /**
     *  The headers that will be used when requesting the URI. All
     *  keys are lower-case.
     *
     *  This object is a copy, so any chnages will **NOT** be reflected
     *  in the ``FetchRequest``.
     *
     *  To set a header entry, use the ``setHeader`` method.
     */
  }, {
    key: "headers",
    get: function get() {
      var headers = Object.assign({}, _classPrivateFieldGet(this, _headers));
      if (_classPrivateFieldGet(this, _creds)) {
        headers["authorization"] = "Basic ".concat(encodeBase64(toUtf8Bytes(_classPrivateFieldGet(this, _creds))));
      }
      ;
      if (this.allowGzip) {
        headers["accept-encoding"] = "gzip";
      }
      if (headers["content-type"] == null && _classPrivateFieldGet(this, _bodyType)) {
        headers["content-type"] = _classPrivateFieldGet(this, _bodyType);
      }
      if (this.body) {
        headers["content-length"] = String(this.body.length);
      }
      return headers;
    }
    /**
     *  Get the header for %%key%%, ignoring case.
     */
  }, {
    key: "getHeader",
    value: function getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    /**
     *  Set the header for %%key%% to %%value%%. All values are coerced
     *  to a string.
     */
  }, {
    key: "setHeader",
    value: function setHeader(key, value) {
      _classPrivateFieldGet(this, _headers)[String(key).toLowerCase()] = String(value);
    }
    /**
     *  Clear all headers, resetting all intrinsic headers.
     */
  }, {
    key: "clearHeaders",
    value: function clearHeaders() {
      _classPrivateFieldSet(this, _headers, {});
    }
  }, {
    key: _Symbol$iterator,
    value: function value() {
      var headers = this.headers;
      var keys = Object.keys(headers);
      var index = 0;
      return {
        next: function next() {
          if (index < keys.length) {
            var key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
    /**
     *  The value that will be sent for the ``Authorization`` header.
     *
     *  To set the credentials, use the ``setCredentials`` method.
     */
  }, {
    key: "credentials",
    get: function get() {
      return _classPrivateFieldGet(this, _creds) || null;
    }
    /**
     *  Sets an ``Authorization`` for %%username%% with %%password%%.
     */
  }, {
    key: "setCredentials",
    value: function setCredentials(username, password) {
      assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
      _classPrivateFieldSet(this, _creds, "".concat(username, ":").concat(password));
    }
    /**
     *  Enable and request gzip-encoded responses. The response will
     *  automatically be decompressed. //(default: true)//
     */
  }, {
    key: "allowGzip",
    get: function get() {
      return _classPrivateFieldGet(this, _gzip);
    }
  }, {
    key: "allowGzip",
    set: function set(value) {
      _classPrivateFieldSet(this, _gzip, !!value);
    }
    /**
     *  Allow ``Authentication`` credentials to be sent over insecure
     *  channels. //(default: false)//
     */
  }, {
    key: "allowInsecureAuthentication",
    get: function get() {
      return !!_classPrivateFieldGet(this, _allowInsecure);
    }
  }, {
    key: "allowInsecureAuthentication",
    set: function set(value) {
      _classPrivateFieldSet(this, _allowInsecure, !!value);
    }
    /**
     *  The timeout (in milliseconds) to wait for a complere response.
     *  //(default: 5 minutes)//
     */
  }, {
    key: "timeout",
    get: function get() {
      return _classPrivateFieldGet(this, _timeout2);
    }
  }, {
    key: "timeout",
    set: function set(timeout) {
      assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
      _classPrivateFieldSet(this, _timeout2, timeout);
    }
    /**
     *  This function is called prior to each request, for example
     *  during a redirection or retry in case of server throttling.
     *
     *  This offers an opportunity to populate headers or update
     *  content before sending a request.
     */
  }, {
    key: "preflightFunc",
    get: function get() {
      return _classPrivateFieldGet(this, _preflight) || null;
    }
  }, {
    key: "preflightFunc",
    set: function set(preflight) {
      _classPrivateFieldSet(this, _preflight, preflight);
    }
    /**
     *  This function is called after each response, offering an
     *  opportunity to provide client-level throttling or updating
     *  response data.
     *
     *  Any error thrown in this causes the ``send()`` to throw.
     *
     *  To schedule a retry attempt (assuming the maximum retry limit
     *  has not been reached), use [[response.throwThrottleError]].
     */
  }, {
    key: "processFunc",
    get: function get() {
      return _classPrivateFieldGet(this, _process) || null;
    }
  }, {
    key: "processFunc",
    set: function set(process) {
      _classPrivateFieldSet(this, _process, process);
    }
    /**
     *  This function is called on each retry attempt.
     */
  }, {
    key: "retryFunc",
    get: function get() {
      return _classPrivateFieldGet(this, _retry) || null;
    }
  }, {
    key: "retryFunc",
    set: function set(retry) {
      _classPrivateFieldSet(this, _retry, retry);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "<FetchRequest method=".concat(JSON.stringify(this.method), " url=").concat(JSON.stringify(this.url), " headers=").concat(JSON.stringify(this.headers), " body=").concat(_classPrivateFieldGet(this, _body) ? hexlify(_classPrivateFieldGet(this, _body)) : "null", ">");
    }
    /**
     *  Update the throttle parameters used to determine maximum
     *  attempts and exponential-backoff properties.
     */
  }, {
    key: "setThrottleParams",
    value: function setThrottleParams(params) {
      if (params.slotInterval != null) {
        _classPrivateFieldGet(this, _throttle).slotInterval = params.slotInterval;
      }
      if (params.maxAttempts != null) {
        _classPrivateFieldGet(this, _throttle).maxAttempts = params.maxAttempts;
      }
    }
  }, {
    key: "send",
    value:
    /**
     *  Resolves to the response by sending the request.
     */
    function send() {
      assert$1(_classPrivateFieldGet(this, _signal2) == null, "request already sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.send"
      });
      _classPrivateFieldSet(this, _signal2, new FetchCancelSignal(this));
      return _classPrivateMethodGet(this, _send, _send2).call(this, 0, getTime$2() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
    }
    /**
     *  Cancels the inflight response, causing a ``CANCELLED``
     *  error to be rejected from the [[send]].
     */
  }, {
    key: "cancel",
    value: function cancel() {
      assert$1(_classPrivateFieldGet(this, _signal2) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.cancel"
      });
      var signal = fetchSignals.get(this);
      if (!signal) {
        throw new Error("missing signal; should not happen");
      }
      signal();
    }
    /**
     *  Returns a new [[FetchRequest]] that represents the redirection
     *  to %%location%%.
     */
  }, {
    key: "redirect",
    value: function redirect(location) {
      // Redirection; for now we only support absolute locataions
      var current = this.url.split(":")[0].toLowerCase();
      var target = location.split(":")[0].toLowerCase();
      // Don't allow redirecting:
      // - non-GET requests
      // - downgrading the security (e.g. https => http)
      // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
      assert$1(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
        operation: "redirect(".concat(this.method, " ").concat(JSON.stringify(this.url), " => ").concat(JSON.stringify(location), ")")
      });
      // Create a copy of this request, with a new URL
      var req = new FetchRequest(location);
      req.method = "GET";
      req.allowGzip = this.allowGzip;
      req.timeout = this.timeout;
      _classPrivateFieldSet(req, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));
      if (_classPrivateFieldGet(this, _body)) {
        _classPrivateFieldSet(req, _body, new Uint8Array(_classPrivateFieldGet(this, _body)));
      }
      _classPrivateFieldSet(req, _bodyType, _classPrivateFieldGet(this, _bodyType));
      // Do not forward credentials unless on the same domain; only absolute
      //req.allowInsecure = false;
      // paths are currently supported; may want a way to specify to forward?
      //setStore(req.#props, "creds", getStore(this.#pros, "creds"));
      return req;
    }
    /**
     *  Create a new copy of this request.
     */
  }, {
    key: "clone",
    value: function clone() {
      var clone = new FetchRequest(this.url);
      // Preserve "default method" (i.e. null)
      _classPrivateFieldSet(clone, _method, _classPrivateFieldGet(this, _method));
      // Preserve "default body" with type, copying the Uint8Array is present
      if (_classPrivateFieldGet(this, _body)) {
        _classPrivateFieldSet(clone, _body, _classPrivateFieldGet(this, _body));
      }
      _classPrivateFieldSet(clone, _bodyType, _classPrivateFieldGet(this, _bodyType));
      // Preserve "default headers"
      _classPrivateFieldSet(clone, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));
      // Credentials is readonly, so we copy internally
      _classPrivateFieldSet(clone, _creds, _classPrivateFieldGet(this, _creds));
      if (this.allowGzip) {
        clone.allowGzip = true;
      }
      clone.timeout = this.timeout;
      if (this.allowInsecureAuthentication) {
        clone.allowInsecureAuthentication = true;
      }
      _classPrivateFieldSet(clone, _preflight, _classPrivateFieldGet(this, _preflight));
      _classPrivateFieldSet(clone, _process, _classPrivateFieldGet(this, _process));
      _classPrivateFieldSet(clone, _retry, _classPrivateFieldGet(this, _retry));
      return clone;
    }
    /**
     *  Locks all static configuration for gateways and FetchGetUrlFunc
     *  registration.
     */
  }], [{
    key: "lockConfig",
    value: function lockConfig() {
      locked$5 = true;
    }
    /**
     *  Get the current Gateway function for %%scheme%%.
     */
  }, {
    key: "getGateway",
    value: function getGateway(scheme) {
      return Gateways[scheme.toLowerCase()] || null;
    }
    /**
     *  Use the %%func%% when fetching URIs using %%scheme%%.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
  }, {
    key: "registerGateway",
    value: function registerGateway(scheme, func) {
      scheme = scheme.toLowerCase();
      if (scheme === "http" || scheme === "https") {
        throw new Error("cannot intercept ".concat(scheme, "; use registerGetUrl"));
      }
      if (locked$5) {
        throw new Error("gateways locked");
      }
      Gateways[scheme] = func;
    }
    /**
     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
  }, {
    key: "registerGetUrl",
    value: function registerGetUrl(getUrl) {
      if (locked$5) {
        throw new Error("gateways locked");
      }
      getUrlFunc = getUrl;
    }
    /**
     *  Creates a function that can "fetch" data URIs.
     *
     *  Note that this is automatically done internally to support
     *  data URIs, so it is not necessary to register it.
     *
     *  This is not generally something that is needed, but may
     *  be useful in a wrapper to perfom custom data URI functionality.
     */
  }, {
    key: "createDataGateway",
    value: function createDataGateway() {
      return dataGatewayFunc;
    }
    /**
     *  Creates a function that will fetch IPFS (unvalidated) from
     *  a custom gateway baseUrl.
     *
     *  The default IPFS gateway used internally is
     *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
     */
  }, {
    key: "createIpfsGatewayFunc",
    value: function createIpfsGatewayFunc(baseUrl) {
      return getIpfsGatewayFunc(baseUrl);
    }
  }]);
  return FetchRequest;
}();
exports.FetchRequest = FetchRequest;
function _send2(_x280, _x281, _x282, _x283, _x284) {
  return _send10.apply(this, arguments);
}
function _send10() {
  _send10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee225(attempt, expires, delay, _request, _response) {
    var req, scheme, result, _response2, resp, response, _req$redirect, location, _req$clone, retryAfter, _delay, _req$clone2, _delay2;
    return _regeneratorRuntime().wrap(function _callee225$(_context228) {
      while (1) switch (_context228.prev = _context228.next) {
        case 0:
          if (!(attempt >= _classPrivateFieldGet(this, _throttle).maxAttempts)) {
            _context228.next = 2;
            break;
          }
          return _context228.abrupt("return", _response.makeServerError("exceeded maximum retry limit"));
        case 2:
          assert$1(getTime$2() <= expires, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: _request
          });
          if (!(delay > 0)) {
            _context228.next = 6;
            break;
          }
          _context228.next = 6;
          return wait(delay);
        case 6:
          req = this.clone();
          scheme = (req.url.split(":")[0] || "").toLowerCase(); // Process any Gateways
          if (!(scheme in Gateways)) {
            _context228.next = 27;
            break;
          }
          _context228.next = 11;
          return Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet(_request, _signal2)));
        case 11:
          result = _context228.sent;
          if (!(result instanceof FetchResponse)) {
            _context228.next = 26;
            break;
          }
          _response2 = result;
          if (!this.processFunc) {
            _context228.next = 25;
            break;
          }
          checkSignal(_classPrivateFieldGet(_request, _signal2));
          _context228.prev = 16;
          _context228.next = 19;
          return this.processFunc(req, _response2);
        case 19:
          _response2 = _context228.sent;
          _context228.next = 25;
          break;
        case 22:
          _context228.prev = 22;
          _context228.t0 = _context228["catch"](16);
          // Something went wrong during processing; throw a 5xx server error
          if (_context228.t0.throttle == null || typeof _context228.t0.stall !== "number") {
            _response2.makeServerError("error in post-processing function", _context228.t0).assertOk();
          }
          // Ignore throttling
        case 25:
          return _context228.abrupt("return", _response2);
        case 26:
          req = result;
        case 27:
          if (!this.preflightFunc) {
            _context228.next = 31;
            break;
          }
          _context228.next = 30;
          return this.preflightFunc(req);
        case 30:
          req = _context228.sent;
        case 31:
          _context228.next = 33;
          return getUrlFunc(req, checkSignal(_classPrivateFieldGet(_request, _signal2)));
        case 33:
          resp = _context228.sent;
          response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
          if (!(response.statusCode === 301 || response.statusCode === 302)) {
            _context228.next = 46;
            break;
          }
          _context228.prev = 36;
          location = response.headers.location || "";
          return _context228.abrupt("return", _classPrivateMethodGet(_req$redirect = req.redirect(location), _send, _send2).call(_req$redirect, attempt + 1, expires, 0, _request, response));
        case 41:
          _context228.prev = 41;
          _context228.t1 = _context228["catch"](36);
        case 43:
          return _context228.abrupt("return", response);
        case 46:
          if (!(response.statusCode === 429)) {
            _context228.next = 57;
            break;
          }
          _context228.t2 = this.retryFunc == null;
          if (_context228.t2) {
            _context228.next = 52;
            break;
          }
          _context228.next = 51;
          return this.retryFunc(req, response, attempt);
        case 51:
          _context228.t2 = _context228.sent;
        case 52:
          if (!_context228.t2) {
            _context228.next = 57;
            break;
          }
          retryAfter = response.headers["retry-after"];
          _delay = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
            _delay = parseInt(retryAfter);
          }
          return _context228.abrupt("return", _classPrivateMethodGet(_req$clone = req.clone(), _send, _send2).call(_req$clone, attempt + 1, expires, _delay, _request, response));
        case 57:
          if (!this.processFunc) {
            _context228.next = 72;
            break;
          }
          checkSignal(_classPrivateFieldGet(_request, _signal2));
          _context228.prev = 59;
          _context228.next = 62;
          return this.processFunc(req, response);
        case 62:
          response = _context228.sent;
          _context228.next = 72;
          break;
        case 65:
          _context228.prev = 65;
          _context228.t3 = _context228["catch"](59);
          // Something went wrong during processing; throw a 5xx server error
          if (_context228.t3.throttle == null || typeof _context228.t3.stall !== "number") {
            response.makeServerError("error in post-processing function", _context228.t3).assertOk();
          }
          // Throttle
          _delay2 = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          ;
          if (_context228.t3.stall >= 0) {
            _delay2 = _context228.t3.stall;
          }
          return _context228.abrupt("return", _classPrivateMethodGet(_req$clone2 = req.clone(), _send, _send2).call(_req$clone2, attempt + 1, expires, _delay2, _request, response));
        case 72:
          return _context228.abrupt("return", response);
        case 73:
        case "end":
          return _context228.stop();
      }
    }, _callee225, this, [[16, 22], [36, 41], [59, 65]]);
  }));
  return _send10.apply(this, arguments);
}
;
/**
 *  The response for a FetchREquest.
 */
var _statusCode = /*#__PURE__*/new WeakMap();
var _statusMessage = /*#__PURE__*/new WeakMap();
var _headers2 = /*#__PURE__*/new WeakMap();
var _body2 = /*#__PURE__*/new WeakMap();
var _request2 = /*#__PURE__*/new WeakMap();
var _error2 = /*#__PURE__*/new WeakMap();
_Symbol$iterator2 = Symbol.iterator;
var FetchResponse = /*#__PURE__*/function () {
  function FetchResponse(statusCode, statusMessage, headers, body, request) {
    _classCallCheck(this, FetchResponse);
    _classPrivateFieldInitSpec(this, _statusCode, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _statusMessage, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _headers2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _body2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _request2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _error2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _statusCode, statusCode);
    _classPrivateFieldSet(this, _statusMessage, statusMessage);
    _classPrivateFieldSet(this, _headers2, Object.keys(headers).reduce(function (accum, k) {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {}));
    _classPrivateFieldSet(this, _body2, body == null ? null : new Uint8Array(body));
    _classPrivateFieldSet(this, _request2, request || null);
    _classPrivateFieldSet(this, _error2, {
      message: ""
    });
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  _createClass(FetchResponse, [{
    key: "toString",
    value: function toString() {
      return "<FetchResponse status=".concat(this.statusCode, " body=").concat(_classPrivateFieldGet(this, _body2) ? hexlify(_classPrivateFieldGet(this, _body2)) : "null", ">");
    }
    /**
     *  The response status code.
     */
  }, {
    key: "statusCode",
    get: function get() {
      return _classPrivateFieldGet(this, _statusCode);
    }
    /**
     *  The response status message.
     */
  }, {
    key: "statusMessage",
    get: function get() {
      return _classPrivateFieldGet(this, _statusMessage);
    }
    /**
     *  The response headers. All keys are lower-case.
     */
  }, {
    key: "headers",
    get: function get() {
      return Object.assign({}, _classPrivateFieldGet(this, _headers2));
    }
    /**
     *  The response body, or ``null`` if there was no body.
     */
  }, {
    key: "body",
    get: function get() {
      return _classPrivateFieldGet(this, _body2) == null ? null : new Uint8Array(_classPrivateFieldGet(this, _body2));
    }
    /**
     *  The response body as a UTF-8 encoded string, or the empty
     *  string (i.e. ``""``) if there was no body.
     *
     *  An error is thrown if the body is invalid UTF-8 data.
     */
  }, {
    key: "bodyText",
    get: function get() {
      try {
        return _classPrivateFieldGet(this, _body2) == null ? "" : toUtf8String(_classPrivateFieldGet(this, _body2));
      } catch (error) {
        assert$1(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
          operation: "bodyText",
          info: {
            response: this
          }
        });
      }
    }
    /**
     *  The response body, decoded as JSON.
     *
     *  An error is thrown if the body is invalid JSON-encoded data
     *  or if there was no body.
     */
  }, {
    key: "bodyJson",
    get: function get() {
      try {
        return JSON.parse(this.bodyText);
      } catch (error) {
        assert$1(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
          operation: "bodyJson",
          info: {
            response: this
          }
        });
      }
    }
  }, {
    key: _Symbol$iterator2,
    value: function value() {
      var headers = this.headers;
      var keys = Object.keys(headers);
      var index = 0;
      return {
        next: function next() {
          if (index < keys.length) {
            var key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
  }, {
    key: "makeServerError",
    value: function makeServerError(message, error) {
      var statusMessage;
      if (!message) {
        message = "".concat(this.statusCode, " ").concat(this.statusMessage);
        statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(message, ")");
      } else {
        statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(this.statusCode, " ").concat(this.statusMessage, "; ").concat(message, ")");
      }
      var response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet(this, _request2) || undefined);
      _classPrivateFieldSet(response, _error2, {
        message: message,
        error: error
      });
      return response;
    }
    /**
     *  If called within a [request.processFunc](FetchRequest-processFunc)
     *  call, causes the request to retry as if throttled for %%stall%%
     *  milliseconds.
     */
  }, {
    key: "throwThrottleError",
    value: function throwThrottleError(message, stall) {
      if (stall == null) {
        stall = -1;
      } else {
        assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
      }
      var error = new Error(message || "throttling requests");
      defineProperties(error, {
        stall: stall,
        throttle: true
      });
      throw error;
    }
    /**
     *  Get the header value for %%key%%, ignoring case.
     */
  }, {
    key: "getHeader",
    value: function getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    /**
     *  Returns true of the response has a body.
     */
  }, {
    key: "hasBody",
    value: function hasBody() {
      return _classPrivateFieldGet(this, _body2) != null;
    }
    /**
     *  The request made for this response.
     */
  }, {
    key: "request",
    get: function get() {
      return _classPrivateFieldGet(this, _request2);
    }
    /**
     *  Returns true if this response was a success statusCode.
     */
  }, {
    key: "ok",
    value: function ok() {
      return _classPrivateFieldGet(this, _error2).message === "" && this.statusCode >= 200 && this.statusCode < 300;
    }
    /**
     *  Throws a ``SERVER_ERROR`` if this response is not ok.
     */
  }, {
    key: "assertOk",
    value: function assertOk() {
      if (this.ok()) {
        return;
      }
      var _classPrivateFieldGet2 = _classPrivateFieldGet(this, _error2),
        message = _classPrivateFieldGet2.message,
        error = _classPrivateFieldGet2.error;
      if (message === "") {
        message = "server response ".concat(this.statusCode, " ").concat(this.statusMessage);
      }
      assert$1(false, message, "SERVER_ERROR", {
        request: this.request || "unknown request",
        response: this,
        error: error
      });
    }
  }]);
  return FetchResponse;
}();
exports.FetchResponse = FetchResponse;
function getTime$2() {
  return new Date().getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay);
  });
}

/**
 *  About fixed-point math...
 *
 *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]
 */
var BN_N1 = BigInt(-1);
var BN_0$8 = BigInt(0);
var BN_1$4 = BigInt(1);
var BN_5 = BigInt(5);
var _guard$5 = {};
// Constant to pull zeros from for multipliers
var Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
// Returns a string "1" followed by decimal "0"s
function getTens(decimals) {
  var result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  var width = BigInt(format.width);
  if (format.signed) {
    var limit = BN_1$4 << width - BN_1$4;
    assert$1(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    var _limit = BN_1$4 << width;
    assert$1(safeOp == null || val >= 0 && val < _limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % _limit + _limit) % _limit & _limit - BN_1$4;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = "fixed128x".concat(value);
  }
  var signed = true;
  var width = 128;
  var decimals = 18;
  if (typeof value === "string") {
    // Parse the format string
    if (value === "fixed") {
      // defaults...
    } else if (value === "ufixed") {
      signed = false;
    } else {
      var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    // Extract the values from the object
    var v = value;
    var check = function check(key, type, defaultValue) {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(_typeof(v[key]) === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed = check("signed", "boolean", signed);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  var name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return {
    signed: signed,
    width: width,
    decimals: decimals,
    name: name
  };
}
function toString(val, decimals) {
  var negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  var str = val.toString();
  // No decimal point for whole values
  if (decimals === 0) {
    return negative + str;
  }
  // Pad out to the whole component (including a whole digit)
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  // Insert the decimal point
  var index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  // Trim the whole component (leaving at least one 0)
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  // Trim the decimal component (leaving at least one 0)
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
/**
 *  A FixedNumber represents a value over its [[FixedFormat]]
 *  arithmetic field.
 *
 *  A FixedNumber can be used to perform math, losslessly, on
 *  values which have decmial places.
 *
 *  A FixedNumber has a fixed bit-width to store values in, and stores all
 *  values internally by multiplying the value by 10 raised to the power of
 *  %%decimals%%.
 *
 *  If operations are performed that cause a value to grow too high (close to
 *  positive infinity) or too low (close to negative infinity), the value
 *  is said to //overflow//.
 *
 *  For example, an 8-bit signed value, with 0 decimals may only be within
 *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
 *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
 *
 *  Many operation have a normal and //unsafe// variant. The normal variant
 *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
 *  variant will silently allow overflow, corrupting its value value.
 *
 *  If operations are performed that cause a value to become too small
 *  (close to zero), the value loses precison and is said to //underflow//.
 *
 *  For example, an value with 1 decimal place may store a number as small
 *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
 *  into 1 decimal place, so underflow occurs which means precision is lost
 *  and the value becomes ``0``.
 *
 *  Some operations have a normal and //signalling// variant. The normal
 *  variant will silently ignore underflow, while the //signalling// variant
 *  will thow a [[NumericFaultError]] on underflow.
 */
var _format2 = /*#__PURE__*/new WeakMap();
var _val = /*#__PURE__*/new WeakMap();
var _tens = /*#__PURE__*/new WeakMap();
var _checkFormat = /*#__PURE__*/new WeakSet();
var _checkValue = /*#__PURE__*/new WeakSet();
var _add = /*#__PURE__*/new WeakSet();
var _sub = /*#__PURE__*/new WeakSet();
var _mul = /*#__PURE__*/new WeakSet();
var _div = /*#__PURE__*/new WeakSet();
var FixedNumber = /*#__PURE__*/function () {
  /**
   *  The specific fixed-point arithmetic field for this value.
   */

  // The actual value (accounting for decimals)

  // A base-10 value to multiple values by to maintain the magnitude

  /**
   *  This is a property so console.log shows a human-meaningful value.
   *
   *  @private
   */

  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  function FixedNumber(guard, value, format) {
    _classCallCheck(this, FixedNumber);
    _classPrivateMethodInitSpec(this, _div);
    _classPrivateMethodInitSpec(this, _mul);
    _classPrivateMethodInitSpec(this, _sub);
    _classPrivateMethodInitSpec(this, _add);
    _classPrivateMethodInitSpec(this, _checkValue);
    _classPrivateMethodInitSpec(this, _checkFormat);
    _defineProperty(this, "format", void 0);
    _classPrivateFieldInitSpec(this, _format2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _val, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _tens, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "_value", void 0);
    assertPrivate(guard, _guard$5, "FixedNumber");
    _classPrivateFieldSet(this, _val, value);
    _classPrivateFieldSet(this, _format2, format);
    var _value = toString(value, format.decimals);
    defineProperties(this, {
      format: format.name,
      _value: _value
    });
    _classPrivateFieldSet(this, _tens, getTens(format.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  _createClass(FixedNumber, [{
    key: "signed",
    get: function get() {
      return _classPrivateFieldGet(this, _format2).signed;
    }
    /**
     *  The number of bits available to store the value.
     */
  }, {
    key: "width",
    get: function get() {
      return _classPrivateFieldGet(this, _format2).width;
    }
    /**
     *  The number of decimal places in the fixed-point arithment field.
     */
  }, {
    key: "decimals",
    get: function get() {
      return _classPrivateFieldGet(this, _format2).decimals;
    }
    /**
     *  The value as an integer, based on the smallest unit the
     *  [[decimals]] allow.
     */
  }, {
    key: "value",
    get: function get() {
      return _classPrivateFieldGet(this, _val);
    }
  }, {
    key: "addUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%, ignoring overflow.
     */
    function addUnsafe(other) {
      return _classPrivateMethodGet(this, _add, _add2).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "add",
    value: function add(other) {
      return _classPrivateMethodGet(this, _add, _add2).call(this, other, "add");
    }
  }, {
    key: "subUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%, ignoring overflow.
     */
    function subUnsafe(other) {
      return _classPrivateMethodGet(this, _sub, _sub2).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "sub",
    value: function sub(other) {
      return _classPrivateMethodGet(this, _sub, _sub2).call(this, other, "sub");
    }
  }, {
    key: "mulUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%, ignoring overflow and underflow (precision loss).
     */
    function mulUnsafe(other) {
      return _classPrivateMethodGet(this, _mul, _mul2).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "mul",
    value: function mul(other) {
      return _classPrivateMethodGet(this, _mul, _mul2).call(this, other, "mul");
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs or if underflow (precision loss) occurs.
     */
  }, {
    key: "mulSignal",
    value: function mulSignal(other) {
      _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, other);
      var value = _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(other, _val);
      assert$1(value % _classPrivateFieldGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
        operation: "mulSignal",
        fault: "underflow",
        value: this
      });
      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, value / _classPrivateFieldGet(this, _tens), "mulSignal");
    }
  }, {
    key: "divUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    function divUnsafe(other) {
      return _classPrivateMethodGet(this, _div, _div2).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
  }, {
    key: "div",
    value: function div(other) {
      return _classPrivateMethodGet(this, _div, _div2).call(this, other, "div");
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
     *  (precision loss) occurs.
     */
  }, {
    key: "divSignal",
    value: function divSignal(other) {
      assert$1(_classPrivateFieldGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
      });
      _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, other);
      var value = _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(this, _tens);
      assert$1(value % _classPrivateFieldGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
        operation: "divSignal",
        fault: "underflow",
        value: this
      });
      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, value / _classPrivateFieldGet(other, _val), "divSignal");
    }
    /**
     *  Returns a comparison result between %%this%% and %%other%%.
     *
     *  This is suitable for use in sorting, where ``-1`` implies %%this%%
     *  is smaller, ``1`` implies %%other%% is larger and ``0`` implies
     *  both are equal.
     */
  }, {
    key: "cmp",
    value: function cmp(other) {
      var a = this.value,
        b = other.value;
      // Coerce a and b to the same magnitude
      var delta = this.decimals - other.decimals;
      if (delta > 0) {
        b *= getTens(delta);
      } else if (delta < 0) {
        a *= getTens(-delta);
      }
      // Comnpare
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return -1;
      }
      return 0;
    }
    /**
     *  Returns true if %%other%% is equal to %%this%%.
     */
  }, {
    key: "eq",
    value: function eq(other) {
      return this.cmp(other) === 0;
    }
    /**
     *  Returns true if %%other%% is less than to %%this%%.
     */
  }, {
    key: "lt",
    value: function lt(other) {
      return this.cmp(other) < 0;
    }
    /**
     *  Returns true if %%other%% is less than or equal to %%this%%.
     */
  }, {
    key: "lte",
    value: function lte(other) {
      return this.cmp(other) <= 0;
    }
    /**
     *  Returns true if %%other%% is greater than to %%this%%.
     */
  }, {
    key: "gt",
    value: function gt(other) {
      return this.cmp(other) > 0;
    }
    /**
     *  Returns true if %%other%% is greater than or equal to %%this%%.
     */
  }, {
    key: "gte",
    value: function gte(other) {
      return this.cmp(other) >= 0;
    }
    /**
     *  Returns a new [[FixedNumber]] which is the largest **integer**
     *  that is less than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
  }, {
    key: "floor",
    value: function floor() {
      var val = _classPrivateFieldGet(this, _val);
      if (_classPrivateFieldGet(this, _val) < BN_0$8) {
        val -= _classPrivateFieldGet(this, _tens) - BN_1$4;
      }
      val = _classPrivateFieldGet(this, _val) / _classPrivateFieldGet(this, _tens) * _classPrivateFieldGet(this, _tens);
      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, val, "floor");
    }
    /**
     *  Returns a new [[FixedNumber]] which is the smallest **integer**
     *  that is greater than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
  }, {
    key: "ceiling",
    value: function ceiling() {
      var val = _classPrivateFieldGet(this, _val);
      if (_classPrivateFieldGet(this, _val) > BN_0$8) {
        val += _classPrivateFieldGet(this, _tens) - BN_1$4;
      }
      val = _classPrivateFieldGet(this, _val) / _classPrivateFieldGet(this, _tens) * _classPrivateFieldGet(this, _tens);
      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, val, "ceiling");
    }
    /**
     *  Returns a new [[FixedNumber]] with the decimal component
     *  rounded up on ties at %%decimals%% places.
     */
  }, {
    key: "round",
    value: function round(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      // Not enough precision to not already be rounded
      if (decimals >= this.decimals) {
        return this;
      }
      var delta = this.decimals - decimals;
      var bump = BN_5 * getTens(delta - 1);
      var value = this.value + bump;
      var tens = getTens(delta);
      value = value / tens * tens;
      checkValue(value, _classPrivateFieldGet(this, _format2), "round");
      return new FixedNumber(_guard$5, value, _classPrivateFieldGet(this, _format2));
    }
    /**
     *  Returns true if %%this%% is equal to ``0``.
     */
  }, {
    key: "isZero",
    value: function isZero() {
      return _classPrivateFieldGet(this, _val) === BN_0$8;
    }
    /**
     *  Returns true if %%this%% is less than ``0``.
     */
  }, {
    key: "isNegative",
    value: function isNegative() {
      return _classPrivateFieldGet(this, _val) < BN_0$8;
    }
    /**
     *  Returns the string representation of %%this%%.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._value;
    }
    /**
     *  Returns a float approximation.
     *
     *  Due to IEEE 754 precission (or lack thereof), this function
     *  can only return an approximation and most values will contain
     *  rounding errors.
     */
  }, {
    key: "toUnsafeFloat",
    value: function toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    /**
     *  Return a new [[FixedNumber]] with the same value but has had
     *  its field set to %%format%%.
     *
     *  This will throw if the value cannot fit into %%format%%.
     */
  }, {
    key: "toFormat",
    value: function toFormat(format) {
      return FixedNumber.fromString(this.toString(), format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% divided by
     *  %%decimal%% places with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
     *  or underflow (precision loss).
     */
  }], [{
    key: "fromValue",
    value: function fromValue(_value, decimals, _format) {
      if (decimals == null) {
        decimals = 0;
      }
      var format = getFormat(_format);
      var value = getBigInt(_value, "value");
      var delta = decimals - format.decimals;
      if (delta > 0) {
        var tens = getTens(delta);
        assert$1(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
          operation: "fromValue",
          fault: "underflow",
          value: _value
        });
        value /= tens;
      } else if (delta < 0) {
        value *= getTens(-delta);
      }
      checkValue(value, format, "fromValue");
      return new FixedNumber(_guard$5, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%%, either due to overflow or underflow (precision loss).
     */
  }, {
    key: "fromString",
    value: function fromString(_value, _format) {
      var match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
      assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
      var format = getFormat(_format);
      var whole = match[2] || "0",
        decimal = match[3] || "";
      // Pad out the decimals
      while (decimal.length < format.decimals) {
        decimal += Zeros$1;
      }
      // Check precision is safe
      assert$1(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
        operation: "fromString",
        fault: "underflow",
        value: _value
      });
      // Remove extra padding
      decimal = decimal.substring(0, format.decimals);
      var value = BigInt(match[1] + whole + decimal);
      checkValue(value, format, "fromString");
      return new FixedNumber(_guard$5, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] with the big-endian representation
     *  %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%% due to overflow.
     */
  }, {
    key: "fromBytes",
    value: function fromBytes(_value, _format) {
      var value = toBigInt(getBytes(_value, "value"));
      var format = getFormat(_format);
      if (format.signed) {
        value = fromTwos(value, format.width);
      }
      checkValue(value, format, "fromBytes");
      return new FixedNumber(_guard$5, value, format);
    }
  }]);
  return FixedNumber;
}(); //const f1 = FixedNumber.fromString("12.56", "fixed16x2");
//const f2 = FixedNumber.fromString("0.3", "fixed16x2");
//console.log(f1.divSignal(f2));
//const BUMP = FixedNumber.from("0.5");
//See: https://github.com/ethereum/wiki/wiki/RLP
exports.FixedNumber = FixedNumber;
function _checkFormat2(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
}
function _checkValue2(val, safeOp) {
  /*
          const width = BigInt(this.width);
          if (this.signed) {
              const limit = (BN_1 << (width - BN_1));
              assert(safeOp == null || (val >= -limit  && val < limit), "overflow", "NUMERIC_FAULT", {
                  operation: <string>safeOp, fault: "overflow", value: val
              });
  
              if (val > BN_0) {
                  val = fromTwos(mask(val, width), width);
              } else {
                  val = -fromTwos(mask(-val, width), width);
              }
  
          } else {
              const masked = mask(val, width);
              assert(safeOp == null || (val >= 0 && val === masked), "overflow", "NUMERIC_FAULT", {
                  operation: <string>safeOp, fault: "overflow", value: val
              });
              val = masked;
          }
  */
  val = checkValue(val, _classPrivateFieldGet(this, _format2), safeOp);
  return new FixedNumber(_guard$5, val, _classPrivateFieldGet(this, _format2));
}
function _add2(o, safeOp) {
  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);
  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) + _classPrivateFieldGet(o, _val), safeOp);
}
function _sub2(o, safeOp) {
  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);
  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) - _classPrivateFieldGet(o, _val), safeOp);
}
function _mul2(o, safeOp) {
  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);
  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(o, _val) / _classPrivateFieldGet(this, _tens), safeOp);
}
function _div2(o, safeOp) {
  assert$1(_classPrivateFieldGet(o, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);
  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(this, _tens) / _classPrivateFieldGet(o, _val), safeOp);
}
function hexlifyByte(value) {
  var result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  var result = 0;
  for (var i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  var result = [];
  while (childOffset < offset + 1 + length) {
    var decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert$1(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: length,
      offset: offset
    });
  }
  return {
    consumed: 1 + length,
    result: result
  };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
  assert$1(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  var checkOffset = function checkOffset(offset) {
    assert$1(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset
    });
  };
  // Array with extra length prefix
  if (data[offset] >= 0xf8) {
    var lengthLength = data[offset] - 0xf7;
    checkOffset(offset + 1 + lengthLength);
    var length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 0xc0) {
    var _length = data[offset] - 0xc0;
    checkOffset(offset + 1 + _length);
    return _decodeChildren(data, offset, offset + 1, _length);
  } else if (data[offset] >= 0xb8) {
    var _lengthLength = data[offset] - 0xb7;
    checkOffset(offset + 1 + _lengthLength);
    var _length2 = unarrayifyInteger(data, offset + 1, _lengthLength);
    checkOffset(offset + 1 + _lengthLength + _length2);
    var result = hexlify(data.slice(offset + 1 + _lengthLength, offset + 1 + _lengthLength + _length2));
    return {
      consumed: 1 + _lengthLength + _length2,
      result: result
    };
  } else if (data[offset] >= 0x80) {
    var _length3 = data[offset] - 0x80;
    checkOffset(offset + 1 + _length3);
    var _result = hexlify(data.slice(offset + 1, offset + 1 + _length3));
    return {
      consumed: 1 + _length3,
      result: _result
    };
  }
  return {
    consumed: 1,
    result: hexlifyByte(data[offset])
  };
}
/**
 *  Decodes %%data%% into the structured data it represents.
 */
function decodeRlp(_data) {
  var data = getBytes(_data, "data");
  var decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}

//See: https://github.com/ethereum/wiki/wiki/RLP
function arrayifyInteger(value) {
  var result = [];
  while (value) {
    result.unshift(value & 0xff);
    value >>= 8;
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    var payload = [];
    object.forEach(function (child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(0xc0 + payload.length);
      return payload;
    }
    var _length4 = arrayifyInteger(payload.length);
    _length4.unshift(0xf7 + _length4.length);
    return _length4.concat(payload);
  }
  var data = Array.prototype.slice.call(getBytes(object, "object"));
  if (data.length === 1 && data[0] <= 0x7f) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(0x80 + data.length);
    return data;
  }
  var length = arrayifyInteger(data.length);
  length.unshift(0xb7 + length.length);
  return length.concat(data);
}
var nibbles = "0123456789abcdef";
/**
 *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
 */
function encodeRlp(object) {
  var result = "0x";
  var _iterator3 = _createForOfIteratorHelper(_encode(object)),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var v = _step3.value;
      result += nibbles[v >> 4];
      result += nibbles[v & 0xf];
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return result;
}

/**
 *  Most interactions with Ethereum requires integer values, which use
 *  the smallest magnitude unit.
 *
 *  For example, imagine dealing with dollars and cents. Since dollars
 *  are divisible, non-integer values are possible, such as ``$10.77``.
 *  By using the smallest indivisible unit (i.e. cents), the value can
 *  be kept as the integer ``1077``.
 *
 *  When receiving decimal input from the user (as a decimal string),
 *  the value should be converted to an integer and when showing a user
 *  a value, the integer value should be converted to a decimal string.
 *
 *  This creates a clear distinction, between values to be used by code
 *  (integers) and values used for display logic to users (decimals).
 *
 *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,
 *  where each individual unit is called a //wei//.
 *
 *  @_subsection api/utils:Unit Conversion  [about-units]
 */
var names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
/**
 *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
 *  places. The %%unit%% may be the number of decimal places or the name of
 *  a unit (e.g. ``"gwei"`` for 9 decimal places).
 *
 */
function formatUnits(value, unit) {
  var decimals = 18;
  if (typeof unit === "string") {
    var index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, {
    decimals: decimals
  }).toString();
}
/**
 *  Converts the //decimal string// %%value%% to a BigInt, assuming
 *  %%unit%% decimal places. The %%unit%% may the number of decimal places
 *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
 */
function parseUnits(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  var decimals = 18;
  if (typeof unit === "string") {
    var index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, {
    decimals: decimals
  }).value;
}
/**
 *  Converts %%value%% into a //decimal string// using 18 decimal places.
 */
function formatEther(wei) {
  return formatUnits(wei, 18);
}
/**
 *  Converts the //decimal string// %%ether%% to a BigInt, using 18
 *  decimal places.
 */
function parseEther(ether) {
  return parseUnits(ether, 18);
}

/**
 *  Explain UUID and link to RFC here.
 *
 *  @_subsection: api/utils:UUID  [about-uuid]
 */
/**
 *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.
 *
 *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
 */
function uuidV4(randomBytes) {
  var bytes = getBytes(randomBytes, "randomBytes");
  // Section: 4.1.3:
  // - time_hi_and_version[12:16] = 0b0100
  bytes[6] = bytes[6] & 0x0f | 0x40;
  // Section 4.4
  // - clock_seq_hi_and_reserved[6] = 0b0
  // - clock_seq_hi_and_reserved[7] = 0b1
  bytes[8] = bytes[8] & 0x3f | 0x80;
  var value = hexlify(bytes);
  return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
}

/**
 *  There are many simple utilities required to interact with
 *  Ethereum and to simplify the library, without increasing
 *  the library dependencies for simple functions.
 *
 *  @_section api/utils:Utilities  [about-utils]
 */

/**
 * @_ignore:
 */
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
var passProperties$1 = ["then"];
var _guard$4 = {};
function throwError(name, error) {
  var wrapped = new Error("deferred error during ABI decoding triggered accessing ".concat(name));
  wrapped.error = error;
  throw wrapped;
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
var _names = /*#__PURE__*/new WeakMap();
var Result = /*#__PURE__*/function (_Array) {
  _inherits(Result, _Array);
  var _super = _createSuper(Result);
  /**
   *  @private
   */
  function Result() {
    var _this3;
    _classCallCheck(this, Result);
    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }
    // To properly sub-class Array so the other built-in
    // functions work, the constructor has to behave fairly
    // well. So, in the event we are created via fromItems()
    // we build the read-only Result object we want, but on
    // any other input, we use the default constructor
    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
    var guard = args[0];
    var items = args[1];
    var names = (args[2] || []).slice();
    var wrap = true;
    if (guard !== _guard$4) {
      items = args;
      names = [];
      wrap = false;
    }
    // Can't just pass in ...items since an array of length 1
    // is a special case in the super.
    _this3 = _super.call(this, items.length);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this3), _names, {
      writable: true,
      value: void 0
    });
    items.forEach(function (item, index) {
      _this3[index] = item;
    });
    // Find all unique keys
    var nameCounts = names.reduce(function (accum, name) {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, new Map());
    // Remove any key thats not unique
    _classPrivateFieldSet(_assertThisInitialized(_this3), _names, Object.freeze(items.map(function (item, index) {
      var name = names[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    if (!wrap) {
      return _possibleConstructorReturn(_this3);
    }
    // A wrapped Result is immutable
    Object.freeze(_assertThisInitialized(_this3));
    // Proxy indices and names so we can trap deferred errors
    return _possibleConstructorReturn(_this3, new Proxy(_assertThisInitialized(_this3), {
      get: function get(target, prop, receiver) {
        if (typeof prop === "string") {
          // Index accessor
          if (prop.match(/^[0-9]+$/)) {
            var index = getNumber(prop, "%index");
            if (index < 0 || index >= _this3.length) {
              throw new RangeError("out of result range");
            }
            var item = target[index];
            if (item instanceof Error) {
              throwError("index ".concat(index), item);
            }
            return item;
          }
          // Pass important checks (like `then` for Promise) through
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          var value = target[prop];
          if (value instanceof Function) {
            // Make sure functions work with private variables
            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
                args[_key3] = arguments[_key3];
              }
              return value.apply(this === receiver ? target : this, args);
            };
          } else if (!(prop in target)) {
            // Possible name accessor
            return target.getValue.apply(_assertThisInitialized(_this3) === receiver ? target : _assertThisInitialized(_this3), [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    }));
  }
  /**
   *  Returns the Result as a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  _createClass(Result, [{
    key: "toArray",
    value: function toArray() {
      var result = [];
      this.forEach(function (item, index) {
        if (item instanceof Error) {
          throwError("index ".concat(index), item);
        }
        result.push(item);
      });
      return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
  }, {
    key: "toObject",
    value: function toObject() {
      var _this4 = this;
      return _classPrivateFieldGet(this, _names).reduce(function (accum, name, index) {
        assert$1(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
          operation: "toObject()"
        });
        // Add values for names that don't conflict
        if (!(name in accum)) {
          accum[name] = _this4.getValue(name);
        }
        return accum;
      }, {});
    }
    /**
     *  @_ignore
     */
  }, {
    key: "slice",
    value: function slice(start, end) {
      if (start == null) {
        start = 0;
      }
      if (start < 0) {
        start += this.length;
        if (start < 0) {
          start = 0;
        }
      }
      if (end == null) {
        end = this.length;
      }
      if (end < 0) {
        end += this.length;
        if (end < 0) {
          end = 0;
        }
      }
      if (end > this.length) {
        end = this.length;
      }
      var result = [],
        names = [];
      for (var i = start; i < end; i++) {
        result.push(this[i]);
        names.push(_classPrivateFieldGet(this, _names)[i]);
      }
      return new Result(_guard$4, result, names);
    }
    /**
     *  @_ignore
     */
  }, {
    key: "filter",
    value: function filter(callback, thisArg) {
      var result = [],
        names = [];
      for (var i = 0; i < this.length; i++) {
        var item = this[i];
        if (item instanceof Error) {
          throwError("index ".concat(i), item);
        }
        if (callback.call(thisArg, item, i, this)) {
          result.push(item);
          names.push(_classPrivateFieldGet(this, _names)[i]);
        }
      }
      return new Result(_guard$4, result, names);
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
  }, {
    key: "getValue",
    value: function getValue(name) {
      var index = _classPrivateFieldGet(this, _names).indexOf(name);
      if (index === -1) {
        return undefined;
      }
      var value = this[index];
      if (value instanceof Error) {
        throwError("property ".concat(JSON.stringify(name)), value.error);
      }
      return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
  }], [{
    key: "fromItems",
    value: function fromItems(items, keys) {
      return new Result(_guard$4, items, keys);
    }
  }]);
  return Result;
}( /*#__PURE__*/_wrapNativeSuper(Array));
/**
 *  Returns all errors found in a [[Result]].
 *
 *  Since certain errors encountered when creating a [[Result]] do
 *  not impact the ability to continue parsing data, they are
 *  deferred until they are actually accessed. Hence a faulty string
 *  in an Event that is never used does not impact the program flow.
 *
 *  However, sometimes it may be useful to access, identify or
 *  validate correctness of a [[Result]].
 *
 *  @_docloc api/abi
 */
exports.Result = Result;
function checkResultErrors(result) {
  // Find the first error (if any)
  var errors = [];
  var checkErrors = function checkErrors(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (var key in object) {
      var childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({
          path: childPath,
          error: error
        });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue$1(value) {
  var bytes = toBeArray(value);
  assert$1(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", {
    buffer: bytes,
    length: WordSize,
    offset: bytes.length
  });
  if (bytes.length !== WordSize) {
    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
  }
  return bytes;
}
/**
 *  @_ignore
 */
var Coder = /*#__PURE__*/function () {
  // The coder name:
  //   - address, uint256, tuple, array, etc.

  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.

  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz

  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)

  function Coder(name, type, localName, dynamic) {
    _classCallCheck(this, Coder);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "localName", void 0);
    _defineProperty(this, "dynamic", void 0);
    defineProperties(this, {
      name: name,
      type: type,
      localName: localName,
      dynamic: dynamic
    }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _createClass(Coder, [{
    key: "_throwError",
    value: function _throwError(message, value) {
      assertArgument(false, message, this.localName, value);
    }
  }]);
  return Coder;
}();
/**
 *  @_ignore
 */
var _data2 = /*#__PURE__*/new WeakMap();
var _dataLength = /*#__PURE__*/new WeakMap();
var _writeData = /*#__PURE__*/new WeakSet();
var Writer = /*#__PURE__*/function () {
  // An array of WordSize lengthed objects to concatenation

  function Writer() {
    _classCallCheck(this, Writer);
    _classPrivateMethodInitSpec(this, _writeData);
    _classPrivateFieldInitSpec(this, _data2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _dataLength, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _data2, []);
    _classPrivateFieldSet(this, _dataLength, 0);
  }
  _createClass(Writer, [{
    key: "data",
    get: function get() {
      return concat(_classPrivateFieldGet(this, _data2));
    }
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(this, _dataLength);
    }
  }, {
    key: "appendWriter",
    value: function appendWriter(writer) {
      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, getBytesCopy(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
  }, {
    key: "writeBytes",
    value: function writeBytes(value) {
      var bytes = getBytesCopy(value);
      var paddingOffset = bytes.length % WordSize;
      if (paddingOffset) {
        bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
      }
      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, bytes);
    }
    // Numeric item; pad on the left *to* WordSize
  }, {
    key: "writeValue",
    value: function writeValue(value) {
      return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, getValue$1(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
  }, {
    key: "writeUpdatableValue",
    value: function writeUpdatableValue() {
      var _this5 = this;
      var offset = _classPrivateFieldGet(this, _data2).length;
      _classPrivateFieldGet(this, _data2).push(Padding);
      _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + WordSize);
      return function (value) {
        _classPrivateFieldGet(_this5, _data2)[offset] = getValue$1(value);
      };
    }
  }]);
  return Writer;
}();
/**
 *  @_ignore
 */
function _writeData2(data) {
  _classPrivateFieldGet(this, _data2).push(data);
  _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + data.length);
  return data.length;
}
var _data3 = /*#__PURE__*/new WeakMap();
var _offset = /*#__PURE__*/new WeakMap();
var _peekBytes = /*#__PURE__*/new WeakSet();
var Reader = /*#__PURE__*/function () {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.

  function Reader(data, allowLoose) {
    _classCallCheck(this, Reader);
    _classPrivateMethodInitSpec(this, _peekBytes);
    _defineProperty(this, "allowLoose", void 0);
    _classPrivateFieldInitSpec(this, _data3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _offset, {
      writable: true,
      value: void 0
    });
    defineProperties(this, {
      allowLoose: !!allowLoose
    });
    _classPrivateFieldSet(this, _data3, getBytesCopy(data));
    _classPrivateFieldSet(this, _offset, 0);
  }
  _createClass(Reader, [{
    key: "data",
    get: function get() {
      return hexlify(_classPrivateFieldGet(this, _data3));
    }
  }, {
    key: "dataLength",
    get: function get() {
      return _classPrivateFieldGet(this, _data3).length;
    }
  }, {
    key: "consumed",
    get: function get() {
      return _classPrivateFieldGet(this, _offset);
    }
  }, {
    key: "bytes",
    get: function get() {
      return new Uint8Array(_classPrivateFieldGet(this, _data3));
    }
  }, {
    key: "subReader",
    value:
    // Create a sub-reader with the same underlying data, but offset
    function subReader(offset) {
      return new Reader(_classPrivateFieldGet(this, _data3).slice(_classPrivateFieldGet(this, _offset) + offset), this.allowLoose);
    }
    // Read bytes
  }, {
    key: "readBytes",
    value: function readBytes(length, loose) {
      var bytes = _classPrivateMethodGet(this, _peekBytes, _peekBytes2).call(this, 0, length, !!loose);
      _classPrivateFieldSet(this, _offset, _classPrivateFieldGet(this, _offset) + bytes.length);
      // @TODO: Make sure the length..end bytes are all 0?
      return bytes.slice(0, length);
    }
    // Read a numeric values
  }, {
    key: "readValue",
    value: function readValue() {
      return toBigInt(this.readBytes(WordSize));
    }
  }, {
    key: "readIndex",
    value: function readIndex() {
      return toNumber(this.readBytes(WordSize));
    }
  }]);
  return Reader;
}();
function _peekBytes2(offset, length, loose) {
  var alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (_classPrivateFieldGet(this, _offset) + alignedLength > _classPrivateFieldGet(this, _data3).length) {
    if (this.allowLoose && loose && _classPrivateFieldGet(this, _offset) + length <= _classPrivateFieldGet(this, _data3).length) {
      alignedLength = length;
    } else {
      assert$1(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(_classPrivateFieldGet(this, _data3)),
        length: _classPrivateFieldGet(this, _data3).length,
        offset: _classPrivateFieldGet(this, _offset) + alignedLength
      });
    }
  }
  return _classPrivateFieldGet(this, _data3).slice(_classPrivateFieldGet(this, _offset), _classPrivateFieldGet(this, _offset) + alignedLength);
}
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error("Wrong positive integer: ".concat(n));
}
function bool(b) {
  if (typeof b !== 'boolean') throw new Error("Expected boolean, not ".concat(b));
}
function bytes(b) {
  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
  for (var _len3 = arguments.length, lengths = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
    lengths[_key4 - 1] = arguments[_key4];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError("Expected Uint8Array of length ".concat(lengths, ", not of length=").concat(b.length));
}
function hash(hash) {
  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  number(hash.outputLen);
  number(hash.blockLen);
}
function exists(instance) {
  var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
  bytes(out);
  var min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least ".concat(min));
  }
}
var assert = {
  number: number,
  bool: bool,
  bytes: bytes,
  hash: hash,
  exists: exists,
  output: output
};
var crypto$2 = {
  node: undefined,
  web: (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && 'crypto' in self ? self.crypto : undefined
};

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Cast array to different type
var u8 = function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
var u32 = function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
// Cast array to view
var createView = function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
// The rotate right (circular right shift) operation for uint32
var rotr = function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
};
var isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!isLE) throw new Error('Non little-endian hardware is not supported');
var hexes$1 = Array.from({
  length: 256
}, function (v, i) {
  return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex$1(uint8a) {
  // pre-caching improves the speed 6x
  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');
  var hex = '';
  for (var i = 0; i < uint8a.length; i++) {
    hex += hexes$1[uint8a[i]];
  }
  return hex;
}
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes$1(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToBytes: expected string, got ' + _typeof(hex));
  }
  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
  var array = new Uint8Array(hex.length / 2);
  for (var i = 0; i < array.length; i++) {
    var j = i * 2;
    var hexByte = hex.slice(j, j + 2);
    var _byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
    array[i] = _byte;
  }
  return array;
}
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
var nextTick = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function nextTick() {
    return _ref.apply(this, arguments);
  };
}();
// Returns control to thread each 'tick' ms to avoid blocking
function asyncLoop(_x8, _x9, _x10) {
  return _asyncLoop.apply(this, arguments);
}
function _asyncLoop() {
  _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee198(iters, tick, cb) {
    var ts, _i89, diff;
    return _regeneratorRuntime().wrap(function _callee198$(_context198) {
      while (1) switch (_context198.prev = _context198.next) {
        case 0:
          ts = Date.now();
          _i89 = 0;
        case 2:
          if (!(_i89 < iters)) {
            _context198.next = 13;
            break;
          }
          cb(_i89);
          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
          diff = Date.now() - ts;
          if (!(diff >= 0 && diff < tick)) {
            _context198.next = 7;
            break;
          }
          return _context198.abrupt("continue", 10);
        case 7:
          _context198.next = 9;
          return nextTick();
        case 9:
          ts += diff;
        case 10:
          _i89++;
          _context198.next = 2;
          break;
        case 13:
        case "end":
          return _context198.stop();
      }
    }, _callee198);
  }));
  return _asyncLoop.apply(this, arguments);
}
function utf8ToBytes(str) {
  if (typeof str !== 'string') {
    throw new TypeError("utf8ToBytes expected string, got ".concat(_typeof(str)));
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array)) throw new TypeError("Expected input type is Uint8Array (got ".concat(_typeof(data), ")"));
  return data;
}
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes$1() {
  for (var _len4 = arguments.length, arrays = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
    arrays[_key5] = arguments[_key5];
  }
  if (!arrays.every(function (a) {
    return a instanceof Uint8Array;
  })) throw new Error('Uint8Array list expected');
  if (arrays.length === 1) return arrays[0];
  var length = arrays.reduce(function (a, arr) {
    return a + arr.length;
  }, 0);
  var result = new Uint8Array(length);
  for (var i = 0, pad = 0; i < arrays.length; i++) {
    var arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
// For runtime check if class implements interface
var Hash = /*#__PURE__*/function () {
  function Hash() {
    _classCallCheck(this, Hash);
  }
  _createClass(Hash, [{
    key: "clone",
    value:
    // Safe version that clones internal state
    function clone() {
      return this._cloneInto();
    }
  }]);
  return Hash;
}(); // Check if object doens't have custom constructor (like Uint8Array/Array)
var isPlainObject = function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
};
function checkOpts(defaults, opts) {
  if (opts !== undefined && (_typeof(opts) !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');
  var merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashConstructor) {
  var hashC = function hashC(message) {
    return hashConstructor().update(toBytes(message)).digest();
  };
  var tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function () {
    return hashConstructor();
  };
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
/**
 * Secure PRNG
 */
function randomBytes$2() {
  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
  if (crypto$2.web) {
    return crypto$2.web.getRandomValues(new Uint8Array(bytesLength));
  } else if (crypto$2.node) {
    return new Uint8Array(crypto$2.node.randomBytes(bytesLength).buffer);
  } else {
    throw new Error("The environment doesn't have randomBytes function");
  }
}

// HMAC (RFC 2104)
var HMAC = /*#__PURE__*/function (_Hash) {
  _inherits(HMAC, _Hash);
  var _super2 = _createSuper(HMAC);
  function HMAC(hash, _key) {
    var _this6;
    _classCallCheck(this, HMAC);
    _this6 = _super2.call(this);
    _this6.finished = false;
    _this6.destroyed = false;
    assert.hash(hash);
    var key = toBytes(_key);
    _this6.iHash = hash.create();
    if (!(_this6.iHash instanceof Hash)) throw new TypeError('Expected instance of class which extends utils.Hash');
    var blockLen = _this6.blockLen = _this6.iHash.blockLen;
    _this6.outputLen = _this6.iHash.outputLen;
    var pad = new Uint8Array(blockLen);
    // blockLen can be bigger than outputLen
    pad.set(key.length > _this6.iHash.blockLen ? hash.create().update(key).digest() : key);
    for (var i = 0; i < pad.length; i++) pad[i] ^= 0x36;
    _this6.iHash.update(pad);
    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
    _this6.oHash = hash.create();
    // Undo internal XOR && apply outer XOR
    for (var _i = 0; _i < pad.length; _i++) pad[_i] ^= 0x36 ^ 0x5c;
    _this6.oHash.update(pad);
    pad.fill(0);
    return _this6;
  }
  _createClass(HMAC, [{
    key: "update",
    value: function update(buf) {
      assert.exists(this);
      this.iHash.update(buf);
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      assert.exists(this);
      assert.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
  }, {
    key: "digest",
    value: function digest() {
      var out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      // Create new instance without calling constructor since key already in state and we don't know it.
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      var oHash = this.oHash,
        iHash = this.iHash,
        finished = this.finished,
        destroyed = this.destroyed,
        blockLen = this.blockLen,
        outputLen = this.outputLen;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }]);
  return HMAC;
}(Hash);
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
var hmac = function hmac(hash, key, message) {
  return new HMAC(hash, key).update(message).digest();
};
hmac.create = function (hash, key) {
  return new HMAC(hash, key);
};

// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
  assert.hash(hash);
  var opts = checkOpts({
    dkLen: 32,
    asyncTick: 10
  }, _opts);
  var c = opts.c,
    dkLen = opts.dkLen,
    asyncTick = opts.asyncTick;
  assert.number(c);
  assert.number(dkLen);
  assert.number(asyncTick);
  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
  var password = toBytes(_password);
  var salt = toBytes(_salt);
  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
  var DK = new Uint8Array(dkLen);
  // U1 = PRF(Password, Salt + INT_32_BE(i))
  var PRF = hmac.create(hash, password);
  var PRFSalt = PRF._cloneInto().update(salt);
  return {
    c: c,
    dkLen: dkLen,
    asyncTick: asyncTick,
    DK: DK,
    PRF: PRF,
    PRFSalt: PRFSalt
  };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW) prfW.destroy();
  u.fill(0);
  return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2$1(hash, password, salt, opts) {
  var _pbkdf2Init = pbkdf2Init(hash, password, salt, opts),
    c = _pbkdf2Init.c,
    dkLen = _pbkdf2Init.dkLen,
    DK = _pbkdf2Init.DK,
    PRF = _pbkdf2Init.PRF,
    PRFSalt = _pbkdf2Init.PRFSalt;
  var prfW; // Working copy
  var arr = new Uint8Array(4);
  var view = createView(arr);
  var u = new Uint8Array(PRF.outputLen);
  // DK = T1 + T2 + ⋯ + Tdklen/hlen
  for (var ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    // Ti = F(Password, Salt, c, i)
    var Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (var ui = 1; ui < c; ui++) {
      // Uc = PRF(Password, Uc−1)
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function pbkdf2Async(_x11, _x12, _x13, _x14) {
  return _pbkdf2Async.apply(this, arguments);
} // Polyfill for Safari 14
function _pbkdf2Async() {
  _pbkdf2Async = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee199(hash, password, salt, opts) {
    var _pbkdf2Init2, c, dkLen, asyncTick, DK, PRF, PRFSalt, prfW, arr, view, u, _loop6, ti, pos;
    return _regeneratorRuntime().wrap(function _callee199$(_context200) {
      while (1) switch (_context200.prev = _context200.next) {
        case 0:
          _pbkdf2Init2 = pbkdf2Init(hash, password, salt, opts), c = _pbkdf2Init2.c, dkLen = _pbkdf2Init2.dkLen, asyncTick = _pbkdf2Init2.asyncTick, DK = _pbkdf2Init2.DK, PRF = _pbkdf2Init2.PRF, PRFSalt = _pbkdf2Init2.PRFSalt;
          // Working copy
          arr = new Uint8Array(4);
          view = createView(arr);
          u = new Uint8Array(PRF.outputLen); // DK = T1 + T2 + ⋯ + Tdklen/hlen
          _loop6 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop6() {
            var Ti;
            return _regeneratorRuntime().wrap(function _loop6$(_context199) {
              while (1) switch (_context199.prev = _context199.next) {
                case 0:
                  // Ti = F(Password, Salt, c, i)
                  Ti = DK.subarray(pos, pos + PRF.outputLen);
                  view.setInt32(0, ti, false);
                  // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
                  // U1 = PRF(Password, Salt + INT_32_BE(i))
                  (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
                  Ti.set(u.subarray(0, Ti.length));
                  _context199.next = 6;
                  return asyncLoop(c - 1, asyncTick, function (i) {
                    // Uc = PRF(Password, Uc−1)
                    PRF._cloneInto(prfW).update(u).digestInto(u);
                    for (var _i90 = 0; _i90 < Ti.length; _i90++) Ti[_i90] ^= u[_i90];
                  });
                case 6:
                case "end":
                  return _context199.stop();
              }
            }, _loop6);
          });
          ti = 1, pos = 0;
        case 6:
          if (!(pos < dkLen)) {
            _context200.next = 11;
            break;
          }
          return _context200.delegateYield(_loop6(), "t0", 8);
        case 8:
          ti++, pos += PRF.outputLen;
          _context200.next = 6;
          break;
        case 11:
          return _context200.abrupt("return", pbkdf2Output(PRF, PRFSalt, DK, prfW, u));
        case 12:
        case "end":
          return _context200.stop();
      }
    }, _callee199);
  }));
  return _pbkdf2Async.apply(this, arguments);
}
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  var _32n = BigInt(32);
  var _u32_max = BigInt(0xffffffff);
  var wh = Number(value >> _32n & _u32_max);
  var wl = Number(value & _u32_max);
  var h = isLE ? 4 : 0;
  var l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
var SHA2 = /*#__PURE__*/function (_Hash2) {
  _inherits(SHA2, _Hash2);
  var _super3 = _createSuper(SHA2);
  function SHA2(blockLen, outputLen, padOffset, isLE) {
    var _this7;
    _classCallCheck(this, SHA2);
    _this7 = _super3.call(this);
    _this7.blockLen = blockLen;
    _this7.outputLen = outputLen;
    _this7.padOffset = padOffset;
    _this7.isLE = isLE;
    _this7.finished = false;
    _this7.length = 0;
    _this7.pos = 0;
    _this7.destroyed = false;
    _this7.buffer = new Uint8Array(blockLen);
    _this7.view = createView(_this7.buffer);
    return _this7;
  }
  _createClass(SHA2, [{
    key: "update",
    value: function update(data) {
      assert.exists(this);
      var view = this.view,
        buffer = this.buffer,
        blockLen = this.blockLen;
      data = toBytes(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        // Fast path: we have at least one block in input, cast it to view and process
        if (take === blockLen) {
          var dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      assert.exists(this);
      assert.output(out, this);
      this.finished = true;
      // Padding
      // We can avoid allocation of buffer for padding completely if it
      // was previously not allocated here. But it won't change performance.
      var buffer = this.buffer,
        view = this.view,
        blockLen = this.blockLen,
        isLE = this.isLE;
      var pos = this.pos;
      // append the bit '1' to the message
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      // Pad until full block byte with zeros
      for (var i = pos; i < blockLen; i++) buffer[i] = 0;
      // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
      // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
      // So we just write lowest 64 bits of that value.
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      var oview = createView(out);
      this.get().forEach(function (v, i) {
        return oview.setUint32(4 * i, v, isLE);
      });
    }
  }, {
    key: "digest",
    value: function digest() {
      var buffer = this.buffer,
        outputLen = this.outputLen;
      this.digestInto(buffer);
      var res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var _to2;
      to || (to = new this.constructor());
      (_to2 = to).set.apply(_to2, _toConsumableArray(this.get()));
      var blockLen = this.blockLen,
        buffer = this.buffer,
        length = this.length,
        finished = this.finished,
        destroyed = this.destroyed,
        pos = this.pos;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
  }]);
  return SHA2;
}(Hash); // Choice: a ? b : c
var Chi = function Chi(a, b, c) {
  return a & b ^ ~a & c;
};
// Majority function, true if any two inpust is true
var Maj = function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
};
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
var SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
var IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
var SHA256_W = new Uint32Array(64);
var SHA256 = /*#__PURE__*/function (_SHA) {
  _inherits(SHA256, _SHA);
  var _super4 = _createSuper(SHA256);
  function SHA256() {
    var _this8;
    _classCallCheck(this, SHA256);
    _this8 = _super4.call(this, 64, 32, 8, false);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    _this8.A = IV[0] | 0;
    _this8.B = IV[1] | 0;
    _this8.C = IV[2] | 0;
    _this8.D = IV[3] | 0;
    _this8.E = IV[4] | 0;
    _this8.F = IV[5] | 0;
    _this8.G = IV[6] | 0;
    _this8.H = IV[7] | 0;
    return _this8;
  }
  _createClass(SHA256, [{
    key: "get",
    value: function get() {
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
      for (var _i2 = 16; _i2 < 64; _i2++) {
        var W15 = SHA256_W[_i2 - 15];
        var W2 = SHA256_W[_i2 - 2];
        var s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        var s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[_i2] = s1 + SHA256_W[_i2 - 7] + s0 + SHA256_W[_i2 - 16] | 0;
      }
      // Compression function main loop, 64 rounds
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      for (var _i3 = 0; _i3 < 64; _i3++) {
        var sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        var _T = H + sigma1 + Chi(E, F, G) + SHA256_K[_i3] + SHA256_W[_i3] | 0;
        var sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        var _T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + _T | 0;
        D = C;
        C = B;
        B = A;
        A = _T + _T2 | 0;
      }
      // Add the compressed chunk to the current hash value
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA256_W.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }]);
  return SHA256;
}(SHA2);
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
var sha256$1 = wrapConstructor(function () {
  return new SHA256();
});
var U32_MASK64 = BigInt(Math.pow(2, 32) - 1);
var _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64),
    l: Number(n >> _32n & U32_MASK64)
  };
  return {
    h: Number(n >> _32n & U32_MASK64) | 0,
    l: Number(n & U32_MASK64) | 0
  };
}
function split(lst) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var Ah = new Uint32Array(lst.length);
  var Al = new Uint32Array(lst.length);
  for (var i = 0; i < lst.length; i++) {
    var _fromBig = fromBig(lst[i], le),
      h = _fromBig.h,
      l = _fromBig.l;
    var _ref2 = [h, l];
    Ah[i] = _ref2[0];
    Al[i] = _ref2[1];
  }
  return [Ah, Al];
}
var toBig = function toBig(h, l) {
  return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
};
// for Shift in [0, 32)
var shrSH = function shrSH(h, l, s) {
  return h >>> s;
};
var shrSL = function shrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
// Right rotate for Shift in [1, 32)
var rotrSH = function rotrSH(h, l, s) {
  return h >>> s | l << 32 - s;
};
var rotrSL = function rotrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function rotrBH(h, l, s) {
  return h << 64 - s | l >>> s - 32;
};
var rotrBL = function rotrBL(h, l, s) {
  return h >>> s - 32 | l << 64 - s;
};
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function rotr32H(h, l) {
  return l;
};
var rotr32L = function rotr32L(h, l) {
  return h;
};
// Left rotate for Shift in [1, 32)
var rotlSH = function rotlSH(h, l, s) {
  return h << s | l >>> 32 - s;
};
var rotlSL = function rotlSL(h, l, s) {
  return l << s | h >>> 32 - s;
};
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function rotlBH(h, l, s) {
  return l << s - 32 | h >>> 64 - s;
};
var rotlBL = function rotlBL(h, l, s) {
  return h << s - 32 | l >>> 64 - s;
};
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
  var l = (Al >>> 0) + (Bl >>> 0);
  return {
    h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
    l: l | 0
  };
}
// Addition with more than 2 elements
var add3L = function add3L(Al, Bl, Cl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
var add3H = function add3H(low, Ah, Bh, Ch) {
  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
var add4L = function add4L(Al, Bl, Cl, Dl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
var add5L = function add5L(Al, Bl, Cl, Dl, El) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
// prettier-ignore
var u64 = {
  fromBig: fromBig,
  split: split,
  toBig: toBig,
  shrSH: shrSH,
  shrSL: shrSL,
  rotrSH: rotrSH,
  rotrSL: rotrSL,
  rotrBH: rotrBH,
  rotrBL: rotrBL,
  rotr32H: rotr32H,
  rotr32L: rotr32L,
  rotlSH: rotlSH,
  rotlSL: rotlSL,
  rotlBH: rotlBH,
  rotlBL: rotlBL,
  add: add,
  add3L: add3L,
  add3H: add3H,
  add4L: add4L,
  add4H: add4H,
  add5H: add5H,
  add5L: add5L
};

// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
var _u64$split = u64.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(function (n) {
    return BigInt(n);
  })),
  _u64$split2 = _slicedToArray(_u64$split, 2),
  SHA512_Kh = _u64$split2[0],
  SHA512_Kl = _u64$split2[1];
// Temporary buffer, not used to store anything between runs
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = /*#__PURE__*/function (_SHA2) {
  _inherits(SHA512, _SHA2);
  var _super5 = _createSuper(SHA512);
  function SHA512() {
    var _this9;
    _classCallCheck(this, SHA512);
    _this9 = _super5.call(this, 128, 64, 16, false);
    // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
    // Also looks cleaner and easier to verify with spec.
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // h -- high 32 bits, l -- low 32 bits
    _this9.Ah = 0x6a09e667 | 0;
    _this9.Al = 0xf3bcc908 | 0;
    _this9.Bh = 0xbb67ae85 | 0;
    _this9.Bl = 0x84caa73b | 0;
    _this9.Ch = 0x3c6ef372 | 0;
    _this9.Cl = 0xfe94f82b | 0;
    _this9.Dh = 0xa54ff53a | 0;
    _this9.Dl = 0x5f1d36f1 | 0;
    _this9.Eh = 0x510e527f | 0;
    _this9.El = 0xade682d1 | 0;
    _this9.Fh = 0x9b05688c | 0;
    _this9.Fl = 0x2b3e6c1f | 0;
    _this9.Gh = 0x1f83d9ab | 0;
    _this9.Gl = 0xfb41bd6b | 0;
    _this9.Hh = 0x5be0cd19 | 0;
    _this9.Hl = 0x137e2179 | 0;
    return _this9;
  }
  // prettier-ignore
  _createClass(SHA512, [{
    key: "get",
    value: function get() {
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (var _i4 = 16; _i4 < 80; _i4++) {
        // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
        var W15h = SHA512_W_H[_i4 - 15] | 0;
        var W15l = SHA512_W_L[_i4 - 15] | 0;
        var s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        var s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
        var W2h = SHA512_W_H[_i4 - 2] | 0;
        var W2l = SHA512_W_L[_i4 - 2] | 0;
        var s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        var s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
        var SUMl = u64.add4L(s0l, s1l, SHA512_W_L[_i4 - 7], SHA512_W_L[_i4 - 16]);
        var SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[_i4 - 7], SHA512_W_H[_i4 - 16]);
        SHA512_W_H[_i4] = SUMh | 0;
        SHA512_W_L[_i4] = SUMl | 0;
      }
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      // Compression function main loop, 80 rounds
      for (var _i5 = 0; _i5 < 80; _i5++) {
        // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
        var sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        var sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
        var CHIh = Eh & Fh ^ ~Eh & Gh;
        var CHIl = El & Fl ^ ~El & Gl;
        // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
        // prettier-ignore
        var T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i5], SHA512_W_L[_i5]);
        var T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i5], SHA512_W_H[_i5]);
        var T1l = T1ll | 0;
        // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
        var sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        var sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        var _u64$add = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);
        Eh = _u64$add.h;
        El = _u64$add.l;
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        var All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      // Add the compressed chunk to the current hash value
      var _u64$add2 = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);
      Ah = _u64$add2.h;
      Al = _u64$add2.l;
      var _u64$add3 = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);
      Bh = _u64$add3.h;
      Bl = _u64$add3.l;
      var _u64$add4 = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);
      Ch = _u64$add4.h;
      Cl = _u64$add4.l;
      var _u64$add5 = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);
      Dh = _u64$add5.h;
      Dl = _u64$add5.l;
      var _u64$add6 = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);
      Eh = _u64$add6.h;
      El = _u64$add6.l;
      var _u64$add7 = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);
      Fh = _u64$add7.h;
      Fl = _u64$add7.l;
      var _u64$add8 = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);
      Gh = _u64$add8.h;
      Gl = _u64$add8.l;
      var _u64$add9 = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);
      Hh = _u64$add9.h;
      Hl = _u64$add9.l;
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }]);
  return SHA512;
}(SHA2);
var SHA512_256 = /*#__PURE__*/function (_SHA3) {
  _inherits(SHA512_256, _SHA3);
  var _super6 = _createSuper(SHA512_256);
  function SHA512_256() {
    var _this10;
    _classCallCheck(this, SHA512_256);
    _this10 = _super6.call(this);
    // h -- high 32 bits, l -- low 32 bits
    _this10.Ah = 0x22312194 | 0;
    _this10.Al = 0xfc2bf72c | 0;
    _this10.Bh = 0x9f555fa3 | 0;
    _this10.Bl = 0xc84c64c2 | 0;
    _this10.Ch = 0x2393b86b | 0;
    _this10.Cl = 0x6f53b151 | 0;
    _this10.Dh = 0x96387719 | 0;
    _this10.Dl = 0x5940eabd | 0;
    _this10.Eh = 0x96283ee2 | 0;
    _this10.El = 0xa88effe3 | 0;
    _this10.Fh = 0xbe5e1e25 | 0;
    _this10.Fl = 0x53863992 | 0;
    _this10.Gh = 0x2b0199fc | 0;
    _this10.Gl = 0x2c85b8aa | 0;
    _this10.Hh = 0x0eb72ddc | 0;
    _this10.Hl = 0x81c52ca2 | 0;
    _this10.outputLen = 32;
    return _this10;
  }
  return _createClass(SHA512_256);
}(SHA512);
var SHA384 = /*#__PURE__*/function (_SHA4) {
  _inherits(SHA384, _SHA4);
  var _super7 = _createSuper(SHA384);
  function SHA384() {
    var _this11;
    _classCallCheck(this, SHA384);
    _this11 = _super7.call(this);
    // h -- high 32 bits, l -- low 32 bits
    _this11.Ah = 0xcbbb9d5d | 0;
    _this11.Al = 0xc1059ed8 | 0;
    _this11.Bh = 0x629a292a | 0;
    _this11.Bl = 0x367cd507 | 0;
    _this11.Ch = 0x9159015a | 0;
    _this11.Cl = 0x3070dd17 | 0;
    _this11.Dh = 0x152fecd8 | 0;
    _this11.Dl = 0xf70e5939 | 0;
    _this11.Eh = 0x67332667 | 0;
    _this11.El = 0xffc00b31 | 0;
    _this11.Fh = 0x8eb44a87 | 0;
    _this11.Fl = 0x68581511 | 0;
    _this11.Gh = 0xdb0c2e0d | 0;
    _this11.Gl = 0x64f98fa7 | 0;
    _this11.Hh = 0x47b5481d | 0;
    _this11.Hl = 0xbefa4fa4 | 0;
    _this11.outputLen = 48;
    return _this11;
  }
  return _createClass(SHA384);
}(SHA512);
var sha512$1 = wrapConstructor(function () {
  return new SHA512();
});
var sha512_256 = wrapConstructor(function () {
  return new SHA512_256();
});
var sha384 = wrapConstructor(function () {
  return new SHA384();
});

/* Browser Crypto Shims */
function getGlobal$1() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}
;
var anyGlobal = getGlobal$1();
var crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$1.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  var algo = {
    sha256: sha256$1,
    sha512: sha512$1
  }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  var algo = {
    sha256: sha256$1,
    sha512: sha512$1
  }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}
function randomBytes$1(length) {
  assert$1(crypto$1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  var result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}

/**
 *  An **HMAC** enables verification that a given key was used
 *  to authenticate a payload.
 *
 *  See: [[link-wiki-hmac]]
 *
 *  @_subsection: api/crypto:HMAC  [about-hmac]
 */
var locked$4 = false;
var _computeHmac = function _computeHmac(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
var __computeHmac = _computeHmac;
/**
 *  Return the HMAC for %%data%% using the %%key%% key with the underlying
 *  %%algo%% used for compression.
 *
 *  @example:
 *    key = id("some-secret")
 *
 *    // Compute the HMAC
 *    computeHmac("sha256", key, "0x1337")
 *    //_result:
 *
 *    // To compute the HMAC of UTF-8 data, the data must be
 *    // converted to UTF-8 bytes
 *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
 *    //_result:
 *
 */
function computeHmac(algorithm, _key, _data) {
  var key = getBytes(_key, "key");
  var data = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function () {
  locked$4 = true;
};
computeHmac.register = function (func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// Various per round constants calculations
var SHA3_PI = [],
  SHA3_ROTL = [],
  _SHA3_IOTA = [];
var _0n$1 = BigInt(0);
var _1n$1 = BigInt(1);
var _2n$1 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(0x71);
for (var round = 0, R = _1n$1, x = 1, y = 0; round < 24; round++) {
  // Pi
  var _ref3 = [y, (2 * x + 3 * y) % 5];
  x = _ref3[0];
  y = _ref3[1];
  SHA3_PI.push(2 * (5 * y + x));
  // Rotational
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  // Iota
  var t = _0n$1;
  for (var j = 0; j < 7; j++) {
    R = (R << _1n$1 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n$1) t ^= _1n$1 << (_1n$1 << BigInt(j)) - _1n$1;
  }
  _SHA3_IOTA.push(t);
}
var _u64$split3 = u64.split(_SHA3_IOTA, true),
  _u64$split4 = _slicedToArray(_u64$split3, 2),
  SHA3_IOTA_H = _u64$split4[0],
  SHA3_IOTA_L = _u64$split4[1];
// Left rotation (without 0, 32, 64)
var rotlH = function rotlH(h, l, s) {
  return s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
};
var rotlL = function rotlL(h, l, s) {
  return s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
};
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s) {
  var rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
  var B = new Uint32Array(5 * 2);
  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
  for (var _round = 24 - rounds; _round < 24; _round++) {
    // Theta θ
    for (var _x15 = 0; _x15 < 10; _x15++) B[_x15] = s[_x15] ^ s[_x15 + 10] ^ s[_x15 + 20] ^ s[_x15 + 30] ^ s[_x15 + 40];
    for (var _x16 = 0; _x16 < 10; _x16 += 2) {
      var idx1 = (_x16 + 8) % 10;
      var idx0 = (_x16 + 2) % 10;
      var B0 = B[idx0];
      var B1 = B[idx0 + 1];
      var Th = rotlH(B0, B1, 1) ^ B[idx1];
      var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (var _y = 0; _y < 50; _y += 10) {
        s[_x16 + _y] ^= Th;
        s[_x16 + _y + 1] ^= Tl;
      }
    }
    // Rho (ρ) and Pi (π)
    var curH = s[2];
    var curL = s[3];
    for (var _t = 0; _t < 24; _t++) {
      var shift = SHA3_ROTL[_t];
      var _Th = rotlH(curH, curL, shift);
      var _Tl = rotlL(curH, curL, shift);
      var PI = SHA3_PI[_t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = _Th;
      s[PI + 1] = _Tl;
    }
    // Chi (χ)
    for (var _y2 = 0; _y2 < 50; _y2 += 10) {
      for (var _x17 = 0; _x17 < 10; _x17++) B[_x17] = s[_y2 + _x17];
      for (var _x18 = 0; _x18 < 10; _x18++) s[_y2 + _x18] ^= ~B[(_x18 + 2) % 10] & B[(_x18 + 4) % 10];
    }
    // Iota (ι)
    s[0] ^= SHA3_IOTA_H[_round];
    s[1] ^= SHA3_IOTA_L[_round];
  }
  B.fill(0);
}
var Keccak = /*#__PURE__*/function (_Hash3) {
  _inherits(Keccak, _Hash3);
  var _super8 = _createSuper(Keccak);
  // NOTE: we accept arguments in bytes instead of bits here.
  function Keccak(blockLen, suffix, outputLen) {
    var _this12;
    var enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;
    _classCallCheck(this, Keccak);
    _this12 = _super8.call(this);
    _this12.blockLen = blockLen;
    _this12.suffix = suffix;
    _this12.outputLen = outputLen;
    _this12.enableXOF = enableXOF;
    _this12.rounds = rounds;
    _this12.pos = 0;
    _this12.posOut = 0;
    _this12.finished = false;
    _this12.destroyed = false;
    // Can be passed from user as dkLen
    assert.number(outputLen);
    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
    if (0 >= _this12.blockLen || _this12.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
    _this12.state = new Uint8Array(200);
    _this12.state32 = u32(_this12.state);
    return _this12;
  }
  _createClass(Keccak, [{
    key: "keccak",
    value: function keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
  }, {
    key: "update",
    value: function update(data) {
      assert.exists(this);
      var blockLen = this.blockLen,
        state = this.state;
      data = toBytes(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        for (var i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen) this.keccak();
      }
      return this;
    }
  }, {
    key: "finish",
    value: function finish() {
      if (this.finished) return;
      this.finished = true;
      var state = this.state,
        suffix = this.suffix,
        pos = this.pos,
        blockLen = this.blockLen;
      // Do the padding
      state[pos] ^= suffix;
      if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
      state[blockLen - 1] ^= 0x80;
      this.keccak();
    }
  }, {
    key: "writeInto",
    value: function writeInto(out) {
      assert.exists(this, false);
      assert.bytes(out);
      this.finish();
      var bufferOut = this.state;
      var blockLen = this.blockLen;
      for (var pos = 0, len = out.length; pos < len;) {
        if (this.posOut >= blockLen) this.keccak();
        var take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
  }, {
    key: "xofInto",
    value: function xofInto(out) {
      // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
      if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
      return this.writeInto(out);
    }
  }, {
    key: "xof",
    value: function xof(bytes) {
      assert.number(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      assert.output(out, this);
      if (this.finished) throw new Error('digest() was already called');
      this.writeInto(out);
      this.destroy();
      return out;
    }
  }, {
    key: "digest",
    value: function digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var blockLen = this.blockLen,
        suffix = this.suffix,
        outputLen = this.outputLen,
        rounds = this.rounds,
        enableXOF = this.enableXOF;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      // Suffix can change in cSHAKE
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }]);
  return Keccak;
}(Hash);
var gen = function gen(suffix, blockLen, outputLen) {
  return wrapConstructor(function () {
    return new Keccak(blockLen, suffix, outputLen);
  });
};
var sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
var sha3_256 = gen(0x06, 136, 256 / 8);
var sha3_384 = gen(0x06, 104, 384 / 8);
var sha3_512 = gen(0x06, 72, 512 / 8);
var keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
var keccak_256 = gen(0x01, 136, 256 / 8);
var keccak_384 = gen(0x01, 104, 384 / 8);
var keccak_512 = gen(0x01, 72, 512 / 8);
var genShake = function genShake(suffix, blockLen, outputLen) {
  return wrapConstructorWithOpts(function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
  });
};
var shake128 = genShake(0x1f, 168, 128 / 8);
var shake256 = genShake(0x1f, 136, 256 / 8);

/**
 *  Cryptographic hashing functions
 *
 *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
 */
var locked$3 = false;
var _keccak256 = function _keccak256(data) {
  return keccak_256(data);
};
var __keccak256 = _keccak256;
/**
 *  Compute the cryptographic KECCAK256 hash of %%data%%.
 *
 *  The %%data%% **must** be a data representation, to compute the
 *  hash of UTF-8 data use the [[id]] function.
 *
 *  @returns DataHexstring
 *  @example:
 *    keccak256("0x")
 *    //_result:
 *
 *    keccak256("0x1337")
 *    //_result:
 *
 *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 *    // Strings are assumed to be DataHexString, otherwise it will
 *    // throw. To hash UTF-8 data, see the note above.
 *    keccak256("Hello World")
 *    //_error:
 */
function keccak256(_data) {
  var data = getBytes(_data, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function () {
  locked$3 = true;
};
keccak256.register = function (func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({
  length: 16
}, function (_, i) {
  return i;
});
var Pi = Id.map(function (i) {
  return (9 * i + 5) % 16;
});
var idxL = [Id];
var idxR = [Pi];
for (var i = 0; i < 4; i++) for (var _i6 = 0, _arr2 = [idxL, idxR]; _i6 < _arr2.length; _i6++) {
  var _j = _arr2[_i6];
  _j.push(_j[i].map(function (k) {
    return Rho[k];
  }));
}
var shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {
  return new Uint8Array(i);
});
var shiftsL = idxL.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var shiftsR = idxR.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
var Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
var rotl$1 = function rotl$1(word, shift) {
  return word << shift | word >>> 32 - shift;
};
// It's called f() in spec.
function f(group, x, y, z) {
  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
var BUF = new Uint32Array(16);
var RIPEMD160 = /*#__PURE__*/function (_SHA5) {
  _inherits(RIPEMD160, _SHA5);
  var _super9 = _createSuper(RIPEMD160);
  function RIPEMD160() {
    var _this13;
    _classCallCheck(this, RIPEMD160);
    _this13 = _super9.call(this, 64, 20, 8, true);
    _this13.h0 = 0x67452301 | 0;
    _this13.h1 = 0xefcdab89 | 0;
    _this13.h2 = 0x98badcfe | 0;
    _this13.h3 = 0x10325476 | 0;
    _this13.h4 = 0xc3d2e1f0 | 0;
    return _this13;
  }
  _createClass(RIPEMD160, [{
    key: "get",
    value: function get() {
      var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3,
        h4 = this.h4;
      return [h0, h1, h2, h3, h4];
    }
  }, {
    key: "set",
    value: function set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var _i7 = 0; _i7 < 16; _i7++, offset += 4) BUF[_i7] = view.getUint32(offset, true);
      // prettier-ignore
      var al = this.h0 | 0,
        ar = al,
        bl = this.h1 | 0,
        br = bl,
        cl = this.h2 | 0,
        cr = cl,
        dl = this.h3 | 0,
        dr = dl,
        el = this.h4 | 0,
        er = el;
      // Instead of iterating 0 to 80, we split it into 5 groups
      // And use the groups in constants, functions, etc. Much simpler
      for (var group = 0; group < 5; group++) {
        var rGroup = 4 - group;
        var hbl = Kl[group],
          hbr = Kr[group]; // prettier-ignore
        var rl = idxL[group],
          rr = idxR[group]; // prettier-ignore
        var sl = shiftsL[group],
          sr = shiftsR[group]; // prettier-ignore
        for (var _i8 = 0; _i8 < 16; _i8++) {
          var tl = rotl$1(al + f(group, bl, cl, dl) + BUF[rl[_i8]] + hbl, sl[_i8]) + el | 0;
          al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
        }
        // 2 loops are 10% faster
        for (var _i9 = 0; _i9 < 16; _i9++) {
          var tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[_i9]] + hbr, sr[_i9]) + er | 0;
          ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
        }
      }
      // Add the compressed chunk to the current hash value
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      BUF.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  }]);
  return RIPEMD160;
}(SHA2);
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
var ripemd160$1 = wrapConstructor(function () {
  return new RIPEMD160();
});
var locked$2 = false;
var _ripemd160 = function _ripemd160(data) {
  return ripemd160$1(data);
};
var __ripemd160 = _ripemd160;
/**
 *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    ripemd160("0x")
 *    //_result:
 *
 *    ripemd160("0x1337")
 *    //_result:
 *
 *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function ripemd160(_data) {
  var data = getBytes(_data, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function () {
  locked$2 = true;
};
ripemd160.register = function (func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);

/**
 *  A **Password-Based Key-Derivation Function** is designed to create
 *  a sequence of bytes suitible as a **key** from a human-rememberable
 *  password.
 *
 *  @_subsection: api/crypto:Passwords  [about-pbkdf]
 */
var locked$1 = false;
var _pbkdf2 = function _pbkdf2(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
/**
 *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
 *  the %%salt%% and using %%iterations%% of %%algo%%.
 *
 *  This PBKDF is outdated and should not be used in new projects, but is
 *  required to decrypt older files.
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the PBKDF2
 *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
 *    //_result:
 */
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  var password = getBytes(_password, "password");
  var salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function () {
  locked$1 = true;
};
pbkdf2.register = function (func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);

/**
 *  A **Cryptographically Secure Random Value** is one that has been
 *  generated with additional care take to prevent side-channels
 *  from allowing others to detect it and prevent others from through
 *  coincidence generate the same values.
 *
 *  @_subsection: api/crypto:Random Values  [about-crypto-random]
 */
var locked = false;
var _randomBytes = function _randomBytes(length) {
  return new Uint8Array(randomBytes$1(length));
};
var __randomBytes = _randomBytes;
/**
 *  Return %%length%% bytes of cryptographically secure random data.
 *
 *  @example:
 *    randomBytes(8)
 *    //_result:
 */
function randomBytes(length) {
  return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function () {
  locked = true;
};
randomBytes.register = function (func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);

// RFC 7914 Scrypt KDF
// Left rotate for uint32
var rotl = function rotl(a, b) {
  return a << b | a >>> 32 - b;
};
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  // Based on https://cr.yp.to/salsa20.html
  // Xor blocks
  var y00 = prev[pi++] ^ input[ii++],
    y01 = prev[pi++] ^ input[ii++];
  var y02 = prev[pi++] ^ input[ii++],
    y03 = prev[pi++] ^ input[ii++];
  var y04 = prev[pi++] ^ input[ii++],
    y05 = prev[pi++] ^ input[ii++];
  var y06 = prev[pi++] ^ input[ii++],
    y07 = prev[pi++] ^ input[ii++];
  var y08 = prev[pi++] ^ input[ii++],
    y09 = prev[pi++] ^ input[ii++];
  var y10 = prev[pi++] ^ input[ii++],
    y11 = prev[pi++] ^ input[ii++];
  var y12 = prev[pi++] ^ input[ii++],
    y13 = prev[pi++] ^ input[ii++];
  var y14 = prev[pi++] ^ input[ii++],
    y15 = prev[pi++] ^ input[ii++];
  // Save state to temporary variables (salsa)
  var x00 = y00,
    x01 = y01,
    x02 = y02,
    x03 = y03,
    x04 = y04,
    x05 = y05,
    x06 = y06,
    x07 = y07,
    x08 = y08,
    x09 = y09,
    x10 = y10,
    x11 = y11,
    x12 = y12,
    x13 = y13,
    x14 = y14,
    x15 = y15;
  // Main loop (salsa)
  for (var _i10 = 0; _i10 < 8; _i10 += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  // Write output (salsa)
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
  var head = oi + 0;
  var tail = oi + 16 * r;
  for (var _i11 = 0; _i11 < 16; _i11++) out[tail + _i11] = input[ii + (2 * r - 1) * 16 + _i11]; // X ← B[2r−1]
  for (var _i12 = 0; _i12 < r; _i12++, head += 16, ii += 16) {
    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
    if (_i12 > 0) tail += 16; // First iteration overwrites tmp value in tail
    XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
  }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
  // Maxmem - 1GB+1KB by default
  var opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: Math.pow(1024, 3) + 1024
  }, _opts);
  var N = opts.N,
    r = opts.r,
    p = opts.p,
    dkLen = opts.dkLen,
    asyncTick = opts.asyncTick,
    maxmem = opts.maxmem,
    onProgress = opts.onProgress;
  assert.number(N);
  assert.number(r);
  assert.number(p);
  assert.number(dkLen);
  assert.number(asyncTick);
  assert.number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');
  var blockSize = 128 * r;
  var blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= Math.pow(2, blockSize / 8) || N > Math.pow(2, 32)) {
    // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
    // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
    throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
  }
  if (p < 0 || p > (Math.pow(2, 32) - 1) * 32 / blockSize) {
    throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
  }
  if (dkLen < 0 || dkLen > (Math.pow(2, 32) - 1) * 32) {
    throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
  }
  var memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: parameters too large, ".concat(memUsed, " (128 * r * (N + p)) > ").concat(maxmem, " (maxmem)"));
  }
  // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
  // Since it has only one iteration there is no reason to use async variant
  var B = pbkdf2$1(sha256$1, password, salt, {
    c: 1,
    dkLen: blockSize * p
  });
  var B32 = u32(B);
  // Re-used between parallel iterations. Array(iterations) of B
  var V = u32(new Uint8Array(blockSize * N));
  var tmp = u32(new Uint8Array(blockSize));
  var blockMixCb = function blockMixCb() {};
  if (onProgress) {
    var totalBlockMix = 2 * N * p;
    // Invoke callback if progress changes from 10.01 to 10.02
    // Allows to draw smooth progress bar on up to 8K screen
    var callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
    var blockMixCnt = 0;
    blockMixCb = function blockMixCb() {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return {
    N: N,
    r: r,
    p: p,
    dkLen: dkLen,
    blockSize32: blockSize32,
    V: V,
    B32: B32,
    B: B,
    tmp: tmp,
    blockMixCb: blockMixCb,
    asyncTick: asyncTick
  };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  var res = pbkdf2$1(sha256$1, password, B, {
    c: 1,
    dkLen: dkLen
  });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
/**
 * Scrypt KDF from RFC 7914.
 * @param password - pass
 * @param salt - salt
 * @param opts - parameters
 * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
 * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
 * - `p` is parallelization factor (1 is common)
 * - `dkLen` is output key length in bytes e.g. 32.
 * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
 * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
 * - `onProgress` - callback function that would be executed for progress report
 * @returns Derived key
 */
function scrypt$1(password, salt, opts) {
  var _scryptInit = scryptInit(password, salt, opts),
    N = _scryptInit.N,
    r = _scryptInit.r,
    p = _scryptInit.p,
    dkLen = _scryptInit.dkLen,
    blockSize32 = _scryptInit.blockSize32,
    V = _scryptInit.V,
    B32 = _scryptInit.B32,
    B = _scryptInit.B,
    tmp = _scryptInit.tmp,
    blockMixCb = _scryptInit.blockMixCb;
  for (var pi = 0; pi < p; pi++) {
    var _Pi = blockSize32 * pi;
    for (var _i13 = 0; _i13 < blockSize32; _i13++) V[_i13] = B32[_Pi + _i13]; // V[0] = B[i]
    for (var _i14 = 0, pos = 0; _i14 < N - 1; _i14++) {
      BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, _Pi, r); // Process last element
    blockMixCb();
    for (var _i15 = 0; _i15 < N; _i15++) {
      // First u32 of the last 64-byte block (u32 is LE)
      var _j2 = B32[_Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
      for (var k = 0; k < blockSize32; k++) tmp[k] = B32[_Pi + k] ^ V[_j2 * blockSize32 + k]; // tmp = B ^ V[j]
      BlockMix(tmp, 0, B32, _Pi, r); // B = BlockMix(B ^ V[j])
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
/**
 * Scrypt KDF from RFC 7914.
 */
function scryptAsync(_x19, _x20, _x21) {
  return _scryptAsync2.apply(this, arguments);
}
function _scryptAsync2() {
  _scryptAsync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee200(password, salt, opts) {
    var _scryptInit2, N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick, _loop7, pi;
    return _regeneratorRuntime().wrap(function _callee200$(_context202) {
      while (1) switch (_context202.prev = _context202.next) {
        case 0:
          _scryptInit2 = scryptInit(password, salt, opts), N = _scryptInit2.N, r = _scryptInit2.r, p = _scryptInit2.p, dkLen = _scryptInit2.dkLen, blockSize32 = _scryptInit2.blockSize32, V = _scryptInit2.V, B32 = _scryptInit2.B32, B = _scryptInit2.B, tmp = _scryptInit2.tmp, blockMixCb = _scryptInit2.blockMixCb, asyncTick = _scryptInit2.asyncTick;
          _loop7 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop7() {
            var Pi, _i91, pos;
            return _regeneratorRuntime().wrap(function _loop7$(_context201) {
              while (1) switch (_context201.prev = _context201.next) {
                case 0:
                  Pi = blockSize32 * pi;
                  for (_i91 = 0; _i91 < blockSize32; _i91++) V[_i91] = B32[Pi + _i91]; // V[0] = B[i]
                  pos = 0;
                  _context201.next = 5;
                  return asyncLoop(N - 1, asyncTick, function (i) {
                    BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
                    blockMixCb();
                  });
                case 5:
                  BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
                  blockMixCb();
                  _context201.next = 9;
                  return asyncLoop(N, asyncTick, function (i) {
                    // First u32 of the last 64-byte block (u32 is LE)
                    var j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
                    for (var k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
                    BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
                    blockMixCb();
                  });
                case 9:
                case "end":
                  return _context201.stop();
              }
            }, _loop7);
          });
          pi = 0;
        case 3:
          if (!(pi < p)) {
            _context202.next = 8;
            break;
          }
          return _context202.delegateYield(_loop7(), "t0", 5);
        case 5:
          pi++;
          _context202.next = 3;
          break;
        case 8:
          return _context202.abrupt("return", scryptOutput(password, dkLen, B, V, tmp));
        case 9:
        case "end":
          return _context202.stop();
      }
    }, _callee200);
  }));
  return _scryptAsync2.apply(this, arguments);
}
var lockedSync = false,
  lockedAsync = false;
var _scryptAsync = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(passwd, salt, N, r, p, dkLen, onProgress) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return scryptAsync(passwd, salt, {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            onProgress: onProgress
          });
        case 2:
          return _context4.abrupt("return", _context4.sent);
        case 3:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function _scryptAsync(_x22, _x23, _x24, _x25, _x26, _x27, _x28) {
    return _ref4.apply(this, arguments);
  };
}();
var _scryptSync = function _scryptSync(passwd, salt, N, r, p, dkLen) {
  return scrypt$1(passwd, salt, {
    N: N,
    r: r,
    p: p,
    dkLen: dkLen
  });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
/**
 *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
 *  derivation to increase the resource cost to brute-force a password
 *  for a given key.
 *
 *  This means this algorithm is intentionally slow, and can be tuned to
 *  become slower. As computation and memory speed improve over time,
 *  increasing the difficulty maintains the cost of an attacker.
 *
 *  For example, if a target time of 5 seconds is used, a legitimate user
 *  which knows their password requires only 5 seconds to unlock their
 *  account. A 6 character password has 68 billion possibilities, which
 *  would require an attacker to invest over 10,000 years of CPU time. This
 *  is of course a crude example (as password generally aren't random),
 *  but demonstrates to value of imposing large costs to decryption.
 *
 *  For this reason, if building a UI which involved decrypting or
 *  encrypting datsa using scrypt, it is recommended to use a
 *  [[ProgressCallback]] (as event short periods can seem lik an eternity
 *  if the UI freezes). Including the phrase //"decrypting"// in the UI
 *  can also help, assuring the user their waiting is for a good reason.
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scrypt(_x29, _x30, _x31, _x32, _x33, _x34, _x35) {
  return _scrypt.apply(this, arguments);
}
function _scrypt() {
  _scrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee201(_passwd, _salt, N, r, p, dkLen, progress) {
    var passwd, salt;
    return _regeneratorRuntime().wrap(function _callee201$(_context203) {
      while (1) switch (_context203.prev = _context203.next) {
        case 0:
          passwd = getBytes(_passwd, "passwd");
          salt = getBytes(_salt, "salt");
          _context203.t0 = hexlify;
          _context203.next = 5;
          return __scryptAsync(passwd, salt, N, r, p, dkLen, progress);
        case 5:
          _context203.t1 = _context203.sent;
          return _context203.abrupt("return", (0, _context203.t0)(_context203.t1));
        case 7:
        case "end":
          return _context203.stop();
      }
    }, _callee201);
  }));
  return _scrypt.apply(this, arguments);
}
scrypt._ = _scryptAsync;
scrypt.lock = function () {
  lockedAsync = true;
};
scrypt.register = function (func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
/**
 *  Provides a synchronous variant of [[scrypt]].
 *
 *  This will completely lock up and freeze the UI in a browser and will
 *  prevent any event loop from progressing. For this reason, it is
 *  preferred to use the [async variant](scrypt).
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
  var passwd = getBytes(_passwd, "passwd");
  var salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function () {
  lockedSync = true;
};
scryptSync.register = function (func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
var _sha256 = function _sha256(data) {
  return createHash("sha256").update(data).digest();
};
var _sha512 = function _sha512(data) {
  return createHash("sha512").update(data).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false,
  locked512 = false;
/**
 *  Compute the cryptographic SHA2-256 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha256("0x")
 *    //_result:
 *
 *    sha256("0x1337")
 *    //_result:
 *
 *    sha256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function sha256(_data) {
  var data = getBytes(_data, "data");
  return hexlify(__sha256(data));
}
sha256._ = _sha256;
sha256.lock = function () {
  locked256 = true;
};
sha256.register = function (func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
/**
 *  Compute the cryptographic SHA2-512 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha512("0x")
 *    //_result:
 *
 *    sha512("0x1337")
 *    //_result:
 *
 *    sha512(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 */
function sha512(_data) {
  var data = getBytes(_data, "data");
  return hexlify(__sha512(data));
}
sha512._ = _sha512;
sha512.lock = function () {
  locked512 = true;
};
sha512.register = function (func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256);
var _nodeResolve_empty = {};
var nodeCrypto = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': _nodeResolve_empty
});

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  h: _1n,
  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')
});
var divNearest = function divNearest(a, b) {
  return (a + b / _2n) / b;
};
var endo = {
  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
  splitScalar: function splitScalar(k) {
    var n = CURVE.n;
    var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
    var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
    var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
    var b2 = a1;
    var POW_2_128 = BigInt('0x100000000000000000000000000000000');
    var c1 = divNearest(b2 * k, n);
    var c2 = divNearest(-b1 * k, n);
    var k1 = mod(k - c1 * a1 - c2 * a2, n);
    var k2 = mod(-c1 * b1 - c2 * b2, n);
    var k1neg = k1 > POW_2_128;
    var k2neg = k2 > POW_2_128;
    if (k1neg) k1 = n - k1;
    if (k2neg) k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
    }
    return {
      k1neg: k1neg,
      k1: k1,
      k2neg: k2neg,
      k2: k2
    };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  var a = CURVE.a,
    b = CURVE.b;
  var x2 = mod(x * x);
  var x3 = mod(x2 * x);
  return mod(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n;
var ShaError = /*#__PURE__*/function (_Error) {
  _inherits(ShaError, _Error);
  var _super10 = _createSuper(ShaError);
  function ShaError(message) {
    _classCallCheck(this, ShaError);
    return _super10.call(this, message);
  }
  return _createClass(ShaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');
}
var JacobianPoint = /*#__PURE__*/function () {
  function JacobianPoint(x, y, z) {
    _classCallCheck(this, JacobianPoint);
    this.x = x;
    this.y = y;
    this.z = z;
  }
  _createClass(JacobianPoint, [{
    key: "equals",
    value: function equals(other) {
      assertJacPoint(other);
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var X2 = other.x,
        Y2 = other.y,
        Z2 = other.z;
      var Z1Z1 = mod(Z1 * Z1);
      var Z2Z2 = mod(Z2 * Z2);
      var U1 = mod(X1 * Z2Z2);
      var U2 = mod(X2 * Z1Z1);
      var S1 = mod(mod(Y1 * Z2) * Z2Z2);
      var S2 = mod(mod(Y2 * Z1) * Z1Z1);
      return U1 === U2 && S1 === S2;
    }
  }, {
    key: "negate",
    value: function negate() {
      return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
  }, {
    key: "double",
    value: function double() {
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var A = mod(X1 * X1);
      var B = mod(Y1 * Y1);
      var C = mod(B * B);
      var x1b = X1 + B;
      var D = mod(_2n * (mod(x1b * x1b) - A - C));
      var E = mod(_3n * A);
      var F = mod(E * E);
      var X3 = mod(F - _2n * D);
      var Y3 = mod(E * (D - X3) - _8n * C);
      var Z3 = mod(_2n * Y1 * Z1);
      return new JacobianPoint(X3, Y3, Z3);
    }
  }, {
    key: "add",
    value: function add(other) {
      assertJacPoint(other);
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var X2 = other.x,
        Y2 = other.y,
        Z2 = other.z;
      if (X2 === _0n || Y2 === _0n) return this;
      if (X1 === _0n || Y1 === _0n) return other;
      var Z1Z1 = mod(Z1 * Z1);
      var Z2Z2 = mod(Z2 * Z2);
      var U1 = mod(X1 * Z2Z2);
      var U2 = mod(X2 * Z1Z1);
      var S1 = mod(mod(Y1 * Z2) * Z2Z2);
      var S2 = mod(mod(Y2 * Z1) * Z1Z1);
      var H = mod(U2 - U1);
      var r = mod(S2 - S1);
      if (H === _0n) {
        if (r === _0n) {
          return this["double"]();
        } else {
          return JacobianPoint.ZERO;
        }
      }
      var HH = mod(H * H);
      var HHH = mod(H * HH);
      var V = mod(U1 * HH);
      var X3 = mod(r * r - HHH - _2n * V);
      var Y3 = mod(r * (V - X3) - S1 * HHH);
      var Z3 = mod(Z1 * Z2 * H);
      return new JacobianPoint(X3, Y3, Z3);
    }
  }, {
    key: "subtract",
    value: function subtract(other) {
      return this.add(other.negate());
    }
  }, {
    key: "multiplyUnsafe",
    value: function multiplyUnsafe(scalar) {
      var P0 = JacobianPoint.ZERO;
      if (typeof scalar === 'bigint' && scalar === _0n) return P0;
      var n = normalizeScalar(scalar);
      if (n === _1n) return this;
      if (!USE_ENDOMORPHISM) {
        var p = P0;
        var _d2 = this;
        while (n > _0n) {
          if (n & _1n) p = p.add(_d2);
          _d2 = _d2["double"]();
          n >>= _1n;
        }
        return p;
      }
      var _endo$splitScalar = endo.splitScalar(n),
        k1neg = _endo$splitScalar.k1neg,
        k1 = _endo$splitScalar.k1,
        k2neg = _endo$splitScalar.k2neg,
        k2 = _endo$splitScalar.k2;
      var k1p = P0;
      var k2p = P0;
      var d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n) k1p = k1p.add(d);
        if (k2 & _1n) k2p = k2p.add(d);
        d = d["double"]();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      if (k1neg) k1p = k1p.negate();
      if (k2neg) k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
      return k1p.add(k2p);
    }
  }, {
    key: "precomputeWindow",
    value: function precomputeWindow(W) {
      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
      var points = [];
      var p = this;
      var base = p;
      for (var _window = 0; _window < windows; _window++) {
        base = p;
        points.push(base);
        for (var _i16 = 1; _i16 < Math.pow(2, W - 1); _i16++) {
          base = base.add(p);
          points.push(base);
        }
        p = base["double"]();
      }
      return points;
    }
  }, {
    key: "wNAF",
    value: function wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
      }
      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = JacobianPoint.normalizeZ(precomputes);
          pointPrecomputes.set(affinePoint, precomputes);
        }
      }
      var p = JacobianPoint.ZERO;
      var f = JacobianPoint.BASE;
      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
      var windowSize = Math.pow(2, W - 1);
      var mask = BigInt(Math.pow(2, W) - 1);
      var maxNumber = Math.pow(2, W);
      var shiftBy = BigInt(W);
      for (var _window2 = 0; _window2 < windows; _window2++) {
        var offset = _window2 * windowSize;
        var wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n;
        }
        var offset1 = offset;
        var offset2 = offset + Math.abs(wbits) - 1;
        var cond1 = _window2 % 2 !== 0;
        var cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return {
        p: p,
        f: f
      };
    }
  }, {
    key: "multiply",
    value: function multiply(scalar, affinePoint) {
      var n = normalizeScalar(scalar);
      var point;
      var fake;
      if (USE_ENDOMORPHISM) {
        var _endo$splitScalar2 = endo.splitScalar(n),
          k1neg = _endo$splitScalar2.k1neg,
          k1 = _endo$splitScalar2.k1,
          k2neg = _endo$splitScalar2.k2neg,
          k2 = _endo$splitScalar2.k2;
        var _this$wNAF = this.wNAF(k1, affinePoint),
          k1p = _this$wNAF.p,
          f1p = _this$wNAF.f;
        var _this$wNAF2 = this.wNAF(k2, affinePoint),
          k2p = _this$wNAF2.p,
          f2p = _this$wNAF2.f;
        k1p = constTimeNegate(k1neg, k1p);
        k2p = constTimeNegate(k2neg, k2p);
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        var _this$wNAF3 = this.wNAF(n, affinePoint),
          p = _this$wNAF3.p,
          _f = _this$wNAF3.f;
        point = p;
        fake = _f;
      }
      return JacobianPoint.normalizeZ([point, fake])[0];
    }
  }, {
    key: "toAffine",
    value: function toAffine(invZ) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var is0 = this.equals(JacobianPoint.ZERO);
      if (invZ == null) invZ = is0 ? _8n : invert(z);
      var iz1 = invZ;
      var iz2 = mod(iz1 * iz1);
      var iz3 = mod(iz2 * iz1);
      var ax = mod(x * iz2);
      var ay = mod(y * iz3);
      var zz = mod(z * iz1);
      if (is0) return Point.ZERO;
      if (zz !== _1n) throw new Error('invZ was invalid');
      return new Point(ax, ay);
    }
  }], [{
    key: "fromAffine",
    value: function fromAffine(p) {
      if (!(p instanceof Point)) {
        throw new TypeError('JacobianPoint#fromAffine: expected Point');
      }
      if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
      return new JacobianPoint(p.x, p.y, _1n);
    }
  }, {
    key: "toAffineBatch",
    value: function toAffineBatch(points) {
      var toInv = invertBatch(points.map(function (p) {
        return p.z;
      }));
      return points.map(function (p, i) {
        return p.toAffine(toInv[i]);
      });
    }
  }, {
    key: "normalizeZ",
    value: function normalizeZ(points) {
      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
  }]);
  return JacobianPoint;
}();
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
  var neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes = new WeakMap();
var Point = /*#__PURE__*/function () {
  function Point(x, y) {
    _classCallCheck(this, Point);
    this.x = x;
    this.y = y;
  }
  _createClass(Point, [{
    key: "_setWindowSize",
    value: function _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes["delete"](this);
    }
  }, {
    key: "hasEvenY",
    value: function hasEvenY() {
      return this.y % _2n === _0n;
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return hexToBytes(this.toHex(isCompressed));
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var x = numTo32bStr(this.x);
      if (isCompressed) {
        var prefix = this.hasEvenY() ? '02' : '03';
        return "".concat(prefix).concat(x);
      } else {
        return "04".concat(x).concat(numTo32bStr(this.y));
      }
    }
  }, {
    key: "toHexX",
    value: function toHexX() {
      return this.toHex(true).slice(2);
    }
  }, {
    key: "toRawX",
    value: function toRawX() {
      return this.toRawBytes(true).slice(1);
    }
  }, {
    key: "assertValidity",
    value: function assertValidity() {
      var msg = 'Point is not on elliptic curve';
      var x = this.x,
        y = this.y;
      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
      var left = mod(y * y);
      var right = weierstrass(x);
      if (mod(left - right) !== _0n) throw new Error(msg);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this.x === other.x && this.y === other.y;
    }
  }, {
    key: "negate",
    value: function negate() {
      return new Point(this.x, mod(-this.y));
    }
  }, {
    key: "double",
    value: function double() {
      return JacobianPoint.fromAffine(this)["double"]().toAffine();
    }
  }, {
    key: "add",
    value: function add(other) {
      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
  }, {
    key: "subtract",
    value: function subtract(other) {
      return this.add(other.negate());
    }
  }, {
    key: "multiply",
    value: function multiply(scalar) {
      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
  }, {
    key: "multiplyAndAddUnsafe",
    value: function multiplyAndAddUnsafe(Q, a, b) {
      var P = JacobianPoint.fromAffine(this);
      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
      var sum = aP.add(bQ);
      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
  }], [{
    key: "fromCompressedHex",
    value: function fromCompressedHex(bytes) {
      var isShort = bytes.length === 32;
      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
      var y2 = weierstrass(x);
      var y = sqrtMod(y2);
      var isYOdd = (y & _1n) === _1n;
      if (isShort) {
        if (isYOdd) y = mod(-y);
      } else {
        var isFirstByteOdd = (bytes[0] & 1) === 1;
        if (isFirstByteOdd !== isYOdd) y = mod(-y);
      }
      var point = new Point(x, y);
      point.assertValidity();
      return point;
    }
  }, {
    key: "fromUncompressedHex",
    value: function fromUncompressedHex(bytes) {
      var x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
      var y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
      var point = new Point(x, y);
      point.assertValidity();
      return point;
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var bytes = ensureBytes(hex);
      var len = bytes.length;
      var header = bytes[0];
      if (len === fieldLen) return this.fromCompressedHex(bytes);
      if (len === compressedLen && (header === 0x02 || header === 0x03)) {
        return this.fromCompressedHex(bytes);
      }
      if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);
      throw new Error("Point.fromHex: received invalid point. Expected 32-".concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes, not ").concat(len));
    }
  }, {
    key: "fromPrivateKey",
    value: function fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
  }, {
    key: "fromSignature",
    value: function fromSignature(msgHash, signature, recovery) {
      var _normalizeSignature = normalizeSignature(signature),
        r = _normalizeSignature.r,
        s = _normalizeSignature.s;
      if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');
      var h = truncateHash(ensureBytes(msgHash));
      var n = CURVE.n;
      var radj = recovery === 2 || recovery === 3 ? r + n : r;
      var rinv = invert(radj, n);
      var u1 = mod(-h * rinv, n);
      var u2 = mod(s * rinv, n);
      var prefix = recovery & 1 ? '03' : '02';
      var R = Point.fromHex(prefix + numTo32bStr(radj));
      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q) throw new Error('Cannot recover signature: point at infinify');
      Q.assertValidity();
      return Q;
    }
  }]);
  return Point;
}();
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 0x02) {
    throw new Error("Invalid signature integer tag: ".concat(bytesToHex(data)));
  }
  var len = data[1];
  var res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error("Invalid signature integer: wrong length");
  }
  if (res[0] === 0x00 && res[1] <= 0x7f) {
    throw new Error('Invalid signature integer: trailing length');
  }
  return {
    data: bytesToNumber(res),
    left: data.subarray(len + 2)
  };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 0x30) {
    throw new Error("Invalid signature tag: ".concat(bytesToHex(data)));
  }
  if (data[1] !== data.length - 2) {
    throw new Error('Invalid signature: incorrect length');
  }
  var _parseDERInt = parseDERInt(data.subarray(2)),
    r = _parseDERInt.data,
    sBytes = _parseDERInt.left;
  var _parseDERInt2 = parseDERInt(sBytes),
    s = _parseDERInt2.data,
    rBytesLeft = _parseDERInt2.left;
  if (rBytesLeft.length) {
    throw new Error("Invalid signature: left bytes after parsing: ".concat(bytesToHex(rBytesLeft)));
  }
  return {
    r: r,
    s: s
  };
}
var Signature$1 = /*#__PURE__*/function () {
  function Signature$1(r, s) {
    _classCallCheck(this, Signature$1);
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  _createClass(Signature$1, [{
    key: "assertValidity",
    value: function assertValidity() {
      var r = this.r,
        s = this.s;
      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');
      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');
    }
  }, {
    key: "hasHighS",
    value: function hasHighS() {
      var HALF = CURVE.n >> _1n;
      return this.s > HALF;
    }
  }, {
    key: "normalizeS",
    value: function normalizeS() {
      return this.hasHighS() ? new Signature$1(this.r, mod(-this.s, CURVE.n)) : this;
    }
  }, {
    key: "toDERRawBytes",
    value: function toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
  }, {
    key: "toDERHex",
    value: function toDERHex() {
      var sHex = sliceDER(numberToHexUnpadded(this.s));
      var rHex = sliceDER(numberToHexUnpadded(this.r));
      var sHexL = sHex.length / 2;
      var rHexL = rHex.length / 2;
      var sLen = numberToHexUnpadded(sHexL);
      var rLen = numberToHexUnpadded(rHexL);
      var length = numberToHexUnpadded(rHexL + sHexL + 4);
      return "30".concat(length, "02").concat(rLen).concat(rHex, "02").concat(sLen).concat(sHex);
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      return this.toDERRawBytes();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return this.toDERHex();
    }
  }, {
    key: "toCompactRawBytes",
    value: function toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
  }, {
    key: "toCompactHex",
    value: function toCompactHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  }], [{
    key: "fromCompact",
    value: function fromCompact(hex) {
      var arr = hex instanceof Uint8Array;
      var name = 'Signature.fromCompact';
      if (typeof hex !== 'string' && !arr) throw new TypeError("".concat(name, ": Expected string or Uint8Array"));
      var str = arr ? bytesToHex(hex) : hex;
      if (str.length !== 128) throw new Error("".concat(name, ": Expected 64-byte hex"));
      return new Signature$1(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
  }, {
    key: "fromDER",
    value: function fromDER(hex) {
      var arr = hex instanceof Uint8Array;
      if (typeof hex !== 'string' && !arr) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),
        r = _parseDERSignature.r,
        s = _parseDERSignature.s;
      return new Signature$1(r, s);
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return this.fromDER(hex);
    }
  }]);
  return Signature$1;
}();
function concatBytes() {
  for (var _len5 = arguments.length, arrays = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
    arrays[_key6] = arguments[_key6];
  }
  if (!arrays.every(function (b) {
    return b instanceof Uint8Array;
  })) throw new Error('Uint8Array list expected');
  if (arrays.length === 1) return arrays[0];
  var length = arrays.reduce(function (a, arr) {
    return a + arr.length;
  }, 0);
  var result = new Uint8Array(length);
  for (var _i17 = 0, pad = 0; _i17 < arrays.length; _i17++) {
    var arr = arrays[_i17];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({
  length: 256
}, function (v, i) {
  return i.toString(16).padStart(2, '0');
});
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');
  var hex = '';
  for (var _i18 = 0; _i18 < uint8a.length; _i18++) {
    hex += hexes[uint8a[_i18]];
  }
  return hex;
}
var POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function numTo32bStr(num) {
  if (typeof num !== 'bigint') throw new Error('Expected bigint');
  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');
  return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
  var b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32) throw new Error('Error: expected 32 bytes');
  return b;
}
function numberToHexUnpadded(num) {
  var hex = num.toString(16);
  return hex.length & 1 ? "0".concat(hex) : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToNumber: expected string, got ' + _typeof(hex));
  }
  return BigInt("0x".concat(hex));
}
function hexToBytes(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToBytes: expected string, got ' + _typeof(hex));
  }
  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
  var array = new Uint8Array(hex.length / 2);
  for (var _i19 = 0; _i19 < array.length; _i19++) {
    var _j3 = _i19 * 2;
    var hexByte = hex.slice(_j3, _j3 + 2);
    var _byte2 = Number.parseInt(hexByte, 16);
    if (Number.isNaN(_byte2) || _byte2 < 0) throw new Error('Invalid byte sequence');
    array[_i19] = _byte2;
  }
  return array;
}
function bytesToNumber(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);
  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;
  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a) {
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  var result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  var P = CURVE.P;
  var res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  var P = CURVE.P;
  var _6n = BigInt(6);
  var _11n = BigInt(11);
  var _22n = BigInt(22);
  var _23n = BigInt(23);
  var _44n = BigInt(44);
  var _88n = BigInt(88);
  var b2 = x * x * x % P;
  var b3 = b2 * b2 * x % P;
  var b6 = pow2(b3, _3n) * b3 % P;
  var b9 = pow2(b6, _3n) * b3 % P;
  var b11 = pow2(b9, _2n) * b2 % P;
  var b22 = pow2(b11, _11n) * b11 % P;
  var b44 = pow2(b22, _22n) * b22 % P;
  var b88 = pow2(b44, _44n) * b44 % P;
  var b176 = pow2(b88, _88n) * b88 % P;
  var b220 = pow2(b176, _44n) * b44 % P;
  var b223 = pow2(b220, _3n) * b3 % P;
  var t1 = pow2(b223, _23n) * b22 % P;
  var t2 = pow2(t1, _6n) * b2 % P;
  var rt = pow2(t2, _2n);
  var xc = rt * rt % P;
  if (xc !== x) throw new Error('Cannot find square root');
  return rt;
}
function invert(number) {
  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  if (number === _0n || modulo <= _0n) {
    throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
  }
  var a = mod(number, modulo);
  var b = modulo;
  var x = _0n,
    y = _1n,
    u = _1n,
    v = _0n;
  while (a !== _0n) {
    var q = b / a;
    var _r2 = b % a;
    var m = x - u * q;
    var _n2 = y - v * q;
    b = a, a = _r2, x = u, y = v, u = m, v = _n2;
  }
  var gcd = b;
  if (gcd !== _1n) throw new Error('invert: does not exist');
  return mod(x, modulo);
}
function invertBatch(nums) {
  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  var scratch = new Array(nums.length);
  var lastMultiplied = nums.reduce(function (acc, num, i) {
    if (num === _0n) return acc;
    scratch[i] = acc;
    return mod(acc * num, p);
  }, _1n);
  var inverted = invert(lastMultiplied, p);
  nums.reduceRight(function (acc, num, i) {
    if (num === _0n) return acc;
    scratch[i] = mod(acc * scratch[i], p);
    return mod(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes) {
  var delta = bytes.length * 8 - groupLen * 8;
  var num = bytesToNumber(bytes);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash) {
  var truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var h = bits2int_2(hash);
  if (truncateOnly) return h;
  var n = CURVE.n;
  return h >= n ? h - n : h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = /*#__PURE__*/function () {
  function HmacDrbg(hashLen, qByteLen) {
    _classCallCheck(this, HmacDrbg);
    this.hashLen = hashLen;
    this.qByteLen = qByteLen;
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    this.v = new Uint8Array(hashLen).fill(1);
    this.k = new Uint8Array(hashLen).fill(0);
    this.counter = 0;
  }
  _createClass(HmacDrbg, [{
    key: "hmac",
    value: function hmac() {
      for (var _len6 = arguments.length, values = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
        values[_key7] = arguments[_key7];
      }
      return utils.hmacSha256.apply(utils, [this.k].concat(values));
    }
  }, {
    key: "hmacSync",
    value: function hmacSync() {
      for (var _len7 = arguments.length, values = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
        values[_key8] = arguments[_key8];
      }
      return _hmacSha256Sync.apply(void 0, [this.k].concat(values));
    }
  }, {
    key: "checkSync",
    value: function checkSync() {
      if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');
    }
  }, {
    key: "incr",
    value: function incr() {
      if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');
      this.counter += 1;
    }
  }, {
    key: "reseed",
    value: function () {
      var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var seed,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              seed = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : new Uint8Array();
              _context5.next = 3;
              return this.hmac(this.v, Uint8Array.from([0x00]), seed);
            case 3:
              this.k = _context5.sent;
              _context5.next = 6;
              return this.hmac(this.v);
            case 6:
              this.v = _context5.sent;
              if (!(seed.length === 0)) {
                _context5.next = 9;
                break;
              }
              return _context5.abrupt("return");
            case 9:
              _context5.next = 11;
              return this.hmac(this.v, Uint8Array.from([0x01]), seed);
            case 11:
              this.k = _context5.sent;
              _context5.next = 14;
              return this.hmac(this.v);
            case 14:
              this.v = _context5.sent;
            case 15:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function reseed() {
        return _reseed.apply(this, arguments);
      }
      return reseed;
    }()
  }, {
    key: "reseedSync",
    value: function reseedSync() {
      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();
      this.checkSync();
      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
      this.v = this.hmacSync(this.v);
      if (seed.length === 0) return;
      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
      this.v = this.hmacSync(this.v);
    }
  }, {
    key: "generate",
    value: function () {
      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var len, out, sl;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this.incr();
              len = 0;
              out = [];
            case 3:
              if (!(len < this.qByteLen)) {
                _context6.next = 12;
                break;
              }
              _context6.next = 6;
              return this.hmac(this.v);
            case 6:
              this.v = _context6.sent;
              sl = this.v.slice();
              out.push(sl);
              len += this.v.length;
              _context6.next = 3;
              break;
            case 12:
              return _context6.abrupt("return", concatBytes.apply(void 0, out));
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function generate() {
        return _generate.apply(this, arguments);
      }
      return generate;
    }()
  }, {
    key: "generateSync",
    value: function generateSync() {
      this.checkSync();
      this.incr();
      var len = 0;
      var out = [];
      while (len < this.qByteLen) {
        this.v = this.hmacSync(this.v);
        var sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes.apply(void 0, out);
    }
  }]);
  return HmacDrbg;
}();
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
  var lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var n = CURVE.n;
  var k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k)) return;
  var kinv = invert(k, n);
  var q = Point.BASE.multiply(k);
  var r = mod(q.x, n);
  if (r === _0n) return;
  var s = mod(kinv * mod(m + d * r, n), n);
  if (s === _0n) return;
  var sig = new Signature$1(r, s);
  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return {
    sig: sig,
    recovery: recovery
  };
}
function normalizePrivateKey(key) {
  var num;
  if (typeof key === 'bigint') {
    num = key;
  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === 'string') {
    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');
    num = bytesToNumber(key);
  } else {
    throw new TypeError('Expected valid private key');
  }
  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature$1) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature$1.fromDER(signature);
  } catch (error) {
    return Signature$1.fromCompact(signature);
  }
}
function getPublicKey(privateKey) {
  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function _recoverPublicKey(msgHash, signature, recovery) {
  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
function isProbPub(item) {
  var arr = item instanceof Uint8Array;
  var str = typeof item === 'string';
  var len = (arr || str) && item.length;
  if (arr) return len === compressedLen || len === uncompressedLen;
  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;
  if (item instanceof Point) return true;
  return false;
}
function getSharedSecret(privateA, publicB) {
  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');
  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');
  var b = normalizePublicKey(publicB);
  b.assertValidity();
  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
function bits2int(bytes) {
  var slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
  return bytesToNumber(slice);
}
function bits2octets(bytes) {
  var z1 = bits2int(bytes);
  var z2 = mod(z1, CURVE.n);
  return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null) throw new Error("sign: expected valid message hash, not \"".concat(msgHash, "\""));
  var h1 = ensureBytes(msgHash);
  var d = normalizePrivateKey(privateKey);
  var seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);
    var e = ensureBytes(extraEntropy);
    if (e.length !== fieldLen) throw new Error("sign: Expected ".concat(fieldLen, " bytes of extra data"));
    seedArgs.push(e);
  }
  var seed = concatBytes.apply(void 0, seedArgs);
  var m = bits2int(h1);
  return {
    seed: seed,
    m: m,
    d: d
  };
}
function finalizeSig(recSig, opts) {
  var sig = recSig.sig,
    recovery = recSig.recovery;
  var _Object$assign = Object.assign({
      canonical: true,
      der: true
    }, opts),
    der = _Object$assign.der,
    recovered = _Object$assign.recovered;
  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function sign(_x36, _x37) {
  return _sign.apply(this, arguments);
}
function _sign() {
  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee202(msgHash, privKey) {
    var opts,
      _initSigArgs2,
      seed,
      m,
      d,
      drbg,
      sig,
      _args201 = arguments;
    return _regeneratorRuntime().wrap(function _callee202$(_context204) {
      while (1) switch (_context204.prev = _context204.next) {
        case 0:
          opts = _args201.length > 2 && _args201[2] !== undefined ? _args201[2] : {};
          _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;
          drbg = new HmacDrbg(hashLen, groupLen);
          _context204.next = 5;
          return drbg.reseed(seed);
        case 5:
          _context204.t0 = kmdToSig;
          _context204.next = 8;
          return drbg.generate();
        case 8:
          _context204.t1 = _context204.sent;
          _context204.t2 = m;
          _context204.t3 = d;
          _context204.t4 = opts.canonical;
          if (sig = (0, _context204.t0)(_context204.t1, _context204.t2, _context204.t3, _context204.t4)) {
            _context204.next = 17;
            break;
          }
          _context204.next = 15;
          return drbg.reseed();
        case 15:
          _context204.next = 5;
          break;
        case 17:
          return _context204.abrupt("return", finalizeSig(sig, opts));
        case 18:
        case "end":
          return _context204.stop();
      }
    }, _callee202);
  }));
  return _sign.apply(this, arguments);
}
function signSync(msgHash, privKey) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),
    seed = _initSigArgs.seed,
    m = _initSigArgs.m,
    d = _initSigArgs.d;
  var drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed);
  var sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();
  return finalizeSig(sig, opts);
}
var vopts = {
  strict: true
};
function verify(signature, msgHash, publicKey) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;
  var sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes(msgHash);
  } catch (error) {
    return false;
  }
  var _sig = sig,
    r = _sig.r,
    s = _sig.s;
  if (opts.strict && sig.hasHighS()) return false;
  var h = truncateHash(msgHash);
  var P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  var n = CURVE.n;
  var sinv = invert(s, n);
  var u1 = mod(h * sinv, n);
  var u2 = mod(r * sinv, n);
  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R) return false;
  var v = mod(R.x, n);
  return v === r;
}
function schnorrChallengeFinalize(ch) {
  return mod(bytesToNumber(ch), CURVE.n);
}
var SchnorrSignature = /*#__PURE__*/function () {
  function SchnorrSignature(r, s) {
    _classCallCheck(this, SchnorrSignature);
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  _createClass(SchnorrSignature, [{
    key: "assertValidity",
    value: function assertValidity() {
      var r = this.r,
        s = this.s;
      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      return hexToBytes(this.toHex());
    }
  }], [{
    key: "fromHex",
    value: function fromHex(hex) {
      var bytes = ensureBytes(hex);
      if (bytes.length !== 64) throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not ".concat(bytes.length));
      var r = bytesToNumber(bytes.subarray(0, 32));
      var s = bytesToNumber(bytes.subarray(32, 64));
      return new SchnorrSignature(r, s);
    }
  }]);
  return SchnorrSignature;
}();
function schnorrGetPublicKey(privateKey) {
  return Point.fromPrivateKey(privateKey).toRawX();
}
var InternalSchnorrSignature = /*#__PURE__*/function () {
  function InternalSchnorrSignature(message, privateKey) {
    var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();
    _classCallCheck(this, InternalSchnorrSignature);
    if (message == null) throw new TypeError("sign: Expected valid message, not \"".concat(message, "\""));
    this.m = ensureBytes(message);
    var _this$getScalar = this.getScalar(normalizePrivateKey(privateKey)),
      x = _this$getScalar.x,
      scalar = _this$getScalar.scalar;
    this.px = x;
    this.d = scalar;
    this.rand = ensureBytes(auxRand);
    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');
  }
  _createClass(InternalSchnorrSignature, [{
    key: "getScalar",
    value: function getScalar(priv) {
      var point = Point.fromPrivateKey(priv);
      var scalar = point.hasEvenY() ? priv : CURVE.n - priv;
      return {
        point: point,
        scalar: scalar,
        x: point.toRawX()
      };
    }
  }, {
    key: "initNonce",
    value: function initNonce(d, t0h) {
      return numTo32b(d ^ bytesToNumber(t0h));
    }
  }, {
    key: "finalizeNonce",
    value: function finalizeNonce(k0h) {
      var k0 = mod(bytesToNumber(k0h), CURVE.n);
      if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');
      var _this$getScalar2 = this.getScalar(k0),
        R = _this$getScalar2.point,
        rx = _this$getScalar2.x,
        k = _this$getScalar2.scalar;
      return {
        R: R,
        rx: rx,
        k: k
      };
    }
  }, {
    key: "finalizeSig",
    value: function finalizeSig(R, k, e, d) {
      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
  }, {
    key: "error",
    value: function error() {
      throw new Error('sign: Invalid signature produced');
    }
  }, {
    key: "calc",
    value: function () {
      var _calc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var m, d, px, rand, tag, t, _this$finalizeNonce, R, rx, k, e, sig;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              m = this.m, d = this.d, px = this.px, rand = this.rand;
              tag = utils.taggedHash;
              _context7.t0 = this;
              _context7.t1 = d;
              _context7.next = 6;
              return tag(TAGS.aux, rand);
            case 6:
              _context7.t2 = _context7.sent;
              t = _context7.t0.initNonce.call(_context7.t0, _context7.t1, _context7.t2);
              _context7.t3 = this;
              _context7.next = 11;
              return tag(TAGS.nonce, t, px, m);
            case 11:
              _context7.t4 = _context7.sent;
              _this$finalizeNonce = _context7.t3.finalizeNonce.call(_context7.t3, _context7.t4);
              R = _this$finalizeNonce.R;
              rx = _this$finalizeNonce.rx;
              k = _this$finalizeNonce.k;
              _context7.t5 = schnorrChallengeFinalize;
              _context7.next = 19;
              return tag(TAGS.challenge, rx, px, m);
            case 19:
              _context7.t6 = _context7.sent;
              e = (0, _context7.t5)(_context7.t6);
              sig = this.finalizeSig(R, k, e, d);
              _context7.next = 24;
              return schnorrVerify(sig, m, px);
            case 24:
              if (_context7.sent) {
                _context7.next = 26;
                break;
              }
              this.error();
            case 26:
              return _context7.abrupt("return", sig);
            case 27:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function calc() {
        return _calc.apply(this, arguments);
      }
      return calc;
    }()
  }, {
    key: "calcSync",
    value: function calcSync() {
      var m = this.m,
        d = this.d,
        px = this.px,
        rand = this.rand;
      var tag = utils.taggedHashSync;
      var t = this.initNonce(d, tag(TAGS.aux, rand));
      var _this$finalizeNonce2 = this.finalizeNonce(tag(TAGS.nonce, t, px, m)),
        R = _this$finalizeNonce2.R,
        rx = _this$finalizeNonce2.rx,
        k = _this$finalizeNonce2.k;
      var e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
      var sig = this.finalizeSig(R, k, e, d);
      if (!schnorrVerifySync(sig, m, px)) this.error();
      return sig;
    }
  }]);
  return InternalSchnorrSignature;
}();
function schnorrSign(_x38, _x39, _x40) {
  return _schnorrSign.apply(this, arguments);
}
function _schnorrSign() {
  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee203(msg, privKey, auxRand) {
    return _regeneratorRuntime().wrap(function _callee203$(_context205) {
      while (1) switch (_context205.prev = _context205.next) {
        case 0:
          return _context205.abrupt("return", new InternalSchnorrSignature(msg, privKey, auxRand).calc());
        case 1:
        case "end":
          return _context205.stop();
      }
    }, _callee203);
  }));
  return _schnorrSign.apply(this, arguments);
}
function schnorrSignSync(msg, privKey, auxRand) {
  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
}
function initSchnorrVerify(signature, message, publicKey) {
  var raw = signature instanceof SchnorrSignature;
  var sig = raw ? signature : SchnorrSignature.fromHex(signature);
  if (raw) sig.assertValidity();
  return _objectSpread(_objectSpread({}, sig), {}, {
    m: ensureBytes(message),
    P: normalizePublicKey(publicKey)
  });
}
function finalizeSchnorrVerify(r, P, s, e) {
  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
  if (!R || !R.hasEvenY() || R.x !== r) return false;
  return true;
}
function schnorrVerify(_x41, _x42, _x43) {
  return _schnorrVerify.apply(this, arguments);
}
function _schnorrVerify() {
  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee204(signature, message, publicKey) {
    var _initSchnorrVerify2, _r15, s, m, P, e;
    return _regeneratorRuntime().wrap(function _callee204$(_context206) {
      while (1) switch (_context206.prev = _context206.next) {
        case 0:
          _context206.prev = 0;
          _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), _r15 = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;
          _context206.t0 = schnorrChallengeFinalize;
          _context206.next = 5;
          return utils.taggedHash(TAGS.challenge, numTo32b(_r15), P.toRawX(), m);
        case 5:
          _context206.t1 = _context206.sent;
          e = (0, _context206.t0)(_context206.t1);
          return _context206.abrupt("return", finalizeSchnorrVerify(_r15, P, s, e));
        case 10:
          _context206.prev = 10;
          _context206.t2 = _context206["catch"](0);
          return _context206.abrupt("return", false);
        case 13:
        case "end":
          return _context206.stop();
      }
    }, _callee204, null, [[0, 10]]);
  }));
  return _schnorrVerify.apply(this, arguments);
}
function schnorrVerifySync(signature, message, publicKey) {
  try {
    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),
      _r3 = _initSchnorrVerify.r,
      s = _initSchnorrVerify.s,
      m = _initSchnorrVerify.m,
      P = _initSchnorrVerify.P;
    var e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(_r3), P.toRawX(), m));
    return finalizeSchnorrVerify(_r3, P, s, e);
  } catch (error) {
    if (error instanceof ShaError) throw error;
    return false;
  }
}
var schnorr = {
  Signature: SchnorrSignature,
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  signSync: schnorrSignSync,
  verifySync: schnorrVerifySync
};
Point.BASE._setWindowSize(8);
var crypto = {
  node: nodeCrypto,
  web: (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && 'crypto' in self ? self.crypto : undefined
};
var TAGS = {
  challenge: 'BIP0340/challenge',
  aux: 'BIP0340/aux',
  nonce: 'BIP0340/nonce'
};
var TAGGED_HASH_PREFIXES = {};
var utils = {
  bytesToHex: bytesToHex,
  hexToBytes: hexToBytes,
  concatBytes: concatBytes,
  mod: mod,
  invert: invert,
  isValidPrivateKey: function isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: function hashToPrivateKey(hash) {
    hash = ensureBytes(hash);
    var minLen = groupLen + 8;
    if (hash.length < minLen || hash.length > 1024) {
      throw new Error("Expected valid bytes of private key as per FIPS 186");
    }
    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
    return numTo32b(num);
  },
  randomBytes: function randomBytes() {
    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
    if (crypto.web) {
      return crypto.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto.node) {
      var _randomBytes2 = crypto.node.randomBytes;
      return Uint8Array.from(_randomBytes2(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: function randomPrivateKey() {
    return utils.hashToPrivateKey(utils.randomBytes(groupLen + 8));
  },
  precompute: function precompute() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
    var cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: function () {
    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var _len8,
        messages,
        _key9,
        buffer,
        _createHash,
        _hash,
        _args5 = arguments;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            for (_len8 = _args5.length, messages = new Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
              messages[_key9] = _args5[_key9];
            }
            if (!crypto.web) {
              _context8.next = 8;
              break;
            }
            _context8.next = 4;
            return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));
          case 4:
            buffer = _context8.sent;
            return _context8.abrupt("return", new Uint8Array(buffer));
          case 8:
            if (!crypto.node) {
              _context8.next = 15;
              break;
            }
            _createHash = crypto.node.createHash;
            _hash = _createHash('sha256');
            messages.forEach(function (m) {
              return _hash.update(m);
            });
            return _context8.abrupt("return", Uint8Array.from(_hash.digest()));
          case 15:
            throw new Error("The environment doesn't have sha256 function");
          case 16:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function sha256() {
      return _sha.apply(this, arguments);
    }
    return sha256;
  }(),
  hmacSha256: function () {
    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(key) {
      var _len9,
        messages,
        _key10,
        ckey,
        message,
        buffer,
        _createHmac,
        _hash2,
        _args6 = arguments;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            for (_len9 = _args6.length, messages = new Array(_len9 > 1 ? _len9 - 1 : 0), _key10 = 1; _key10 < _len9; _key10++) {
              messages[_key10 - 1] = _args6[_key10];
            }
            if (!crypto.web) {
              _context9.next = 12;
              break;
            }
            _context9.next = 4;
            return crypto.web.subtle.importKey('raw', key, {
              name: 'HMAC',
              hash: {
                name: 'SHA-256'
              }
            }, false, ['sign']);
          case 4:
            ckey = _context9.sent;
            message = concatBytes.apply(void 0, messages);
            _context9.next = 8;
            return crypto.web.subtle.sign('HMAC', ckey, message);
          case 8:
            buffer = _context9.sent;
            return _context9.abrupt("return", new Uint8Array(buffer));
          case 12:
            if (!crypto.node) {
              _context9.next = 19;
              break;
            }
            _createHmac = crypto.node.createHmac;
            _hash2 = _createHmac('sha256', key);
            messages.forEach(function (m) {
              return _hash2.update(m);
            });
            return _context9.abrupt("return", Uint8Array.from(_hash2.digest()));
          case 19:
            throw new Error("The environment doesn't have hmac-sha256 function");
          case 20:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    function hmacSha256(_x44) {
      return _hmacSha.apply(this, arguments);
    }
    return hmacSha256;
  }(),
  sha256Sync: undefined,
  hmacSha256Sync: undefined,
  taggedHash: function () {
    var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(tag) {
      var tagP,
        tagH,
        _len10,
        messages,
        _key11,
        _args7 = arguments;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            tagP = TAGGED_HASH_PREFIXES[tag];
            if (!(tagP === undefined)) {
              _context10.next = 7;
              break;
            }
            _context10.next = 4;
            return utils.sha256(Uint8Array.from(tag, function (c) {
              return c.charCodeAt(0);
            }));
          case 4:
            tagH = _context10.sent;
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
          case 7:
            for (_len10 = _args7.length, messages = new Array(_len10 > 1 ? _len10 - 1 : 0), _key11 = 1; _key11 < _len10; _key11++) {
              messages[_key11 - 1] = _args7[_key11];
            }
            return _context10.abrupt("return", utils.sha256.apply(utils, [tagP].concat(messages)));
          case 9:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function taggedHash(_x45) {
      return _taggedHash.apply(this, arguments);
    }
    return taggedHash;
  }(),
  taggedHashSync: function taggedHashSync(tag) {
    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');
    var tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {
        return c.charCodeAt(0);
      }));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    for (var _len11 = arguments.length, messages = new Array(_len11 > 1 ? _len11 - 1 : 0), _key12 = 1; _key12 < _len11; _key12++) {
      messages[_key12 - 1] = arguments[_key12];
    }
    return _sha256Sync.apply(void 0, [tagP].concat(messages));
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get: function get() {
      return _sha256Sync;
    },
    set: function set(val) {
      if (!_sha256Sync) _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get: function get() {
      return _hmacSha256Sync;
    },
    set: function set(val) {
      if (!_hmacSha256Sync) _hmacSha256Sync = val;
    }
  }
});

/**
 *  A constant for the zero address.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
 */
var ZeroAddress = "0x0000000000000000000000000000000000000000";

/**
 *  A constant for the zero hash.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
 */
exports.ZeroAddress = ZeroAddress;
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

/**
 *  A constant for the order N for the secp256k1 curve.
 *
 *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
 */
exports.ZeroHash = ZeroHash;
var N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
/**
 *  A constant for the number of wei in a single ether.
 *
 *  (**i.e.** ``1000000000000000000n``)
 */
exports.N = N$1;
var WeiPerEther = BigInt("1000000000000000000");
/**
 *  A constant for the maximum value for a ``uint256``.
 *
 *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.WeiPerEther = WeiPerEther;
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  A constant for the minimum value for an ``int256``.
 *
 *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
 */
exports.MaxUint256 = MaxUint256;
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
/**
 *  A constant for the maximum value for an ``int256``.
 *
 *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.MinInt256 = MinInt256;
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// NFKC (composed)             // (decomposed)
/**
 *  A constant for the ether symbol (normalized using NFKC).
 *
 *  (**i.e.** ``"\\u039e"``)
 */
exports.MaxInt256 = MaxInt256;
var EtherSymbol = "\u039E"; // "\uD835\uDF63";
/**
 *  A constant for the [[link-eip-191]] personal message prefix.
 *
 *  (**i.e.** ``"\\x19Ethereum Signed Message:\\n"``)
 */
exports.EtherSymbol = EtherSymbol;
var MessagePrefix = "\x19Ethereum Signed Message:\n";

/**
 *  Some common constants useful for Ethereum.
 *
 *  @_section: api/constants: Constants  [about-constants]
 */

// Constants
exports.MessagePrefix = MessagePrefix;
var BN_0$7 = BigInt(0);
var BN_1$3 = BigInt(1);
var BN_2$3 = BigInt(2);
var BN_27$1 = BigInt(27);
var BN_28$1 = BigInt(28);
var BN_35$1 = BigInt(35);
var _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
/**
 *  A Signature  @TODO
 *
 *
 *  @_docloc: api/crypto:Signing
 */
var _r4 = /*#__PURE__*/new WeakMap();
var _s2 = /*#__PURE__*/new WeakMap();
var _v2 = /*#__PURE__*/new WeakMap();
var _networkV = /*#__PURE__*/new WeakMap();
_Symbol$for = Symbol["for"]('nodejs.util.inspect.custom');
var Signature = /*#__PURE__*/function () {
  /**
   *  @private
   */
  function Signature(guard, r, s, v) {
    _classCallCheck(this, Signature);
    _classPrivateFieldInitSpec(this, _r4, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _s2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _v2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _networkV, {
      writable: true,
      value: void 0
    });
    assertPrivate(guard, _guard$3, "Signature");
    _classPrivateFieldSet(this, _r4, r);
    _classPrivateFieldSet(this, _s2, s);
    _classPrivateFieldSet(this, _v2, v);
    _classPrivateFieldSet(this, _networkV, null);
  }
  _createClass(Signature, [{
    key: "r",
    get:
    /**
     *  The ``r`` value for a signautre.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    function get() {
      return _classPrivateFieldGet(this, _r4);
    },
    set: function set(value) {
      assertArgument(dataLength(value) === 32, "invalid r", "value", value);
      _classPrivateFieldSet(this, _r4, hexlify(value));
    }
    /**
     *  The ``s`` value for a signature.
     */
  }, {
    key: "s",
    get: function get() {
      return _classPrivateFieldGet(this, _s2);
    },
    set: function set(_value) {
      assertArgument(dataLength(_value) === 32, "invalid r", "value", _value);
      var value = hexlify(_value);
      assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
      _classPrivateFieldSet(this, _s2, value);
    }
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
  }, {
    key: "v",
    get: function get() {
      return _classPrivateFieldGet(this, _v2);
    },
    set: function set(value) {
      var v = getNumber(value, "value");
      assertArgument(v === 27 || v === 28, "invalid v", "v", value);
      _classPrivateFieldSet(this, _v2, v);
    }
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
  }, {
    key: "networkV",
    get: function get() {
      return _classPrivateFieldGet(this, _networkV);
    }
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
  }, {
    key: "legacyChainId",
    get: function get() {
      var v = this.networkV;
      if (v == null) {
        return null;
      }
      return Signature.getChainId(v);
    }
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
  }, {
    key: "yParity",
    get: function get() {
      return this.v === 27 ? 0 : 1;
    }
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
  }, {
    key: "yParityAndS",
    get: function get() {
      // The EIP-2098 compact representation
      var yParityAndS = getBytes(this.s);
      if (this.yParity) {
        yParityAndS[0] |= 0x80;
      }
      return hexlify(yParityAndS);
    }
    /**
     *  The [[link-eip-2098]] compact representation.
     */
  }, {
    key: "compactSerialized",
    get: function get() {
      return concat([this.r, this.yParityAndS]);
    }
    /**
     *  The serialized representation.
     */
  }, {
    key: "serialized",
    get: function get() {
      return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
    }
  }, {
    key: _Symbol$for,
    value: function value() {
      return "Signature { r: \"".concat(this.r, "\", s: \"").concat(this.s, "\", yParity: ").concat(this.yParity, ", networkV: ").concat(this.networkV, " }");
    }
    /**
     *  Returns a new identical [[Signature]].
     */
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Signature(_guard$3, this.r, this.s, this.v);
      if (this.networkV) {
        _classPrivateFieldSet(clone, _networkV, this.networkV);
      }
      return clone;
    }
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var networkV = this.networkV;
      return {
        _type: "signature",
        networkV: networkV != null ? networkV.toString() : null,
        r: this.r,
        s: this.s,
        v: this.v
      };
    }
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
  }], [{
    key: "getChainId",
    value: function getChainId(v) {
      var bv = getBigInt(v, "v");
      // The v is not an EIP-155 v, so it is the unspecified chain ID
      if (bv == BN_27$1 || bv == BN_28$1) {
        return BN_0$7;
      }
      // Bad value for an EIP-155 v
      assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
      return (bv - BN_35$1) / BN_2$3;
    }
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
  }, {
    key: "getChainIdV",
    value: function getChainIdV(chainId, v) {
      return getBigInt(chainId) * BN_2$3 + BigInt(35 + v - 27);
    }
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
  }, {
    key: "getNormalizedV",
    value: function getNormalizedV(v) {
      var bv = getBigInt(v);
      if (bv === BN_0$7 || bv === BN_27$1) {
        return 27;
      }
      if (bv === BN_1$3 || bv === BN_28$1) {
        return 28;
      }
      assertArgument(bv >= BN_35$1, "invalid v", "v", v);
      // Otherwise, EIP-155 v means odd is 27 and even is 28
      return bv & BN_1$3 ? 27 : 28;
    }
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
  }, {
    key: "from",
    value: function from(sig) {
      function assertError(check, message) {
        assertArgument(check, message, "signature", sig);
      }
      ;
      if (sig == null) {
        return new Signature(_guard$3, ZeroHash, ZeroHash, 27);
      }
      if (typeof sig === "string") {
        var _bytes2 = getBytes(sig, "signature");
        if (_bytes2.length === 64) {
          var _r5 = hexlify(_bytes2.slice(0, 32));
          var _s3 = _bytes2.slice(32, 64);
          var _v3 = _s3[0] & 0x80 ? 28 : 27;
          _s3[0] &= 0x7f;
          return new Signature(_guard$3, _r5, hexlify(_s3), _v3);
        }
        if (_bytes2.length === 65) {
          var _r6 = hexlify(_bytes2.slice(0, 32));
          var _s4 = _bytes2.slice(32, 64);
          assertError((_s4[0] & 0x80) === 0, "non-canonical s");
          var _v4 = Signature.getNormalizedV(_bytes2[64]);
          return new Signature(_guard$3, _r6, hexlify(_s4), _v4);
        }
        assertError(false, "invlaid raw signature length");
      }
      if (sig instanceof Signature) {
        return sig.clone();
      }
      // Get r
      var _r = sig.r;
      assertError(_r != null, "missing r");
      var r = toUint256(_r);
      // Get s; by any means necessary (we check consistency below)
      var s = function (s, yParityAndS) {
        if (s != null) {
          return toUint256(s);
        }
        if (yParityAndS != null) {
          assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
          var _bytes3 = getBytes(yParityAndS);
          _bytes3[0] &= 0x7f;
          return hexlify(_bytes3);
        }
        assertError(false, "missing s");
      }(sig.s, sig.yParityAndS);
      assertError((getBytes(s)[0] & 0x80) == 0, "non-canonical s");
      // Get v; by any means necessary (we check consistency below)
      var _ref5 = function (_v, yParityAndS, yParity) {
          if (_v != null) {
            var _v5 = getBigInt(_v);
            return {
              networkV: _v5 >= BN_35$1 ? _v5 : undefined,
              v: Signature.getNormalizedV(_v5)
            };
          }
          if (yParityAndS != null) {
            assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
            return {
              v: getBytes(yParityAndS)[0] & 0x80 ? 28 : 27
            };
          }
          if (yParity != null) {
            switch (yParity) {
              case 0:
                return {
                  v: 27
                };
              case 1:
                return {
                  v: 28
                };
            }
            assertError(false, "invalid yParity");
          }
          assertError(false, "missing v");
        }(sig.v, sig.yParityAndS, sig.yParity),
        networkV = _ref5.networkV,
        v = _ref5.v;
      var result = new Signature(_guard$3, r, s, v);
      if (networkV) {
        _classPrivateFieldSet(result, _networkV, networkV);
      }
      // If multiple of v, yParity, yParityAndS we given, check they match
      assertError(!("yParity" in sig && sig.yParity !== result.yParity), "yParity mismatch");
      assertError(!("yParityAndS" in sig && sig.yParityAndS !== result.yParityAndS), "yParityAndS mismatch");
      return result;
    }
  }]);
  return Signature;
}();
/**
 *  Add details about signing here.
 *
 *  @_subsection: api/crypto:Signing  [about-signing]
 */
//const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// Make noble-secp256k1 sync
exports.Signature = Signature;
utils.hmacSha256Sync = function (key) {
  for (var _len12 = arguments.length, messages = new Array(_len12 > 1 ? _len12 - 1 : 0), _key13 = 1; _key13 < _len12; _key13++) {
    messages[_key13 - 1] = arguments[_key13];
  }
  return getBytes(computeHmac("sha256", key, concat(messages)));
};
/**
 *  A **SigningKey** provides high-level access to the elliptic curve
 *  cryptography (ECC) operations and key management.
 */
var _privateKey = /*#__PURE__*/new WeakMap();
var SigningKey = /*#__PURE__*/function () {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  function SigningKey(privateKey) {
    _classCallCheck(this, SigningKey);
    _classPrivateFieldInitSpec(this, _privateKey, {
      writable: true,
      value: void 0
    });
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    _classPrivateFieldSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  _createClass(SigningKey, [{
    key: "privateKey",
    get: function get() {
      return _classPrivateFieldGet(this, _privateKey);
    }
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
  }, {
    key: "publicKey",
    get: function get() {
      return SigningKey.computePublicKey(_classPrivateFieldGet(this, _privateKey));
    }
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
  }, {
    key: "compressedPublicKey",
    get: function get() {
      return SigningKey.computePublicKey(_classPrivateFieldGet(this, _privateKey), true);
    }
    /**
     *  Return the signature of the signed %%digest%%.
     */
  }, {
    key: "sign",
    value: function sign(digest) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      var _signSync = signSync(getBytesCopy(digest), getBytesCopy(_classPrivateFieldGet(this, _privateKey)), {
          recovered: true,
          canonical: true
        }),
        _signSync2 = _slicedToArray(_signSync, 2),
        sigDer = _signSync2[0],
        recid = _signSync2[1];
      var sig = Signature$1.fromHex(sigDer);
      return Signature.from({
        r: toBeHex("0x" + sig.r.toString(16), 32),
        s: toBeHex("0x" + sig.s.toString(16), 32),
        v: recid ? 0x1c : 0x1b
      });
    }
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
  }, {
    key: "computeSharedSecret",
    value: function computeSharedSecret(other) {
      var pubKey = SigningKey.computePublicKey(other);
      console.log(pubKey);
      return hexlify(getSharedSecret(getBytesCopy(_classPrivateFieldGet(this, _privateKey)), getBytes(pubKey)));
    }
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
  }], [{
    key: "computePublicKey",
    value: function computePublicKey(key, compressed) {
      var bytes = getBytes(key, "key");
      // private key
      if (bytes.length === 32) {
        var pubKey = getPublicKey(bytes, !!compressed);
        return hexlify(pubKey);
      }
      // raw public key; use uncompressed key with 0x04 prefix
      if (bytes.length === 64) {
        var pub = new Uint8Array(65);
        pub[0] = 0x04;
        pub.set(bytes, 1);
        bytes = pub;
      }
      var point = Point.fromHex(bytes);
      return hexlify(point.toRawBytes(compressed));
    }
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
  }, {
    key: "recoverPublicKey",
    value: function recoverPublicKey(digest, signature) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      var sig = Signature.from(signature);
      var der = Signature$1.fromCompact(getBytesCopy(concat([sig.r, sig.s]))).toDERRawBytes();
      var pubKey = _recoverPublicKey(getBytesCopy(digest), der, sig.yParity);
      if (pubKey != null) {
        return hexlify(pubKey);
      }
      assertArgument(false, "invalid signautre for digest", "signature", signature);
    }
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
  }, {
    key: "addPoints",
    value: function addPoints(p0, p1, compressed) {
      var pub0 = Point.fromHex(SigningKey.computePublicKey(p0).substring(2));
      var pub1 = Point.fromHex(SigningKey.computePublicKey(p1).substring(2));
      return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
  }]);
  return SigningKey;
}();
/**
 *  A fundamental building block of Ethereum is the underlying
 *  cryptographic primitives.
 *
 *  @_section: api/crypto:Cryptographic Functions   [about-crypto]
 */
exports.SigningKey = SigningKey;
null;
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf2.lock();
  randomBytes.lock();
  ripemd160.lock();
  scrypt.lock();
  scryptSync.lock();
  sha256.lock();
  sha512.lock();
  randomBytes.lock();
}
var BN_0$6 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  //    if (!isHexString(address, 20)) {
  //        logger.throwArgumentError("invalid address", "address", address);
  //    }
  address = address.toLowerCase();
  var chars = address.substring(2).split("");
  var expanded = new Uint8Array(40);
  for (var _i20 = 0; _i20 < 40; _i20++) {
    expanded[_i20] = chars[_i20].charCodeAt(0);
  }
  var hashed = getBytes(keccak256(expanded));
  for (var _i21 = 0; _i21 < 40; _i21 += 2) {
    if (hashed[_i21 >> 1] >> 4 >= 8) {
      chars[_i21] = chars[_i21].toUpperCase();
    }
    if ((hashed[_i21 >> 1] & 0x0f) >= 8) {
      chars[_i21 + 1] = chars[_i21 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
var ibanLookup = {};
for (var _i22 = 0; _i22 < 10; _i22++) {
  ibanLookup[String(_i22)] = String(_i22);
}
for (var _i23 = 0; _i23 < 26; _i23++) {
  ibanLookup[String.fromCharCode(65 + _i23)] = String(10 + _i23);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  var expanded = address.split("").map(function (c) {
    return ibanLookup[c];
  }).join("");
  // Javascript can handle integers safely up to 15 (decimal) digits
  while (expanded.length >= safeDigits) {
    var block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  var checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
;
var Base36 = function () {
  ;
  var result = {};
  for (var _i24 = 0; _i24 < 36; _i24++) {
    var key = "0123456789abcdefghijklmnopqrstuvwxyz"[_i24];
    result[key] = BigInt(_i24);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  var result = BN_0$6;
  for (var _i25 = 0; _i25 < value.length; _i25++) {
    result = result * BN_36 + Base36[value[_i25]];
  }
  return result;
}
/**
 *  Returns a normalized and checksumed address for %%address%%.
 *  This accepts non-checksum addresses, checksum addresses and
 *  [[getIcapAddress]] formats.
 *
 *  The checksum in Ethereum uses the capitalization (upper-case
 *  vs lower-case) of the characters within an address to encode
 *  its checksum, which offers, on average, a checksum of 15-bits.
 *
 *  If %%address%% contains both upper-case and lower-case, it is
 *  assumed to already be a checksum address and its checksum is
 *  validated, and if the address fails its expected checksum an
 *  error is thrown.
 *
 *  If you wish the checksum of %%address%% to be ignore, it should
 *  be converted to lower-case (i.e. ``.toLowercase()``) before
 *  being passed in. This should be a very rare situation though,
 *  that you wish to bypass the safegaurds in place to protect
 *  against an address that has been incorrectly copied from another
 *  source.
 *
 *  @example:
 *    // Adds the checksum (via upper-casing specific letters)
 *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
 *    //_result:
 *
 *    // Converts ICAP address and adds checksum
 *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if an address contains mixed case,
 *    // but the checksum fails
 *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_error:
 */
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    // Missing the 0x prefix
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    var result = getChecksumAddress(address);
    // It is a checksummed address with a bad checksum
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  // Maybe ICAP? (we only support direct mode)
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    // It is an ICAP address with a bad checksum
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    var _result2 = fromBase36(address.substring(4)).toString(16);
    while (_result2.length < 40) {
      _result2 = "0" + _result2;
    }
    return getChecksumAddress("0x" + _result2);
  }
  assertArgument(false, "invalid address", "address", address);
}
/**
 *  The [ICAP Address format](link-icap) format is an early checksum
 *  format which attempts to be compatible with the banking
 *  industry [IBAN format](link-wiki-iban] for bank accounts.
 *
 *  It is no longer common or a recommended format.
 *
 *  @example:
 *    getIcapAddress("0x8ba1f109551bd432803012645ac136ddd64dba72");
 *    //_result:
 *
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if the ICAP checksum is wrong
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37");
 *    //_error:
 */
function getIcapAddress(address) {
  //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  var base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}

// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
/**
 *  Returns the address that would result from a ``CREATE`` for %%tx%%.
 *
 *  This can be used to compute the address a contract will be
 *  deployed to by an EOA when sending a deployment transaction (i.e.
 *  when the ``to`` address is ``null``).
 *
 *  This can also be used to compute the address a contract will be
 *  deployed to by a contract, by using the contract's address as the
 *  ``to`` and the contract's nonce.
 *
 *  @example
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
 *    nonce = 5;
 *
 *    getCreateAddress({ from, nonce });
 *    //_result:
 */
function getCreateAddress(tx) {
  var from = getAddress(tx.from);
  var nonce = getBigInt(tx.nonce, "tx.nonce");
  var nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
/**
 *  Returns the address that would result from a ``CREATE2`` operation
 *  with the given %%from%%, %%salt%% and %%initCodeHash%%.
 *
 *  To compute the %%initCodeHash%% from a contract's init code, use
 *  the [[keccak256]] function.
 *
 *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].
 *
 *  @example
 *    // The address of the contract
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72"
 *
 *    // The salt
 *    salt = id("HelloWorld")
 *
 *    // The hash of the initCode
 *    initCode = "0x6394198df16000526103ff60206004601c335afa6040516060f3";
 *    initCodeHash = keccak256(initCode)
 *
 *    getCreate2Address(from, salt, initCodeHash)
 *    //_result:
 */
function getCreate2Address(_from, _salt, _initCodeHash) {
  var from = getAddress(_from);
  var salt = getBytes(_salt, "salt");
  var initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}

/**
 *  Returns true if %%value%% is an object which implements the
 *  [[Addressable]] interface.
 *
 *  @example:
 *    // Wallets and AbstractSigner sub-classes
 *    isAddressable(Wallet.createRandom())
 *    //_result:
 *
 *    // Contracts
 *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
 *    isAddressable(contract)
 *    //_result:
 */
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
/**
 *  Returns true if %%value%% is a valid address.
 *
 *  @example:
 *    // Valid address
 *    isAddress("0x8ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Valid ICAP address
 *    isAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36")
 *    //_result:
 *
 *    // Invalid checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBa72")
 *    //_result:
 *
 *    // Invalid ICAP checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Not an address (an ENS name requires a provided and an
 *    // asynchronous API to access)
 *    isAddress("ricmoo.eth")
 *    //_result:
 */
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {}
  return false;
}
function checkAddress(_x46, _x47) {
  return _checkAddress.apply(this, arguments);
}
/**
 *  Resolves to an address for the %%target%%, which may be any
 *  supported address type, an [[Addressable]] or a Promise which
 *  resolves to an address.
 *
 *  If an ENS name is provided, but that name has not been correctly
 *  configured a [[UnconfiguredNameError]] is thrown.
 *
 *  @example:
 *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
 *
 *    // Addresses are return synchronously
 *    resolveAddress(addr, provider)
 *    //_result:
 *
 *    // Address promises are resolved asynchronously
 *    resolveAddress(Promise.resolve(addr))
 *    //_result:
 *
 *    // ENS names are resolved asynchronously
 *    resolveAddress("dai.tokens.ethers.eth", provider)
 *    //_result:
 *
 *    // Addressable objects are resolved asynchronously
 *    contract = new Contract(addr, [ ])
 *    resolveAddress(contract, provider)
 *    //_result:
 *
 *    // Unconfigured ENS names reject
 *    resolveAddress("nothing-here.ricmoo.eth", provider)
 *    //_error:
 *
 *    // ENS names require a NameResolver object passed in
 *    // (notice the provider was omitted)
 *    resolveAddress("nothing-here.ricmoo.eth")
 *    //_error:
 */
function _checkAddress() {
  _checkAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee205(target, promise) {
    var result;
    return _regeneratorRuntime().wrap(function _callee205$(_context207) {
      while (1) switch (_context207.prev = _context207.next) {
        case 0:
          _context207.next = 2;
          return promise;
        case 2:
          result = _context207.sent;
          if (result == null || result === "0x0000000000000000000000000000000000000000") {
            assert$1(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", {
              value: target
            });
            assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
          }
          return _context207.abrupt("return", getAddress(result));
        case 5:
        case "end":
          return _context207.stop();
      }
    }, _callee205);
  }));
  return _checkAddress.apply(this, arguments);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert$1(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
      operation: "resolveName"
    });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}

/**
 *  Addresses are a fundamental part of interacting with Ethereum. They
 *  represent the gloabal identity of Externally Owned Accounts (accounts
 *  backed by a private key) and contracts.
 *
 *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem
 *  of contracts, standards and libraries which enable looking up an
 *  address for an ENS name.
 *
 *  These functions help convert between various formats, validate
 *  addresses and safely resolve ENS names.
 *
 *  @_section: api/address:Addresses  [about-addresses]
 */
null;

/**
 *  About typed...
 *
 *  @_subsection: api/abi:Typed Values
 */
var _gaurd = {};
function n(value, width) {
  var signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  // @TODO: Check range is valid for value
  return new Typed(_gaurd, "".concat(signed ? "" : "u", "int").concat(width), value, {
    signed: signed,
    width: width
  });
}
function b(value, size) {
  // @TODO: Check range is valid for value
  return new Typed(_gaurd, "bytes".concat(size ? size : ""), value, {
    size: size
  });
}
var _typedSymbol = Symbol["for"]("_ethers_typed");
var _options = /*#__PURE__*/new WeakMap();
var Typed = /*#__PURE__*/function () {
  function Typed(gaurd, type, value, options) {
    _classCallCheck(this, Typed);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "value", void 0);
    _classPrivateFieldInitSpec(this, _options, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "_typedSymbol", void 0);
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, {
      _typedSymbol: _typedSymbol,
      type: type,
      value: value
    });
    _classPrivateFieldSet(this, _options, options);
    // Check the value is valid
    this.format();
  }
  _createClass(Typed, [{
    key: "format",
    value: function format() {
      if (this.type === "array") {
        throw new Error("");
      } else if (this.type === "dynamicArray") {
        throw new Error("");
      } else if (this.type === "tuple") {
        return "tuple(".concat(this.value.map(function (v) {
          return v.format();
        }).join(","), ")");
      }
      return this.type;
    }
  }, {
    key: "defaultValue",
    value: function defaultValue() {
      return 0;
    }
  }, {
    key: "minValue",
    value: function minValue() {
      return 0;
    }
  }, {
    key: "maxValue",
    value: function maxValue() {
      return 0;
    }
  }, {
    key: "isBigInt",
    value: function isBigInt() {
      return !!this.type.match(/^u?int[0-9]+$/);
    }
  }, {
    key: "isData",
    value: function isData() {
      return this.type.startsWith("bytes");
    }
  }, {
    key: "isString",
    value: function isString() {
      return this.type === "string";
    }
  }, {
    key: "tupleName",
    get: function get() {
      if (this.type !== "tuple") {
        throw TypeError("not a tuple");
      }
      return _classPrivateFieldGet(this, _options);
    }
    // Returns the length of this type as an array
    // - `null` indicates the length is unforced, it could be dynamic
    // - `-1` indicates the length is dynamic
    // - any other value indicates it is a static array and is its length
  }, {
    key: "arrayLength",
    get: function get() {
      if (this.type !== "array") {
        throw TypeError("not an array");
      }
      if (_classPrivateFieldGet(this, _options) === true) {
        return -1;
      }
      if (_classPrivateFieldGet(this, _options) === false) {
        return this.value.length;
      }
      return null;
    }
  }], [{
    key: "from",
    value: function from(type, value) {
      return new Typed(_gaurd, type, value);
    }
  }, {
    key: "uint8",
    value: function uint8(v) {
      return n(v, 8);
    }
  }, {
    key: "uint16",
    value: function uint16(v) {
      return n(v, 16);
    }
  }, {
    key: "uint24",
    value: function uint24(v) {
      return n(v, 24);
    }
  }, {
    key: "uint32",
    value: function uint32(v) {
      return n(v, 32);
    }
  }, {
    key: "uint40",
    value: function uint40(v) {
      return n(v, 40);
    }
  }, {
    key: "uint48",
    value: function uint48(v) {
      return n(v, 48);
    }
  }, {
    key: "uint56",
    value: function uint56(v) {
      return n(v, 56);
    }
  }, {
    key: "uint64",
    value: function uint64(v) {
      return n(v, 64);
    }
  }, {
    key: "uint72",
    value: function uint72(v) {
      return n(v, 72);
    }
  }, {
    key: "uint80",
    value: function uint80(v) {
      return n(v, 80);
    }
  }, {
    key: "uint88",
    value: function uint88(v) {
      return n(v, 88);
    }
  }, {
    key: "uint96",
    value: function uint96(v) {
      return n(v, 96);
    }
  }, {
    key: "uint104",
    value: function uint104(v) {
      return n(v, 104);
    }
  }, {
    key: "uint112",
    value: function uint112(v) {
      return n(v, 112);
    }
  }, {
    key: "uint120",
    value: function uint120(v) {
      return n(v, 120);
    }
  }, {
    key: "uint128",
    value: function uint128(v) {
      return n(v, 128);
    }
  }, {
    key: "uint136",
    value: function uint136(v) {
      return n(v, 136);
    }
  }, {
    key: "uint144",
    value: function uint144(v) {
      return n(v, 144);
    }
  }, {
    key: "uint152",
    value: function uint152(v) {
      return n(v, 152);
    }
  }, {
    key: "uint160",
    value: function uint160(v) {
      return n(v, 160);
    }
  }, {
    key: "uint168",
    value: function uint168(v) {
      return n(v, 168);
    }
  }, {
    key: "uint176",
    value: function uint176(v) {
      return n(v, 176);
    }
  }, {
    key: "uint184",
    value: function uint184(v) {
      return n(v, 184);
    }
  }, {
    key: "uint192",
    value: function uint192(v) {
      return n(v, 192);
    }
  }, {
    key: "uint200",
    value: function uint200(v) {
      return n(v, 200);
    }
  }, {
    key: "uint208",
    value: function uint208(v) {
      return n(v, 208);
    }
  }, {
    key: "uint216",
    value: function uint216(v) {
      return n(v, 216);
    }
  }, {
    key: "uint224",
    value: function uint224(v) {
      return n(v, 224);
    }
  }, {
    key: "uint232",
    value: function uint232(v) {
      return n(v, 232);
    }
  }, {
    key: "uint240",
    value: function uint240(v) {
      return n(v, 240);
    }
  }, {
    key: "uint248",
    value: function uint248(v) {
      return n(v, 248);
    }
  }, {
    key: "uint256",
    value: function uint256(v) {
      return n(v, 256);
    }
  }, {
    key: "uint",
    value: function uint(v) {
      return n(v, 256);
    }
  }, {
    key: "int8",
    value: function int8(v) {
      return n(v, -8);
    }
  }, {
    key: "int16",
    value: function int16(v) {
      return n(v, -16);
    }
  }, {
    key: "int24",
    value: function int24(v) {
      return n(v, -24);
    }
  }, {
    key: "int32",
    value: function int32(v) {
      return n(v, -32);
    }
  }, {
    key: "int40",
    value: function int40(v) {
      return n(v, -40);
    }
  }, {
    key: "int48",
    value: function int48(v) {
      return n(v, -48);
    }
  }, {
    key: "int56",
    value: function int56(v) {
      return n(v, -56);
    }
  }, {
    key: "int64",
    value: function int64(v) {
      return n(v, -64);
    }
  }, {
    key: "int72",
    value: function int72(v) {
      return n(v, -72);
    }
  }, {
    key: "int80",
    value: function int80(v) {
      return n(v, -80);
    }
  }, {
    key: "int88",
    value: function int88(v) {
      return n(v, -88);
    }
  }, {
    key: "int96",
    value: function int96(v) {
      return n(v, -96);
    }
  }, {
    key: "int104",
    value: function int104(v) {
      return n(v, -104);
    }
  }, {
    key: "int112",
    value: function int112(v) {
      return n(v, -112);
    }
  }, {
    key: "int120",
    value: function int120(v) {
      return n(v, -120);
    }
  }, {
    key: "int128",
    value: function int128(v) {
      return n(v, -128);
    }
  }, {
    key: "int136",
    value: function int136(v) {
      return n(v, -136);
    }
  }, {
    key: "int144",
    value: function int144(v) {
      return n(v, -144);
    }
  }, {
    key: "int152",
    value: function int152(v) {
      return n(v, -152);
    }
  }, {
    key: "int160",
    value: function int160(v) {
      return n(v, -160);
    }
  }, {
    key: "int168",
    value: function int168(v) {
      return n(v, -168);
    }
  }, {
    key: "int176",
    value: function int176(v) {
      return n(v, -176);
    }
  }, {
    key: "int184",
    value: function int184(v) {
      return n(v, -184);
    }
  }, {
    key: "int192",
    value: function int192(v) {
      return n(v, -192);
    }
  }, {
    key: "int200",
    value: function int200(v) {
      return n(v, -200);
    }
  }, {
    key: "int208",
    value: function int208(v) {
      return n(v, -208);
    }
  }, {
    key: "int216",
    value: function int216(v) {
      return n(v, -216);
    }
  }, {
    key: "int224",
    value: function int224(v) {
      return n(v, -224);
    }
  }, {
    key: "int232",
    value: function int232(v) {
      return n(v, -232);
    }
  }, {
    key: "int240",
    value: function int240(v) {
      return n(v, -240);
    }
  }, {
    key: "int248",
    value: function int248(v) {
      return n(v, -248);
    }
  }, {
    key: "int256",
    value: function int256(v) {
      return n(v, -256);
    }
  }, {
    key: "int",
    value: function int(v) {
      return n(v, -256);
    }
  }, {
    key: "bytes1",
    value: function bytes1(v) {
      return b(v, 1);
    }
  }, {
    key: "bytes2",
    value: function bytes2(v) {
      return b(v, 2);
    }
  }, {
    key: "bytes3",
    value: function bytes3(v) {
      return b(v, 3);
    }
  }, {
    key: "bytes4",
    value: function bytes4(v) {
      return b(v, 4);
    }
  }, {
    key: "bytes5",
    value: function bytes5(v) {
      return b(v, 5);
    }
  }, {
    key: "bytes6",
    value: function bytes6(v) {
      return b(v, 6);
    }
  }, {
    key: "bytes7",
    value: function bytes7(v) {
      return b(v, 7);
    }
  }, {
    key: "bytes8",
    value: function bytes8(v) {
      return b(v, 8);
    }
  }, {
    key: "bytes9",
    value: function bytes9(v) {
      return b(v, 9);
    }
  }, {
    key: "bytes10",
    value: function bytes10(v) {
      return b(v, 10);
    }
  }, {
    key: "bytes11",
    value: function bytes11(v) {
      return b(v, 11);
    }
  }, {
    key: "bytes12",
    value: function bytes12(v) {
      return b(v, 12);
    }
  }, {
    key: "bytes13",
    value: function bytes13(v) {
      return b(v, 13);
    }
  }, {
    key: "bytes14",
    value: function bytes14(v) {
      return b(v, 14);
    }
  }, {
    key: "bytes15",
    value: function bytes15(v) {
      return b(v, 15);
    }
  }, {
    key: "bytes16",
    value: function bytes16(v) {
      return b(v, 16);
    }
  }, {
    key: "bytes17",
    value: function bytes17(v) {
      return b(v, 17);
    }
  }, {
    key: "bytes18",
    value: function bytes18(v) {
      return b(v, 18);
    }
  }, {
    key: "bytes19",
    value: function bytes19(v) {
      return b(v, 19);
    }
  }, {
    key: "bytes20",
    value: function bytes20(v) {
      return b(v, 20);
    }
  }, {
    key: "bytes21",
    value: function bytes21(v) {
      return b(v, 21);
    }
  }, {
    key: "bytes22",
    value: function bytes22(v) {
      return b(v, 22);
    }
  }, {
    key: "bytes23",
    value: function bytes23(v) {
      return b(v, 23);
    }
  }, {
    key: "bytes24",
    value: function bytes24(v) {
      return b(v, 24);
    }
  }, {
    key: "bytes25",
    value: function bytes25(v) {
      return b(v, 25);
    }
  }, {
    key: "bytes26",
    value: function bytes26(v) {
      return b(v, 26);
    }
  }, {
    key: "bytes27",
    value: function bytes27(v) {
      return b(v, 27);
    }
  }, {
    key: "bytes28",
    value: function bytes28(v) {
      return b(v, 28);
    }
  }, {
    key: "bytes29",
    value: function bytes29(v) {
      return b(v, 29);
    }
  }, {
    key: "bytes30",
    value: function bytes30(v) {
      return b(v, 30);
    }
  }, {
    key: "bytes31",
    value: function bytes31(v) {
      return b(v, 31);
    }
  }, {
    key: "bytes32",
    value: function bytes32(v) {
      return b(v, 32);
    }
  }, {
    key: "address",
    value: function address(v) {
      return new Typed(_gaurd, "address", v);
    }
  }, {
    key: "bool",
    value: function bool(v) {
      return new Typed(_gaurd, "bool", !!v);
    }
  }, {
    key: "bytes",
    value: function bytes(v) {
      return new Typed(_gaurd, "bytes", v);
    }
  }, {
    key: "string",
    value: function string(v) {
      return new Typed(_gaurd, "string", v);
    }
  }, {
    key: "array",
    value: function array(v, dynamic) {
      throw new Error("not implemented yet");
      return new Typed(_gaurd, "array", v, dynamic);
    }
  }, {
    key: "tuple",
    value: function tuple(v, name) {
      throw new Error("not implemented yet");
      return new Typed(_gaurd, "tuple", v, name);
    }
  }, {
    key: "overrides",
    value: function overrides(v) {
      return new Typed(_gaurd, "overrides", Object.assign({}, v));
    }
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
  }, {
    key: "isTyped",
    value: function isTyped(value) {
      return value && value._typedSymbol === _typedSymbol;
    }
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
  }, {
    key: "dereference",
    value: function dereference(value, type) {
      if (Typed.isTyped(value)) {
        if (value.type !== type) {
          throw new Error("invalid type: expecetd ".concat(type, ", got ").concat(value.type));
        }
        return value.value;
      }
      return value;
    }
  }]);
  return Typed;
}();
/**
 *  @_ignore
 */
exports.Typed = Typed;
var AddressCoder = /*#__PURE__*/function (_Coder) {
  _inherits(AddressCoder, _Coder);
  var _super11 = _createSuper(AddressCoder);
  function AddressCoder(localName) {
    _classCallCheck(this, AddressCoder);
    return _super11.call(this, "address", "address", localName, false);
  }
  _createClass(AddressCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = Typed.dereference(_value, "string");
      try {
        value = getAddress(value);
      } catch (error) {
        return this._throwError(error.message, _value);
      }
      return writer.writeValue(value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return getAddress(toBeHex(reader.readValue(), 20));
    }
  }]);
  return AddressCoder;
}(Coder);
/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
var AnonymousCoder = /*#__PURE__*/function (_Coder2) {
  _inherits(AnonymousCoder, _Coder2);
  var _super12 = _createSuper(AnonymousCoder);
  function AnonymousCoder(coder) {
    var _this14;
    _classCallCheck(this, AnonymousCoder);
    _this14 = _super12.call(this, coder.name, coder.type, "_", coder.dynamic);
    _defineProperty(_assertThisInitialized(_this14), "coder", void 0);
    _this14.coder = coder;
    return _this14;
  }
  _createClass(AnonymousCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return this.coder.defaultValue();
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      return this.coder.encode(writer, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return this.coder.decode(reader);
    }
  }]);
  return AnonymousCoder;
}(Coder);
/**
 *  @_ignore
 */
function pack(writer, coders, values) {
  var arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && _typeof(values) === "object") {
    var unique = {};
    arrayValues = coders.map(function (coder) {
      var name = coder.localName;
      assert$1(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
        argument: "values",
        info: {
          coder: coder
        },
        value: values
      });
      assert$1(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
        argument: "values",
        info: {
          coder: coder
        },
        value: values
      });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  var staticWriter = new Writer();
  var dynamicWriter = new Writer();
  var updateFuncs = [];
  coders.forEach(function (coder, index) {
    var value = arrayValues[index];
    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      var dynamicOffset = dynamicWriter.length;
      // Encode the dynamic value into the dynamicWriter
      coder.encode(dynamicWriter, value);
      // Prepare to populate the correct offset once we are done
      var updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push(function (baseOffset) {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  // Backfill all the dynamic offsets, now that we know the static length
  updateFuncs.forEach(function (func) {
    func(staticWriter.length);
  });
  var length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
/**
 *  @_ignore
 */
function unpack(reader, coders) {
  var values = [];
  var keys = [];
  // A reader anchored to this base
  var baseReader = reader.subReader(0);
  coders.forEach(function (coder) {
    var value = null;
    if (coder.dynamic) {
      var offset = reader.readIndex();
      var offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == undefined) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
/**
 *  @_ignore
 */
var ArrayCoder = /*#__PURE__*/function (_Coder3) {
  _inherits(ArrayCoder, _Coder3);
  var _super13 = _createSuper(ArrayCoder);
  function ArrayCoder(coder, length, localName) {
    var _this15;
    _classCallCheck(this, ArrayCoder);
    var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    var dynamic = length === -1 || coder.dynamic;
    _this15 = _super13.call(this, "array", type, localName, dynamic);
    _defineProperty(_assertThisInitialized(_this15), "coder", void 0);
    _defineProperty(_assertThisInitialized(_this15), "length", void 0);
    defineProperties(_assertThisInitialized(_this15), {
      coder: coder,
      length: length
    });
    return _this15;
  }
  _createClass(ArrayCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      // Verifies the child coder is valid (even if the array is dynamic or 0-length)
      var defaultChild = this.coder.defaultValue();
      var result = [];
      for (var _i26 = 0; _i26 < this.length; _i26++) {
        result.push(defaultChild);
      }
      return result;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = Typed.dereference(_value, "array");
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      var count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      var coders = [];
      for (var _i27 = 0; _i27 < value.length; _i27++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      var count = this.length;
      if (count === -1) {
        count = reader.readIndex();
        // Check that there is *roughly* enough data to ensure
        // stray random data is not being read as a length. Each
        // slot requires at least 32 bytes for their value (or 32
        // bytes as a link to the data). This could use a much
        // tighter bound, but we are erroring on the side of safety.
        assert$1(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
          buffer: reader.bytes,
          offset: count * WordSize,
          length: reader.dataLength
        });
      }
      var coders = [];
      for (var _i28 = 0; _i28 < count; _i28++) {
        coders.push(new AnonymousCoder(this.coder));
      }
      return unpack(reader, coders);
    }
  }]);
  return ArrayCoder;
}(Coder);
/**
 *  @_ignore
 */
var BooleanCoder = /*#__PURE__*/function (_Coder4) {
  _inherits(BooleanCoder, _Coder4);
  var _super14 = _createSuper(BooleanCoder);
  function BooleanCoder(localName) {
    _classCallCheck(this, BooleanCoder);
    return _super14.call(this, "bool", "bool", localName, false);
  }
  _createClass(BooleanCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return false;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = Typed.dereference(_value, "bool");
      return writer.writeValue(value ? 1 : 0);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return !!reader.readValue();
    }
  }]);
  return BooleanCoder;
}(Coder);
/**
 *  @_ignore
 */
var DynamicBytesCoder = /*#__PURE__*/function (_Coder5) {
  _inherits(DynamicBytesCoder, _Coder5);
  var _super15 = _createSuper(DynamicBytesCoder);
  function DynamicBytesCoder(type, localName) {
    _classCallCheck(this, DynamicBytesCoder);
    return _super15.call(this, type, type, localName, true);
  }
  _createClass(DynamicBytesCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x";
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      value = getBytesCopy(value);
      var length = writer.writeValue(value.length);
      length += writer.writeBytes(value);
      return length;
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return reader.readBytes(reader.readIndex(), true);
    }
  }]);
  return DynamicBytesCoder;
}(Coder);
/**
 *  @_ignore
 */
var BytesCoder = /*#__PURE__*/function (_DynamicBytesCoder) {
  _inherits(BytesCoder, _DynamicBytesCoder);
  var _super16 = _createSuper(BytesCoder);
  function BytesCoder(localName) {
    _classCallCheck(this, BytesCoder);
    return _super16.call(this, "bytes", localName);
  }
  _createClass(BytesCoder, [{
    key: "decode",
    value: function decode(reader) {
      return hexlify(_get(_getPrototypeOf(BytesCoder.prototype), "decode", this).call(this, reader));
    }
  }]);
  return BytesCoder;
}(DynamicBytesCoder);
/**
 *  @_ignore
 */
var FixedBytesCoder = /*#__PURE__*/function (_Coder6) {
  _inherits(FixedBytesCoder, _Coder6);
  var _super17 = _createSuper(FixedBytesCoder);
  function FixedBytesCoder(size, localName) {
    var _this16;
    _classCallCheck(this, FixedBytesCoder);
    var name = "bytes" + String(size);
    _this16 = _super17.call(this, name, name, localName, false);
    _defineProperty(_assertThisInitialized(_this16), "size", void 0);
    defineProperties(_assertThisInitialized(_this16), {
      size: size
    }, {
      size: "number"
    });
    return _this16;
  }
  _createClass(FixedBytesCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var data = getBytesCopy(Typed.dereference(_value, this.type));
      if (data.length !== this.size) {
        this._throwError("incorrect data length", _value);
      }
      return writer.writeBytes(data);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return hexlify(reader.readBytes(this.size));
    }
  }]);
  return FixedBytesCoder;
}(Coder);
var Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
var NullCoder = /*#__PURE__*/function (_Coder7) {
  _inherits(NullCoder, _Coder7);
  var _super18 = _createSuper(NullCoder);
  function NullCoder(localName) {
    _classCallCheck(this, NullCoder);
    return _super18.call(this, "null", "", localName, false);
  }
  _createClass(NullCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return null;
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes(Empty);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      reader.readBytes(0);
      return null;
    }
  }]);
  return NullCoder;
}(Coder);
var BN_0$5 = BigInt(0);
var BN_1$2 = BigInt(1);
var BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  @_ignore
 */
var NumberCoder = /*#__PURE__*/function (_Coder8) {
  _inherits(NumberCoder, _Coder8);
  var _super19 = _createSuper(NumberCoder);
  function NumberCoder(size, signed, localName) {
    var _this17;
    _classCallCheck(this, NumberCoder);
    var name = (signed ? "int" : "uint") + size * 8;
    _this17 = _super19.call(this, name, name, localName, false);
    _defineProperty(_assertThisInitialized(_this17), "size", void 0);
    _defineProperty(_assertThisInitialized(_this17), "signed", void 0);
    defineProperties(_assertThisInitialized(_this17), {
      size: size,
      signed: signed
    }, {
      size: "number",
      signed: "boolean"
    });
    return _this17;
  }
  _createClass(NumberCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return 0;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = getBigInt(Typed.dereference(_value, this.type));
      // Check bounds are safe for encoding
      var maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
      if (this.signed) {
        var bounds = mask(maxUintValue, this.size * 8 - 1);
        if (value > bounds || value < -(bounds + BN_1$2)) {
          this._throwError("value out-of-bounds", _value);
        }
        value = toTwos(value, 8 * WordSize);
      } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
        this._throwError("value out-of-bounds", _value);
      }
      return writer.writeValue(value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      var value = mask(reader.readValue(), this.size * 8);
      if (this.signed) {
        value = fromTwos(value, this.size * 8);
      }
      return value;
    }
  }]);
  return NumberCoder;
}(Coder);
/**
 *  @_ignore
 */
var StringCoder = /*#__PURE__*/function (_DynamicBytesCoder2) {
  _inherits(StringCoder, _DynamicBytesCoder2);
  var _super20 = _createSuper(StringCoder);
  function StringCoder(localName) {
    _classCallCheck(this, StringCoder);
    return _super20.call(this, "string", localName);
  }
  _createClass(StringCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "";
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      return _get(_getPrototypeOf(StringCoder.prototype), "encode", this).call(this, writer, toUtf8Bytes(Typed.dereference(_value, "string")));
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return toUtf8String(_get(_getPrototypeOf(StringCoder.prototype), "decode", this).call(this, reader));
    }
  }]);
  return StringCoder;
}(DynamicBytesCoder);
/**
 *  @_ignore
 */
var TupleCoder = /*#__PURE__*/function (_Coder9) {
  _inherits(TupleCoder, _Coder9);
  var _super21 = _createSuper(TupleCoder);
  function TupleCoder(coders, localName) {
    var _this18;
    _classCallCheck(this, TupleCoder);
    var dynamic = false;
    var types = [];
    coders.forEach(function (coder) {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    var type = "tuple(" + types.join(",") + ")";
    _this18 = _super21.call(this, "tuple", type, localName, dynamic);
    _defineProperty(_assertThisInitialized(_this18), "coders", void 0);
    defineProperties(_assertThisInitialized(_this18), {
      coders: Object.freeze(coders.slice())
    });
    return _this18;
  }
  _createClass(TupleCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      var values = [];
      this.coders.forEach(function (coder) {
        values.push(coder.defaultValue());
      });
      // We only output named properties for uniquely named coders
      var uniqueNames = this.coders.reduce(function (accum, coder) {
        var name = coder.localName;
        if (name) {
          if (!accum[name]) {
            accum[name] = 0;
          }
          accum[name]++;
        }
        return accum;
      }, {});
      // Add named values
      this.coders.forEach(function (coder, index) {
        var name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
          return;
        }
        if (name === "length") {
          name = "_length";
        }
        if (values[name] != null) {
          return;
        }
        values[name] = values[index];
      });
      return Object.freeze(values);
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = Typed.dereference(_value, "tuple");
      return pack(writer, this.coders, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return unpack(reader, this.coders);
    }
  }]);
  return TupleCoder;
}(Coder);
/**
 *  A simple hashing function which operates on UTF-8 strings to
 *  compute an 32-byte irentifier.
 *
 *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
 *  the [[keccak256]].
 *
 *  @example:
 *    id("hello world")
 *    //_result:
 */
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
function decode_arithmetic(bytes) {
  var pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }

  // decode the frequency table
  var symbol_count = u16();
  var total = 1;
  var acc = [0, 1]; // first symbol has frequency 1
  for (var _i29 = 1; _i29 < symbol_count; _i29++) {
    acc.push(total += u16());
  }

  // skip the sized-payload that the last 3 symbols index into
  var skip = u16();
  var pos_payload = pos;
  pos += skip;
  var read_width = 0;
  var read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      // this will read beyond end of buffer
      // but (undefined|0) => zero pad
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  var N = 31;
  var FULL = Math.pow(2, N);
  var HALF = FULL >>> 1;
  var QRTR = HALF >> 1;
  var MASK = FULL - 1;

  // fill register
  var register = 0;
  for (var _i30 = 0; _i30 < N; _i30++) register = register << 1 | read_bit();
  var symbols = [];
  var low = 0;
  var range = FULL; // treat like a float
  while (true) {
    var value = Math.floor(((register - low + 1) * total - 1) / range);
    var start = 0;
    var end = symbol_count;
    while (end - start > 1) {
      // binary search
      var mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break; // first symbol is end mark
    symbols.push(start);
    var a = low + Math.floor(range * acc[start] / total);
    var _b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ _b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      _b2 = _b2 << 1 & MASK | 1;
    }
    while (a & ~_b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      _b2 = (_b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + _b2 - a;
  }
  var offset = symbol_count - 4;
  return symbols.map(function (x) {
    // index into payload
    switch (x - offset) {
      case 3:
        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}

// returns an iterator which returns the next symbol
function read_payload(v) {
  var pos = 0;
  return function () {
    return v[pos++];
  };
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
function unsafe_atob(s) {
  var lookup = [];
  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {
    return lookup[c.charCodeAt(0)] = i;
  });
  var n = s.length;
  var ret = new Uint8Array(6 * n >> 3);
  for (var _i31 = 0, pos = 0, width = 0, carry = 0; _i31 < n; _i31++) {
    carry = carry << 6 | lookup[s.charCodeAt(_i31)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next) {
  var v = Array(n);
  for (var _i32 = 0, _x48 = 0; _i32 < n; _i32++) v[_i32] = _x48 += signed(next());
  return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next) {
  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var ret = [];
  while (true) {
    var _x49 = next();
    var _n3 = next();
    if (!_n3) break;
    prev += _x49;
    for (var _i33 = 0; _i33 < _n3; _i33++) {
      ret.push(prev + _i33);
    }
    prev += _n3 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(function () {
    var v = read_sorted(next);
    if (v.length) return v;
  });
}

// returns map of x => ys
function read_mapped(next) {
  var ret = [];
  while (true) {
    var w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    var _w = next() - 1;
    if (_w < 0) break;
    ret.push(read_replacement_table(_w, next));
  }
  return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
  var v = [];
  while (true) {
    var _x50 = next(v.length);
    if (!_x50) break;
    v.push(_x50);
  }
  return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
  var m = Array(n).fill().map(function () {
    return [];
  });
  for (var _i34 = 0; _i34 < w; _i34++) {
    read_deltas(n, next).forEach(function (x, j) {
      return m[j].push(x);
    });
  }
  return m;
}

// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
  var dx = 1 + next();
  var dy = next();
  var vN = read_array_while(next);
  var m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap(function (v, i) {
    var _v6 = _toArray(v),
      x = _v6[0],
      ys = _v6.slice(1);
    return Array(vN[i]).fill().map(function (_, j) {
      var j_dy = j * dy;
      return [x + j * dx, ys.map(function (y) {
        return y + j_dy;
      })];
    });
  });
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) {
  var n = 1 + next();
  var m = read_transposed(n, 1 + w, next);
  return m.map(function (v) {
    return [v[0], v.slice(1)];
  });
}

// created 2023-01-26T08:54:35.886Z
var r = read_compressed_payload('AEIRrQh1DccBuQJ+APkBMQDiASoAnADQAHQAngBmANQAaACKAEQAgwBJAHcAOQA9ACoANQAmAGMAHgAvACgAJQAWACwAGQAjAB8ALwAVACgAEQAdAAkAHAARABgAFwA7ACcALAAtADcAEwApABAAHQAfABAAGAAeABsAFwAUBLoF3QEXE7k3ygXaALgArkYBbgCsCAPMAK6GNjY2NjFiAQ0ODBDyAAQHRgbrOAVeBV8APTI5B/a9GAUNz8gAFQPPBeelYALMCjYCjqgCht8/lW+QAsXSAoP5ASbmEADytAFIAjSUCkaWAOoA6QocAB7bwM8TEkSkBCJ+AQQCQBjED/IQBjDwDASIbgwDxAeuBzQAsgBwmO+snIYAYgaaAioG8AAiAEIMmhcCqgLKQiDWCMIwA7gCFAIA9zRyqgCohB8AHgQsAt4dASQAwBnUBQEQIFM+CZ4JjyUiIVbATOqDSQAaABMAHAAVclsAKAAVAE71HN89+gI5X8qc5jUKFyRfVAJfPfMAGgATABwAFXIgY0CeAMPyACIAQAzMFsKqAgHavwViBekC0KYCxLcCClMjpGwUehp0TPwAwhRuAugAEjQ0kBfQmAKBggETIgDEFG4C6AASNAFPUCyYTBEDLgIFMBDecB60Ad5KAHgyEn4COBYoAy4uwD5yAEDoAfwsAM4OqLwBImqIALgMAAwCAIraUAUi3HIeAKgu2AGoBgYGBgYrNAOiAG4BCiA+9Dd7BB8eALEBzgIoAgDmMhJ6OvpQtzOoLjVPBQAGAS4FYAVftr8FcDtkQhlBWEiee5pmZqH/EhoDzA4s+H4qBKpSAlpaAnwisi4BlqqsPGIDTB4EimgQANgCBrJGNioCBzACQGQAcgFoJngAiiQgAJwBUL4ALnAeAbbMAz40KEoEWgF2YAZsAmwA+FAeAzAIDABQSACyAABkAHoAMrwGDvr2IJSGBgAQKAAwALoiTgHYAeIOEjiXf4HvABEAGAA7AEQAPzp3gNrHEGYQYwgFTRBMc0EVEgKzD60L7BEcDNgq0tPfADSwB/IDWgfyA1oDWgfyB/IDWgfyA1oDWgNaA1ocEfAh2scQZg9PBHQFlQWSBN0IiiZQEYgHLwjZVBR0JRxOA0wBAyMsSSM7mjMSJUlME00KCAM2SWyufT8DTjGyVPyQqQPSMlY5cwgFHngSpwAxD3ojNbxOhXpOcacKUk+1tYZJaU5uAsU6rz//CigJmm/Cd1UGRBAeJ6gQ+gw2AbgBPg3wS9sE9AY+BMwfgBkcD9CVnwioLeAM8CbmLqSAXSP4KoYF8Ev3POALUFFrD1wLaAnmOmaBUQMkARAijgrgDTwIcBD2CsxuDegRSAc8A9hJnQCoBwQLFB04FbgmE2KvCww5egb+GvkLkiayEyx6/wXWGiQGUAEsGwIA0i7qhbNaNFwfT2IGBgsoI8oUq1AjDShAunhLGh4HGCWsApRDc0qKUTkeliH5PEANaS4WUX8H+DwIGVILhDyhRq5FERHVPpA9SyJMTC8EOIIsMieOCdIPiAy8fHUBXAkkCbQMdBM0ERo3yAg8BxwwlycnGAgkRphgnQT6ogP2E9QDDgVCCUQHFgO4HDATMRUsBRCBJ9oC9jbYLrYCklaDARoFzg8oH+IQU0fjDuwIngJoA4Yl7gAwFSQAGiKeCEZmAGKP21MILs4IympvI3cDahTqZBF2B5QOWgeqHDYVwhzkcMteDoYLKKayCV4BeAmcAWIE5ggMNV6MoyBEZ1aLWxieIGRBQl3/AjQMaBWiRMCHewKOD24SHgE4AXYHPA0EAnoR8BFuEJgI7oYHNbgz+zooBFIhhiAUCioDUmzRCyom/Az7bAGmEmUDDzRAd/FnrmC5JxgABxwyyEFjIfQLlU/QDJ8axBhFVDEZ5wfCA/Ya9iftQVoGAgOmBhY6UDPxBMALbAiOCUIATA6mGgfaGG0KdIzTATSOAbqcA1qUhgJykgY6Bw4Aag6KBXzoACACqgimAAgA0gNaADwCsAegABwAiEQBQAMqMgEk6AKSA5YINM4BmDIB9iwEHsYMGAD6Om5NAsO0AoBtZqUF4FsCkQJMOAFQKAQIUUpUA7J05ADeAE4GFuJKARiuTc4d5kYB4nIuAMoA/gAIOAcIRAHQAfZwALoBYgs0CaW2uAFQ7CwAhgAYbgHaAowA4AA4AIL0AVYAUAVc/AXWAlJMARQ0Gy5aZAG+AyIBNgEQAHwGzpCozAoiBHAH1gIQHhXkAu8xB7gEAyLiE9BCyAK94VgAMhkKOwqqCqlgXmM2CTR1PVMAER+rPso/UQVUO1Y7WztWO1s7VjtbO1Y7WztWO1sDmsLlwuUKb19IYe4MqQ3XRMs6TBPeYFRgNRPLLboUxBXRJVkZQBq/Jwgl51UMDwct1mYzCC80eBe/AEIpa4NEY4keMwpOHOpTlFT7LR4AtEulM7INrxsYREMFSnXwYi0WEQolAmSEAmJFXlCyAF43IwKh+gJomwJmDAKfhzgeDgJmPgJmKQRxBIIDfxYDfpU5CTl6GjmFOiYmAmwgAjI5OA0CbcoCbbHyjQI2akguAWoA4QDkAE0IB5sMkAEBDsUAELgCdzICdqVCAnlORgJ4vSBf3kWxRvYCfEICessCfQwCfPNIA0iAZicALhhJW0peGBpKzwLRBALQz0sqA4hSA4fpRMiRNQLypF0GAwOxS9FMMCgG0k1PTbICi0ICitvEHgogRmoIugKOOgKOX0OahAKO3AKOX3tRt1M4AA1S11SIApP+ApMPAOwAH1UhVbJV0wksHimYiTLkeGlFPjwCl6IC77VYJKsAXCgClpICln+fAKxZr1oMhFAAPgKWuAKWUVxHXNQCmc4CmWdczV0KHAKcnjnFOqACnBkCn54CnruNACASNC0SAp30Ap6VALhAYTdh8gKe1gKgcQGsAp6iIgKeUahjy2QqKC4CJ7ICJoECoP4CoE/aAqYyAqXRAqgCAIACp/Vof2i0AAZMah9q1AKs5gKssQKtagKtBQJXIAJV3wKx5NoDH1FsmgKywBACsusabONtZm1LYgMl0AK2Xz5CbpMDKUgCuGECuUoYArktenA5cOQCvRwDLbUDMhQCvotyBQMzdAK+HXMlc1ICw84CwwdzhXROOEh04wM8qgADPJ0DPcICxX8CxkoCxhOMAshsVALIRwLJUgLJMQJkoALd1Xh8ZHixeShL0wMYpmcFAmH3GfaVJ3sOXpVevhQCz24Cz28yTlbV9haiAMmwAs92ASztA04Vfk4IAtwqAtuNAtJSA1JfA1NiAQQDVY+AjEIDzhnwY0h4AoLRg5AC2soC2eGEE4RMpz8DhqgAMgNkEYZ0XPwAWALfaALeu3Z6AuIy7RcB8zMqAfSeAfLVigLr9gLpc3wCAur8AurnAPxKAbwC7owC65+WrZcGAu5CA4XjmHxw43GkAvMGAGwDjhmZlgL3FgORcQOSigL3mwL53AL4aZofmq6+OpshA52GAv79AR4APJ8fAJ+2AwWQA6ZtA6bcANTIAwZtoYuiCAwDDEwBIAEiB3AGZLxqCAC+BG7CFI4ethAAGng8ACYDNrIDxAwQA4yCAWYqJACM8gAkAOamCqKUCLoGIqbIBQCuBRjCBfAkREUEFn8Fbz5FRzJCKEK7X3gYX8MAlswFOQCQUyCbwDstYDkYutYONhjNGJDJ/QVeBV8FXgVfBWoFXwVeBV8FXgVfBV4FXwVeBV9NHAjejG4JCQkKa17wMgTQA7gGNsLCAMIErsIA7kcwFrkFTT5wPndCRkK9X3w+X+8AWBgzsgCNBcxyzAOm7kaBRC0qCzIdLj08fnTfccH4GckscAFy13U3HgVmBXHJyMm/CNZQYgcHBwqDXoSSxQA6P4gAChbYBuy0KgwAjMoSAwgUAOVsJEQrJlFCuELDSD8qXy5gPS4/KgnIRAUKSz9KPn8+iD53PngCkELDUElCX9JVVnFUETNyWzYCcQASdSZf5zpBIgluogppKjJDJC1CskLDMswIzANf0BUmNRAPEAMGAQYpfqTfcUE0UR7JssmzCWzI0tMKZ0FmD+wQqhgAk5QkTEIsG7BtQM4/Cjo/Sj53QkYcDhEkU05zYjM0Wui8GQqE9CQyQkYcZA9REBU6W0pJPgs7SpwzCogiNEJGG/wPWikqHzc4BwyPaPBlCnhk0GASYDQqdQZKYCBACSIlYLoNCXIXbFVgVBgIBQZk7mAcYJxghGC6YFJgmG8WHga8FdxcsLxhC0MdsgHCMtTICSYcByMKJQGAAnMBNjecWYcCAZEKv04hAOsqdJUR0RQErU3xAaICjqNWBUdmAP4ARBEHOx1egRKsEysmwbZOAFYTOwMAHBO+NVsC2RJLbBEiAN9VBnwEESVhADgAvQKhLgsWdrIgAWIBjQoDA+D0FgaxBlEGwAAky1ywYRC7aBOQCy1GDsIBwgEpCU4DYQUvLy8nJSYoMxktDSgTlABbAnVel1CcCHUmBA94TgHadRbVWCcgsLdN8QcYBVNmAP4ARBEHgQYNK3MRjhKsPzc0zrZdFBIAZsMSAGpKblAoIiLGADgAvQKhLi1CFdUClxiCAVDCWM90eY7epaIO/KAVRBvzEuASDQ8iAwHOCUEQmgwXMhM9EgBCALrVAQkAqwDoAJuRNgAbAGIbzTVzfTEUyAIXCUIrStroIyUSG4QCggTIEbHxcwA+QDQOrT8u1agjB8IQABBBLtUYIAB9suEjD8IhThzUqHclAUQqZiMC8qAPBFPz6x9sDMMNAQhDCkUABccLRAJSDcIIww1DLtWoMQrDCUMPkhroBCIOwgyYCCILwhZCAKcQwgsFGKd74wA7cgtCDEMAAq0JwwUi1/UMBQ110QaCAAfCEmIYEsMBCADxCAAAexViDRbSG/x2F8IYQgAuwgLyqMIAHsICXCcxhgABwgAC6hVDFcIr8qPCz6hCCgKlJ1IAAmIA5+QZwqViFb/LAPsaggioBRH/dwDfwqfCGOIBGsKjknl5BwKpoooAEsINGxIAA5oAbcINAAvCp0IIGkICwQionNEPAgfHqUIFAOGCL71txQNPAAPyABXCAAcCAAnCAGmSABrCAA7CCRjCjnAWAgABYgAOcgAuUiUABsIAF8IIKAANUQC6wi0AA8IADqIq8gCyYQAcIgAbwgAB8gqoAAXNCxwV4gAHogBCwgEJAGnCAAuCAB3CAAjCCagABdEAbqYZ3ACYCCgABdEAAUIAB+IAHaIIKAAGoQAJggAbMgBtIgDmwocACGIACEIAFMIDAGkCCSgABtEA45IACUILqA7L+2YAB0IAbqNATwBOAArCCwADQgAJtAM+AAciABmCAAISpwIACiIACkIACgKn8gbCAAkiAAMSABBCBwAUQgARcgAPkgAN8gANwgAZEg0WIgAVQgBuoha6AcIAwQATQgBpMhEA4VIAAkIABFkAF4IFIgAG1wAYwgQlAYIvWQBATAC2DwcUDHkALzF3AasMCGUCcyoTBgQQDnZSc2YxkCYFhxsFaTQ9A6gKuwYI3wAdAwIKdQF9eU5ZGygDVgIcRQEzBgp6TcSCWYFHADAAOAgAAgAAAFoR4gCClzMBMgB97BQYOU0IUQBeDAAIVwEOkdMAf0IEJ6wAYQDdHACcbz4mkgDUcrgA1tsBHQ/JfHoiH10kENgBj5eyKVpaVE8ZQ8mQAAAAhiM+RzAy5xieVgB5ATAsNylJIBYDN1wE/sz1AFJs4wBxAngCRhGBOs54NTXcAgEMFxkmCxsOsrMAAAMCBAICABnRAgAqAQAFBQUFBQUEBAQEBAQDBAUGBwgDBAQEBAMBASEAigCNAJI8AOcAuADZAKFDAL8ArwCqAKUA6wCjANcAoADkAQUBAADEAH4AXwDPANEBAADbAO8AjQCmAS4A5wDcANkKAAgOMTrZ2dnZu8Xh0tXTSDccAU8BWTRMAVcBZgFlAVgBSVBISm0SAVAaDA8KOT0SDQAmEyosLjE9Pz9CQkJDRBNFBSNWVlZWWFhXWC5ZWlxbWyJiZmZlZ2Ypa211dHd3d3d3d3l5eXl5eXl5eXl5e3t8e3phAEPxAEgAmQB3ADEAZfcAjQBWAFYANgJz7gCKAAT39wBjAJLxAJ4ATgBhAGP+/q8AhACEAGgAVQCwACMAtQCCAj0CQAD7AOYA/QD9AOcA/gDoAOgA5wDlAC4CeAFQAT8BPQFTAT0BPQE9ATgBNwE3ATcBGwFXFgAwDwcAAFIeER0KHB0VAI0AlQClAFAAaR8CMAB1AG4AlgMSAyQxAx5IRU4wAJACTgDGAlYCoQC/ApMCkwKTApMCkwKTAogCkwKTApMCkwKTApMCkgKSApUCnQKUApMCkwKRApECkQKQAnIB0QKUApoCkwKTApIbfhACAPsKA5oCXgI3HAFRFToC3RYPMBgBSzwYUpYBeKlBAWZeAQIDPEwBAwCWMB4flnEAMGcAcAA1AJADm8yS8LWLYQzBMhXJARgIpNx7MQsEKmEBuQDkhYeGhYeFiImJhYqNi4WMj42HjomPiZCFkYWShZORlIWVhZaJl4WYhZmFmoWbipyPnYmehQCJK6cAigRCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAqgOOANBYANYCEwD9YQD9ASAA/QD7APsA/AD72wOLKmzFAP0A+wD7APwA+yMAkGEA/QCQASAA/QCQAvMA/QCQ2wOLKmzFIwD+YQEgAP0A/QD7APsA/AD7AP4A+wD7APwA+9sDiypsxSMAkGEBIAD9AJAA/QCQAvMA/QCQ2wOLKmzFIwJKAT0CUQFAAlLIA6UC8wOl2wOLKmzFIwCQYQEgA6UAkAOlAJAC8wOlAJDbA4sqbMUjBDcAkAQ4AJANlDh0JwEzAJAHRXUKKgEEAM1hCQBbYQAFGjkJAJAJRN8AUAkAkAkAnW0/6mOd3brkH5dB9mNQ/eNThoJ1CP8EZzy46pMulzRpOAZDJDXL2yXaVtAh1MxM82zfnsL/FXSaOaxJlgv345IW0Dfon3fzkx0WByY6wfCroENsWq/bORcfBvtlWbGzP5ju+gqE1DjyFssbkkSeqLAdrCkLOfItA7XNe1PctDPFKoNd/aZ6IQq6JTB6IrDBZ5/nJIbTHMeaaIWRoDvc42ORs9KtvcQWZd+Nv1D2C/hrzaOrFUjpItLWRI4x3GmzQqZbVH5LoCEJpk3hzt1pmM7bPitwOPG8gTKLVFszSrDZyLmfq8LkwkSUhIQlN4nFJUEhU2N7NBTOGk4Y2q9A2M7ps8jcevOKfycp9u3DyCe9hCt7i5HV8U5pm5LnVnKnyzbIyAN/LU4aqT3JK+e9JsdusAsUCgAuCnc4IwbgPBg4EPGOv5gR8D+96c8fLb09f7L6ON2k+Zxe/Y0AYoZIZ8yuu1At7f70iuSFoFmyPpwDU/4lQ+mHkFmq/CwtE7A979KNdD8zaHSx4HoxWsM8vl+2brNxN0QtIUvOfNGAYyv1R5DaM1JAR0C+Ugp6/cNq4pUDyDPKJjFeP4/L1TBoOJak3PVlmDCi/1oF8k1mnzTCz15BdAvmFjQrjide74m2NW1NG/qRrzhbNwwejlhnPfRn4mIfYmXzj5Fbu3C2TUpnYg+djp65dxZJ8XhwUqJ8JYrrR4WtrHKdKjz0i77K+QitukOAZSfFIwvBr1GKYpSukYTqF4gNtgaNDqh78ZDH4Qerglo3VpTLT0wOglaX6bDNhfs04jHVcMfCHwIb+y5bAaBvh2RARFYEjxjr1xTfU09JEjdY1vfcPrPVmnBBSDPj9TcZ1V/Dz8fvy0WLWZM0JPbRL0hLSPeVoC8hgQIGaeE6AYVZnnqm62/wt00pDl5Nw/nDo+bF1tC4qo5DryXVn8ffL3kuT51e+VcBTGiibvP+vqX50dppfxyNORSr48S5WXV8fzcsgjRQH6zjl+nuUYFVloiEnZOPDpHD/7ILh3JuFCdvAi2ANXYXjTDA5Up6YLihbc7d+dBlI9+mdgr8m8+3/Dp26W/Jssn7b9/pOEP4i+/9TsPI9m2NfNKwEI35mqKV+HpZ+W69Y8sM/sIA9Ltvhd+evQTUUfSkYxki28/CBT0cT96HrlrSrE+V9RzhskX0CsDsCfHffBVybkxmHOFOgaUurWNQ2AcZbi1WjkZzYArWZBHFd1SYwtqQ0DIZt7OV40ewQxCr/LgxAc8dLJeAJFseWJq9XiOp21hLv/HhsFbYbg3zCR8JmonZjhuKYrS/KJc30vnOL2CM+GfogNWug2DstZPzauCNeeD8zlP8wxPyfLHYQB/J+wQE3aDpXH/5tdIQpLn3JXNJYZFiXInGB7FqxRxHYJ/re/lHprE5sngUMm11uOIA3bbtkk06I8DYxuwPD+e4sAeNfor0DkWmiCQFiNptkmiD2xGO1kIKGr/Tuu4bHe6z2NaS7Ih0c+Gpv+QbLY9ea122BXNSitM41sxUSlnWl+uJBIFoLqt66v/VfGIQos2lzhOOLDuScVxcyrqH3/FI4vaYB0b8gFHLXtxyX/9JpUCYNwlLZ1v5CeB99l0F795R5wl5UHRq1OYyKqsoIY07wJz2CT0TOf5/JRBPtJIIk5pOJ60SHayS9kMSKbI3fLLYztsY3B4MlSyoEfc9gL4yJVrPo+OGGunCK4p15UbCArJP/PQgUWDW4l+2P/tCqRRy2flIZL/nVeY/vyAfILUM5qEGfcFXXXrAit7skwDEFnD7mL1ATtyrz7HcodhzP7gShFhazIPm7X0+mTCeSWfrOr5WcvJfip19JRRLfXjuQpQjcNCuXo8kqkxQ68ukJQoxlnfjevc0WcKnGpUvyY54eJTS1IRWDqfHANukJLw56ts5yS6Nea7IrL6/78aKmZsch4Q694ujxgx5+0PhlGpzWimajpvkBOOUQlHLkJorzqu4e768L9nJtZWYturb7dsBxjzlNhd/gZcBuRgIUSdgZjg7Rx+f/zLcs4mAa3qDbJNUQVNbSg+dm0L3KH1uhesTPaErVYjZ8Isvfr+zfiX3DT0PlaOv+hdGvLUIlKSEcYHPMs0NtTGzyqMe74yciNFdAVZVzol/XtLsEqivKqfW7zWTCNCvZkPnnBlMv3UHW5RNNEJfuyR3MvYH/9E6gcts5GAwKIgCaBQ+V2Eh9O0IJkxFksPI1V9obqDKCpmPM55mLd+VQgRqgD+9XvsUxjbh/AXXPxOpc0FXFyJzc85aa1VQZa90LAWR4oinrBaOBr8DymCpFbdXMTn7Cv18S0hMR7T/o5VkRqN1g1/dvaDdZsRArO3bopkfee4efLF+hyVdcX4u3aNGTkWvLRafW+sXPktA1lla4UkSB7uJIULfxy/RAflk2miyw9xq9uVGgCNzqCv4iX+AUchfMkZdEgRZ9TZ+1CPTH2jXjMXjFl/+bEPzSjM7zPKKWhyZUgQG1lpp+DNz+Zz+85kD59q99U5R4B3vuI9WenCWqroy2U2Ruq6I+di5N/v9SmYnqJ5H1HLWCbIg6iVrn3s2gFBVFhrc1zzNqoFe275K3Jy1T0Mc5yeE1iRwO2b1L/j/S8jyvGDz6B3NMFEHErGHMM2+oJ5LobazyWEitdgMjQnsd0cjYrCqRpx8idpfwRq6hz/LleX6obpuJh/AGIu4sxD35hwkIEr5ShH8xro7tTDYK1GPHGylK6rp7NCG0lMr7YqwziMUBwXv0zPW667f3/IRLJRD7mkuwUP6mpkxyVjNlcBiAX12r//+WTuzWxsue7bsjRp7xFjpR2tRLqGHLvjYt3TpeybR82K61iLn+pOSWDfUv/HU8ecBtML+Gbz0v9vmlxSgZeBBzbGeP1KSqsH14ZM2kibgDhbS21hIALSOYFCE9LY+2CNvtzT2QuSJMiKP3zwvvs+/JkDwTg0jHVE0XH//U0nu5HKQtCL2KGDQYUgT7qIMVN/OoWqEz1oeG4wG7InZg47NE7rfHB2i7rkpYCUzaPfVtDYgTEPNpa8gXHI2Pp8A6YB8OYHkXDZMMcOL3rJD0Hxk+mRlsSJ12/7T52IcFst5zRc7uDJtQTXBdm9GvsvyXcBbMfKXWqsDSeEnFyPUXZGTafti4a0it8SN1qXxzBmzj+gVZ/FojNy+x73AuuqtJ/oaMZF6m5kbW6ItpfnUT/BrQunS+gLjTTUz0d8jTMpAfFQ40RQi9uM5qdFYzqk85hqSH1zsPOhiO5CN+hNZvL/RIs7m7LyLDuV80ZtyHHqVEngTVPBctHQhmcPjM30m1veDmHCXEpjybWAbgj3TqLUPNazzdHgxYmNuT7trWFcGOi7iTeL5YeK2yp2H98yoLN+skqhffZI/5n/ivceo44wJRY8bzC6DGwdgkMOulYhzW5m6OKyK2Mg+E3YE19L8ngE08TdAuNu0mIzd6kw0i03zzm4oqfVSZjZyxXnBhvt0v89EmnArya/UvHQrdQxBDAJagK2y+OqgBqzQ4FnUeiKfb7HFoUvFSknWhwq58TpBlVRZ0B0A7QWz7X4GLHcbdh5kFI/PKJ91OEh/kmnMEdh+Z23myFH8sXjR/KaHttrpz80N+bl0HM17RX48UjUWslrYHYW7oiHVgcGqTBoTrqK4JYwTTArFO1/APJ8DnEYf+wD92Dw15a9wrPxyJA88yYcv9RypzXLKAWmMuE0KAtIGjfKx1GbRQIq0AkttuRpBO7p4SGrTZuAOat3hTxXEcIKh3HgC1d88K7bz1+Jsi+y7tL/7zc0ZxCBB3hSxvP90GkUp1Lm2wuESafZyFy4Opir+o3gMWtDSuLF3LRHXTUGkKQtvARnwam8BuKv8Q2fHH/cEwPCQd3dhzgri8eTezRsQoGz6ha+S4E7ZzDB/LXwl04vA70NeVsf5rmv1TLvcQSNIBk3U6Qh6Bm+0905B91hopTLnTJRWZkUmbckEw0woG81azyw6LZaBL5Qx2HPvd3LHGLpN6mPZlto50NwW2zFOkgoPKV1gr142teD9aok2HNkPMepl3NIi78ShnAlJCzjZplteUoqz0+iUEOym1LZGGFHMBkc6/5f+sRCCFZZW6KrEby64o/ZfefQAPP6b5ko2fuujIv7uonIKXN6XiJsZmcOeGxteQ+b/ope3Z1HFeXYoW1AJrU/OiCpsyQP1Pr1BdQKFzS0oYnLCAweSnIh7qMFMRBMY7BcnJ5oskUbbRNiosqMzCYUAZPbo8tjCCsCBm5SoGcTHBMXcE+yQpl/OfBkcTw3oa4X7V+ohEh/Zkcv0cqc8sY40IsOW6lLiIrvYND/exZbRlOMgaHvb/QQKaY0k6Aamee2o3LVARCbIP4RoSd7u3CXkG+Iz6iFLfsN38F9xU4n3ueeVgiRs3jw70SMWu1QzDdiLsKtU1qvaLhv7dUbnLimdqYG+pa2aRZ8A6Q9JSr3yTs1MiAvfFHPQJTiqpI/hVUMmL6gPj6eL7lH0IkLCNcaogBA0TGfO0wO6ddf8Fju0L3YbRrWe8J3IewsNBCbpC2b6etQRJnSGLuWDiFoBez9hJHw6+bMQQGQS8YV/kzQ5AFHEqPaMgOjyR5zaHtlOBI4mjo8gdNItHUHQ7Bzq/E/xV1B+L0uoRcLIEj4hcv0yWQTwWLHzoFrvEZPygABpc4rnVjhfcBw5wOvaVVtgiG5qjklrTY1ZaXHkasyVYBd+lgo6zEHMumfK8XR2eD0cVn5w8l1uxGz2ACwtFob/CTV/TUx1kCKp+QROanLrNBiSPTxAf1eOFE+JifgAJ+pyrFqS/0wKlPWUVKlB2Bhu1Ggx2cvfdiR49VIsgBNnE75pf5lpFaQuz8+VPreUd/HLlW8kDSr25AnETsVRrOycLBPYD9/j/7Z0KKdOjtrM71AT+VsjD3D97aUDP5WrHp1DWghsk/lS/hp2VMwo0eqoEerLL/4/SlmyjStwWVDqF6jHC89niCwr1tMSe8GxeC9wjzMKmE7ZtdHOWqqc1OoTI24eVQc++crbyxSU4TxiB+vWoaAUpYQxZ06KKIPq6EvN/rN4DZ0/tQWYVqZ3FTIftPBfIuOWX3PonIKTUArpSvfmQRpkWD00wc3AQS98i4ZYaUbI+DGv90tuEKRjb2ocfdddC21YGUATYQmzelz7JqWBAQqKrWYdWEJlfPeRFZHtUm2MaISZsoOvURowxJKveGRegmBiKZ3d1cMFioJL33RoIKT0eDeK8FH/ybAhZU5TQIsWYmjyeT7EOLL5xZuRPf4qRIo6bbLtFOV6SX60fR8Smys/u1D5DjkmHJyr/woVAvBP2dxGo9gH1LgIm8XlFF1KSYvfj+0w7aTEfoFpcO+Jv3Ssbv8wwkED5JEC+jdln2dzToPNRtWiPbRb8f8G4aZX1j/2Vdbu7jM3gAVD5BKR+yJaOwLtwJodwjWu5di47tnNs9ahpnCUzVMObQfbTqMNs64MGANlgyihKjhwZ6p1Jsnro0/SfkOk6wx+HgUB6Mz9cUiF7KrJkhxnOVjCCcqPZglIojIRoDtkd2AkLNZC88GdP2qZV/1N6PBAe+fpgWZ36oHnewQ8CHdXcxbwQVjOn8U3qD9+e7FzWpg135vgdEMZ9fH5agDnNzdjKFZQ4tDsJs/S6Lk8FqjFJpHMjaRU6FI/DBDM0g+RRkxNoUvm14JAn5dgd6aVHt1aMkSXiJVenbm2FfrIEaFKHtm1erv1BJ5056ULL8AMGLmHav4yxg6F6n5oBq7bdP6zEr6f+QTDJ/KE1XfoG24JvVk2GL7Fb+me27otVFnq1e/2wEuqv6X+2zLQuJQszy5YJi/M5888fMy34L6z8ykD5sCHgzliAoAtEeoaFmnPT63kOYrZWspxYzqQBu/QKNyQ8e4QwKJUCVazmIUp6/zpLA3bWH2ch7QZN0rzWGxMRl3K1osWeETxL95TZSG/atM8LB9B92/71+g9UGWDPfD+lu/KdOQ85rocuHe91/gHA/iprG9PZ2juX49kaRxZ+1/sB3Ck35eWYBFsmCl0wC4QZWX5c5QMuSAEz1CJj0JWArSReV4D/vrgLw+EyhBB6aA4+B34PdlDaTLpm9q9Pkl+bzVWrSO+7uVrIECzsvk8RcmfmNSJretRcoI7ZcIfAqwciU9nJ8O4u1EgkcMOzC/MM2l6OYZRrGcqXCitp4LPXruVPzeD402JGV9grZyz9wJolMLC/YCcWs9CjiWv+DNRLaoSgD5M8T4PzmG8cXYM4jPo5SG1wY3QK/4wzVPrc33wI+AcGI//yXgvyBjocGrl768DMaYCGglwIit4r6t6ulwhwHJ4KeV3VHjspXXG4DIlDR2HNFvPaqkBViIvr433qZPuUINp6oi1LyVVC+EE1j6+wab8uPMeAo6e9uWYequvZynhnYazrvrDQJVkK3KZRoSR5BHi6vOC+AVCujMiQ1GVzGDZ4RFv8jFm7z5CU0iPH2JeXqUzqaKKP4P7osPkcIL99Y7fP3l+TzeFXO2kSpLIJW51oEY8DRIhqexGnxj0nmtGOseStuViIE2mJge45LENf77xjuI7egRNpzthNiajnuqikg0aQS1JqlIZf+hwSUlOp8BEQ0y3xiTOJkohBP3eyYiPDlZpFY88EWOpp4+hC/tQdhrQ56h2VJ2XA6vhPAbj+wH6iA2XYuTvRV25N8wNPQuA0Vzzem2ADZPFK2vr8l0I3GTV3fUN4S6FFYygW2Pu98f+lsgPf67rwVCbgMFAACW3P10GbxnK3SNuNK+VlPRiL7U3dK1o3spH/MFfDkgXuXjxDTxJrYctqHdwUg4rhUCNA13lGjuhJDatpFb/mExsBWS46aLFtROqVm8xQNPXK6A2rRfazJSWpIyh+FMmorXPXYnHQ7YLOmD4B5QTI8rzp7OomiarnaFs5syYjQ0ucc7g1/JzT446IFlDtpUL7DP9bLRCLJryUvi5R71/qX7ycqRSwunQ7+tfJz44Na3aJNszaMEZ/BV4iOGopabYdmvAPe+kIdGCNq5Q8fg8Ld0VNNXV0ZiiGej7zSA+pexy6wKC5k4rZa0k+qaN8bKq3oJWMQCSGaK7PrwMvA8t8BZTzjDqXcFTAIeRtl0SdlGSuAziVXItFcgAkeqwuNsbsrUZFcU6KUZLmvG415kHa0AwMFW2cNSUvPR0U9iCPh0nyslT92B5slYXiDWeSXvxHXItvjI8z5KCIVTIHqGZsbDBTr7WdHzcUAI1ipR86H3o0p2wPhfp7xg9oWOxWIK4a5BWdaV9OAPc0XuvlbwitCVtZDzZxGhIOl77ZgrRYR7LZQFE+Ih23hW3gI914ekkjgbKCi2bsqSAvij6GGj5p+k6evQtJp3qVh9vg+jiJvFCGcKBCITMWpqHZNKfE6IT0dKntS0rhu0DB5D9qIS0/RboNLsx2DlRMlx1QIBeBpHJNKdCL9uWM9eS7RJXKNOpraULtutuJYOl0apdE4LxfsyRSZb6fJkd51SHrI7lLB4vEg4fifJ1dqcWSeY4DgcyjrUcymK+gd3o+qj+3gHKWlLVdMUr3IeF8aClYBq+eeCV9Y7n1Ye8yL7rEvxY7jAlLwucKQ51pu59N8we8XwrbXPChBHXP4LnD3kDwQ85w1DKghtwvpO609fZOrPq8Q7GOOAjHhfR5VqvpoFne8oMHbCrWb1L0IdATo+h1PFeLLI8wc+FEyftLvskCdOtxKfAx3IEJXzBfWTKq5viKP/uu99dxnEpoNJhRtjSZGwOTWr7Ys44++P58O+nkYxd1Gcqm8G3Gh7AHSCxiPNyJWijI/lECrKrAXgBqkRShvdkd7IfoqUlziFDiglx+jdHnmRVmGnk3p/3n78M/HkzFUGZOS07cPnPn9jAnBWl4qDrB1ECf9idIKOdkJTKcZ690nuLW2yDsqwNpgrlT+wx2gv+Engha74lfVqbwqS15FRwuFDfq3bVCZcPy78TL2pH/DOdHeL9MFAtyybQNwHaO781rnJZAhR4M+AYWoSoa0EjQ99xivreM+FKwd7Jp/FC2vvvcq1z3RnRau/BM5KGkBPBSUBOzTNdfaJS/PWTDb1jRSgn2MuY3pVZbY9peHBVI3Ce/u70hg4f7MCVeAjYJfzTkDVLuB6jyjZs5Kko3u39ozgLK4LuwSbUrNIU5cl6Bs3De62AE084XRsm64Gs5W1ofxsWIZ9cYl8PNa5zQHl9ls5aiIKN0rHIIzBnLr03Kle2qq+n/gLDAzvF89vdZCvUFEHRoi9n33O3i49UWyeHP+ZAeRf+psM867nfqON092zE4Pj7AbLtvIUFJFr1y9Le0CL2flc7LUqbgGzOw4/q3vA/cJO5JeI8S+8bc1Y7pqYSzoEWSFn5G7EoPHTGHPMU6SeLKEeli+i8dHY3lWxSrIOU2y0TNo1SeRYewhVx05OXeVDf0xhHNckqp0arRk+bgToeSaHbVZ5nj3IH3m2oayt3sXY78qSPcDpc/5C7VXDRj6bROvvBG5JCsKl/yeMPAUn1flMsmr/FaFdb7gVUXnhLa+/Ilj87PpCC6rILQ6wkIP1ywEg0PztSEzbsJoRwQzDaxkiTN27YDnsy/YKfe6jKcqZWs64skzUAHIt+nXxju0dUVtbCSDAUXYw78Yd4bJKuYU8gbzLzgL4XIUC2HcPIVCUYvM7cybOBFVBdeGR4cOVB7QbGnohTRpiPrGqi1a8QXFBYqENawROuR43OG8dl+Jx4TpwAoi2kkPXW7b/ARSs4DO/z4H6oTIUpN3+/K6Iuc49C4/Uf1NxQTEE91VP8RnLKTpxjywMe2VxM1l4YGXSFY80HUAKIdqczBnnLMPklFV8mrr5hFDypn5TAT00ruU6AjDPNvncoVzX4ac6wAzTwrNH7oz1XLH1wzjQs5k7hcNLbznXQGB7M+rXxKtZXPrz1Ar+OxYGDkJvElknZsHD/IcxRd7ujmmLYpDDbverynroCnSKVQWEGjHL57PaI/WokvhYRpPMk4ni2EUhjDuIF+IU2R0fs40i+66bw8sz8OzyC2eFAxxicd2n5Juta2eWa9KtObD7xLmPvtK+8cjQt+NLjcZCTt+Ss9p1od0bklVgaIV1qJbWxUOr6iUzLDzFefYxAtyRcBr53IaDB25n60KQdhroQWMUpuWSUpELSFxiu4vgQeRoEZe78/ua3TlrszB8sLVZoecnV9YMYz+HkZA/pLqbFhzurB52Wl/WEM6sVk4q04OnzWZFi76JkcGgeeUyYUIwhCDMdIfTUdD4wQpYm3LBw0sp33CVK2q305jeyzgGnBzSMXjesm4XjcEhhrjPSLtwqqoaFCqD5DlHYhoTVafWtBUQXoNfDk19IFxq8sImCcqgMhOToIZUO2530aasY908dMX2nTMFjgv+lapdI8k/e0a7pFw6X3Tgf0m99bbCpOzVgRu2Dw/13CehVfFj+8BeKP6SZV4g/qiX42NWP568PzMajFm2ANmKtHjEIAIc2hc1iecBR9elGP4LmAQwAVmZT8kWc7JSY0ag583ch/Z16krGrjn2YdIaa22egy4/niU6m0WAG3K/yP65cfL//CP+JzcnoLHQFb/KJQeBrEbR1/IKo+YOFXWIQ8ghNxYdMwa49NeXzFqFOIXTmk3w/v5KneS8sGHiPGACh0DE9a1uLAochB79g3IqYObhlswemMucZnAE7dBkp5OAfToa5gHFbIPcec0fVWEOOLftQXsuffyv3wo1LWDDm+SyNMWgSEWtjMyYkjLjTkUtmj7DQlfbpHf38lDvoEN9d2ALxnWCjph4jvfEIRbHvltKbvE2BiYlz45mnJPeFrwZcBny3k0/pyXNrSbEIWvvZw14Y0Fqy4tba1Fu0yNNYaf47jfnz7VCCxKsrJz5oz3F8jXUdQqFu+gDq6EzvKDipXf/3NmcsCC74VB3OgHPgN7W9cU54pjGFDMfifl3m5Vhy21uk1U2nYCrddrifkpwGLYmLSSQAAjC6M3yB1fc6KHpgDnMXh2bYX2ns+Qma+DBgyCkZ0TqZK8Mp2Sryx7HdMM74X9hrwYhQbwlK+zgATAXRzQyS+hK4OTnP17/cyJ2WzY6DChYWGJYXGCnEdMswF5VTYQdSyTpdLXYuh+x2Qr7DR3H2x+YdP0qsLAzYJIWKwrrKkpBgWCmgNCn5t+QbWqf/LoLuvjgDFLtMoxNK5axIA9kammelvwh5ZI52ktrEm/OVEESPQPZGHAIhP7oWDBnGnuzG45XOTpZWsxwNO4UiyxH8riTvQq4JVq5GwX3yqVCbSR0ef/gVYDgiYaiD2EAAxuEPKyXTp/HhL96eVTpaDqFEoV2x1PP/UMcs/XqeGc1gZQG1ot6YxaIEWHanYavH9YdLFjlyU5yrYALVg/sxBjT39oD+BIXvf4LTbvvvpX3srxckEX1XAM9s2uajUTlpPq32mcx4T+sibdQEHQV2WmgwMhbYovh7WWTPfLF03ZbV5a+ElsSIyH6kgJ8+D6aN/6f+ZstkZOYZYx9GbagcrEqwNblz0iZ9NTyvIAeNn3Oup7rtyD4wVE0PoqcnR/LoSK1s1esmOGPjs3zHB8xW4iL8IrhqAJfsWNBYW9TGR11C3KZJaN7MP4O5Ykmpvw94hHzVmsYA68RQdFYfPlFOgCNBoSdy5ODcv11l9bLs135M4okEc4/e8hQczcz2PWipIVSBxa/5sr9xyTFbjG4xm8f4LmrAhD1uEDGrFDl/6X7Nw7/WZPW7fZJGYN8eZ68Td5KGfJyKjD+pTysvTi+8Q8R0L9wKAxAUrYswdvAuiNeenxSplQZjYTxbcH/wP97fOY215SozY3UDRhv7lomztURB2O2UriTX3oAiTKoInkHQietZyhBQ9wMTVHgMrxOP5T/0gN14eFTz0m2D6/iJMbXYGHdIkKEGV2Voa8k/hVNvAVAZKrDEXthUxotwYkYysTDk8j27XEVy+4a30jopuAp5+/xWYb0ne6lwKZwR3j6kDXroOOtrHqWlkJHSWLoPEQJQo/ARzR8UBZSckmeBPn3gJwY62Zo2dyy1AyRRDQBFAJKH9KX+7auP8U8XDo7mMSzq5ZxmaJ5bLpNg4ZM7938SAjMHcu1yB4+lkHnVLnIp86AOPgigH+ZFDRq1QuKWK3pK5JkLDJdakj176NCbjXDASt1h/t1p+GHyKbAoevHSnHuPfoBmQ3nJrDjOhPfwVYi8V5r0KB8BsrfFu8BvhYCbNrvCVnd4Q8RktqIR/ZilioC6g3++L7PHzuXa8NFSF5zd+ISzGLTjrfaKXsBFCkkK0ksSDbl91yXUghMFOskQBeUoo7o3wuIsE29goRIORuJ4b1jSumvR0gR8B21iyW1G4FqHkZOlWz9zq5FnaJX1WbeAxe2DfGSAnw4cqDwg3LFalk6eH89Sdc41Fr6voEa0hfwdkb54yOM7WevDugT1FRzEqdg9zZZ44ZAKGH3ZyqFve3SE4UDN6tLmIFTdIwMrtYRXWBQDB7vvqOuYj7cN31av64+jg/g1uce+am3TOl0cUUL6s0l35FJ9p8vJcG+G8lAFqC0pdmd/aaWYpqDLvB5LEasLMgbPN2N+Wvkh6HYxPOrZEfoxQX/67AzcWOR0K3eYGOgQhyWL7cwKGlxmY/E2b8CKi6Ssgok+7B+zTtq/DXmaDAHRnwbwvCDJ9pITO5RQgBuprEWT0avZv7QjbzITYD8Fzgy4TSYG3z9tLso0Z7MfgHDLKU+kHrzxWkBPwJRydKMXG4AaCA7mlAmjzpNhGOrMGZGZlHSjPbmO5jPd/lKBrViZ0BaXMmqaFOwA/f03O04qQX6MSVA37+SA5Pne/KP7caLJKuOCJXoXpzArUrYesMVc/RXnOv03YrwKgPlR2SjpqIycyulmodZBy6gVc1jA9y6lJqWgR6SY6tc24sVcYuh2GaTeikYJnhr2d6BiL3oLx8M8wuJBdI3FRVIIAx4XougScOw2xWgwUoSYKeLUHc310kVBzSE/vFeHAjlUil8KZftctMgwGjwrhMbjDbK4rB32fTe9jnsqijdp5kOwkD9+klel+lNh3joAFQ');
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, '0');
}
function quote_cp(cp) {
  return "{".concat(hex_cp(cp), "}"); // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) {
  // this is about 2x faster
  var cps = [];
  for (var pos = 0, len = s.length; pos < len;) {
    var cp = s.codePointAt(pos);
    pos += cp < 0x10000 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  var chunk = 4096;
  var len = cps.length;
  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));
  var buf = [];
  for (var _i35 = 0; _i35 < len;) {
    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(_i35, _i35 += chunk))));
  }
  return buf.join('');
}
function compare_arrays(a, b) {
  var n = a.length;
  var c = n - b.length;
  for (var _i36 = 0; c == 0 && _i36 < n; _i36++) c = a[_i36] - b[_i36];
  return c;
}

// reverse polyfill

function nf(cps, form) {
  return explode_cp(str_from_cps(cps).normalize(form));
}
function nfc(cps) {
  return nf(cps, 'NFC');
}
function nfd(cps) {
  return nf(cps, 'NFD');
}

//const t0 = performance.now();

var STOP = 0x2E;
var FE0F = 0xFE0F;
var STOP_CH = '.';
var UNIQUE_PH = 1;
var HYPHEN = 0x2D;
function read_set() {
  return new Set(read_sorted(r));
}
var MAPPED = new Map(read_mapped(r));
var IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints
/*
// direct include from payload is smaller that the decompression code
const FENCED = new Map(read_array_while(() => {
	let cp = r();
	if (cp) return [cp, read_str(r())];
}));
*/
var CM = read_set();
var ESCAPE = read_set(); // characters that should not be printed
var NFC_CHECK = read_set();
var CHUNKS = read_sorted_arrays(r);
function read_chunked() {
  // deduplicated sets + uniques
  return new Set([read_sorted(r).map(function (i) {
    return CHUNKS[i];
  }), read_sorted(r)].flat(2));
}
var UNRESTRICTED = r();
var GROUPS = read_array_while(function (i) {
  // minifier property mangling seems unsafe
  // so these are manually renamed to single chars
  var N = read_array_while(r).map(function (x) {
    return x + 0x60;
  });
  if (N.length) {
    var _R = i >= UNRESTRICTED; // first arent restricted
    N[0] -= 32; // capitalize
    N = str_from_cps(N);
    if (_R) N = "Restricted[".concat(N, "]");
    var P = read_chunked(); // primary
    var Q = read_chunked(); // secondary
    var V = [].concat(_toConsumableArray(P), _toConsumableArray(Q)).sort(function (a, b) {
      return a - b;
    }); // derive: sorted valid
    var M = r() - 1; // combining mark
    // code currently isn't needed
    /*if (M < 0) { // whitelisted
    	M = new Map(read_array_while(() => {
    		let i = r();
    		if (i) return [V[i-1], read_array_while(() => {
    			let v = read_array_while(r);
    			if (v.length) return v.map(x => x-1);
    		})];
    	}));
    }*/
    return {
      N: N,
      P: P,
      M: M,
      R: _R,
      V: new Set(V)
    };
  }
});
var WHOLE_VALID = read_set();
var WHOLE_MAP = new Map();
// decode compressed wholes
[].concat(_toConsumableArray(WHOLE_VALID), _toConsumableArray(read_set())).sort(function (a, b) {
  return a - b;
}).map(function (cp, i, v) {
  var d = r();
  var w = v[i] = d ? v[i - d] : {
    V: [],
    M: new Map()
  };
  w.V.push(cp); // add to member set
  if (!WHOLE_VALID.has(cp)) {
    WHOLE_MAP.set(cp, w); // register with whole map
  }
});
// compute confusable-extent complements
var _iterator4 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),
  _step4;
try {
  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
    var _step4$value = _step4.value,
      V = _step4$value.V,
      M = _step4$value.M;
    // connect all groups that have each whole character
    var recs = [];
    var _iterator53 = _createForOfIteratorHelper(V),
      _step53;
    try {
      var _loop9 = function _loop9() {
        var cp = _step53.value;
        var gs = GROUPS.filter(function (g) {
          return g.V.has(cp);
        });
        var rec = recs.find(function (_ref48) {
          var G = _ref48.G;
          return gs.some(function (g) {
            return G.has(g);
          });
        });
        if (!rec) {
          rec = {
            G: new Set(),
            V: []
          };
          recs.push(rec);
        }
        rec.V.push(cp);
        gs.forEach(function (g) {
          return rec.G.add(g);
        });
      };
      for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
        _loop9();
      }
      // per character cache groups which are not a member of the extent
    } catch (err) {
      _iterator53.e(err);
    } finally {
      _iterator53.f();
    }
    var _union = recs.flatMap(function (_ref47) {
      var G = _ref47.G;
      return _toConsumableArray(G);
    });
    var _loop8 = function _loop8() {
      var _recs$_i = _recs[_i92],
        G = _recs$_i.G,
        V = _recs$_i.V;
      var complement = new Set(_union.filter(function (g) {
        return !G.has(g);
      }));
      var _iterator54 = _createForOfIteratorHelper(V),
        _step54;
      try {
        for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
          var cp = _step54.value;
          M.set(cp, complement);
        }
      } catch (err) {
        _iterator54.e(err);
      } finally {
        _iterator54.f();
      }
    };
    for (var _i92 = 0, _recs = recs; _i92 < _recs.length; _i92++) {
      _loop8();
    }
  }
} catch (err) {
  _iterator4.e(err);
} finally {
  _iterator4.f();
}
var union = new Set(); // exists in 1+ groups
var multi = new Set(); // exists in 2+ groups
var _iterator5 = _createForOfIteratorHelper(GROUPS),
  _step5;
try {
  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
    var g = _step5.value;
    var _iterator55 = _createForOfIteratorHelper(g.V),
      _step55;
    try {
      for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
        var cp = _step55.value;
        (union.has(cp) ? multi : union).add(cp);
      }
    } catch (err) {
      _iterator55.e(err);
    } finally {
      _iterator55.f();
    }
  }
  // dual purpose WHOLE_MAP: return placeholder if unique non-confusable
} catch (err) {
  _iterator5.e(err);
} finally {
  _iterator5.f();
}
var _iterator6 = _createForOfIteratorHelper(union),
  _step6;
try {
  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
    var _cp = _step6.value;
    if (!WHOLE_MAP.has(_cp) && !multi.has(_cp)) {
      WHOLE_MAP.set(_cp, UNIQUE_PH);
    }
  }
} catch (err) {
  _iterator6.e(err);
} finally {
  _iterator6.f();
}
var VALID = new Set([].concat(_toConsumableArray(union), _toConsumableArray(nfd(union)))); // possibly valid

// decode emoji
var EMOJI_SORTED = read_sorted(r);
//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed
var EMOJI_ROOT = read_emoji_trie([]);
function read_emoji_trie(cps) {
  var B = read_array_while(function () {
    var keys = read_sorted(r).map(function (i) {
      return EMOJI_SORTED[i];
    });
    if (keys.length) return read_emoji_trie(keys);
  }).sort(function (a, b) {
    return b.Q.size - a.Q.size;
  }); // sort by likelihood
  var temp = r();
  var V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)
  temp = temp / 3 | 0;
  var F = temp & 1; // allow FE0F
  temp >>= 1;
  var S = temp & 1; // save
  var C = temp & 2; // check
  return {
    B: B,
    V: V,
    F: F,
    S: S,
    C: C,
    Q: new Set(cps)
  };
}
//console.log(performance.now() - t0);

// free tagging system
var Emoji = /*#__PURE__*/function (_Array2) {
  _inherits(Emoji, _Array2);
  var _super22 = _createSuper(Emoji);
  function Emoji() {
    _classCallCheck(this, Emoji);
    return _super22.apply(this, arguments);
  }
  _createClass(Emoji, [{
    key: "is_emoji",
    get: function get() {
      return true;
    }
  }]);
  return Emoji;
}( /*#__PURE__*/_wrapNativeSuper(Array)); // create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
function safe_str_from_cps(cps) {
  var quoter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : quote_cp;
  //if (Number.isInteger(cps)) cps = [cps];
  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
  var buf = [];
  if (is_combining_mark(cps[0])) buf.push('◌');
  var prev = 0;
  var n = cps.length;
  for (var _i37 = 0; _i37 < n; _i37++) {
    var cp = cps[_i37];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, _i37)));
      buf.push(quoter(cp));
      prev = _i37 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join('');
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
  return (should_escape(cp) ? '' : "\"".concat(safe_str_from_cps([cp]), "\" ")) + quote_cp(cp);
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error('invalid label extension');
  }
}
function check_leading_underscore(cps) {
  var UNDERSCORE = 0x5F;
  for (var _i38 = cps.lastIndexOf(UNDERSCORE); _i38 > 0;) {
    if (cps[--_i38] !== UNDERSCORE) {
      throw new Error('underscore allowed only at start');
    }
  }
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
  var cp = cps[0];
  var prev = FENCED.get(cp);
  if (prev) throw error_placement("leading ".concat(prev));
  var n = cps.length;
  var last = -1;
  for (var _i39 = 1; _i39 < n; _i39++) {
    cp = cps[_i39];
    var match = FENCED.get(cp);
    if (match) {
      if (last == _i39) throw error_placement("".concat(prev, " + ").concat(match));
      last = _i39 + 1;
      prev = match;
    }
  }
  if (last == n) throw error_placement("trailing ".concat(prev));
}

// note: set(s) cannot be exposed because they can be modified
function is_combining_mark(cp) {
  return CM.has(cp);
}
function should_escape(cp) {
  return ESCAPE.has(cp);
}
function ens_normalize_fragment(frag, decompose) {
  var nf = decompose ? nfd : nfc;
  return frag.split(STOP_CH).map(function (label) {
    return str_from_cps(process(explode_cp(label), nf).flatMap(function (x) {
      return x.is_emoji ? filter_fe0f(x) : x;
    }));
  }).join(STOP_CH);
}
function ens_normalize(name) {
  return flatten(ens_split(name));
}
function ens_beautify(name) {
  var split = ens_split(name, true);
  // this is experimental
  var _iterator7 = _createForOfIteratorHelper(split),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _step7.value,
        type = _step7$value.type,
        _output = _step7$value.output,
        error = _step7$value.error;
      if (error) continue;

      // replace leading/trailing hyphen
      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
      // not exactly the same in every font, but very similar: "-" vs "‐"
      /*
      const UNICODE_HYPHEN = 0x2010;
      // maybe this should replace all for visual consistancy?
      // `node tools/reg-count.js regex ^-\{2,\}` => 592
      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
      let end = output.length-1;
      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
      */
      // 20230123: WHATWG URL uses "CheckHyphens" false
      // https://url.spec.whatwg.org/#idna

      // ξ => Ξ if not greek
      if (type !== 'Greek') {
        var prev = 0;
        while (true) {
          var next = _output.indexOf(0x3BE, prev);
          if (next < 0) break;
          _output[next] = 0x39E;
          prev = next + 1;
        }
      }

      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
      // could be fixed with special case for: 2D (.) + 200E (LTR)
      //output.splice(0, 0, 0x200E);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  return flatten(split);
}
function ens_split(name, preserve_emoji) {
  var offset = 0;
  // https://unicode.org/reports/tr46/#Validity_Criteria 4.1 Rule 4
  // "The label must not contain a U+002E ( . ) FULL STOP."
  return name.split(STOP_CH).map(function (label) {
    var input = explode_cp(label);
    var info = {
      input: input,
      offset: offset // codepoint, not substring!
    };

    offset += input.length + 1; // + stop
    var norm;
    try {
      var tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]
      var token_count = tokens.length;
      var type;
      if (!token_count) {
        // the label was effectively empty (could of had ignored characters)
        // 20230120: change to strict
        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
        //norm = [];
        //type = 'None'; // use this instead of next match, "ASCII"
        throw new Error("empty label");
      } else {
        var chars = tokens[0];
        var emoji = token_count > 1 || chars.is_emoji;
        if (!emoji && chars.every(function (cp) {
          return cp < 0x80;
        })) {
          // special case for ascii
          norm = chars;
          check_leading_underscore(norm);
          // only needed for ascii
          // 20230123: matches matches WHATWG, see note 3.3
          check_label_extension(norm);
          // cant have fenced
          // cant have cm
          // cant have wholes
          // see derive: assert ascii fast path
          type = 'ASCII';
        } else {
          if (emoji) {
            // there is at least one emoji
            info.emoji = true;
            chars = tokens.flatMap(function (x) {
              return x.is_emoji ? [] : x;
            }); // all of the nfc tokens concat together
          }

          norm = tokens.flatMap(function (x) {
            return !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x;
          });
          check_leading_underscore(norm);
          if (!chars.length) {
            // theres no text, just emoji
            type = 'Emoji';
          } else {
            if (CM.has(norm[0])) throw error_placement('leading combining mark');
            for (var _i40 = 1; _i40 < token_count; _i40++) {
              // we've already checked the first token
              var cps = tokens[_i40];
              if (!cps.is_emoji && CM.has(cps[0])) {
                // every text token has emoji neighbors, eg. EtEEEtEt...
                throw error_placement("emoji + combining mark: \"".concat(str_from_cps(tokens[_i40 - 1]), " + ").concat(safe_str_from_cps([cps[0]]), "\""));
              }
            }
            check_fenced(norm);
            var unique = _toConsumableArray(new Set(chars));
            var _determine_group = determine_group(unique),
              _determine_group2 = _slicedToArray(_determine_group, 1),
              g = _determine_group2[0]; // take the first match
            // see derive: "Matching Groups have Same CM Style"
            // alternative: could form a hybrid type: Latin/Japanese/...	
            check_group(g, chars); // need text in order
            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
            type = g.N;
            // 20230121: consider exposing restricted flag
            // it's simpler to just check for 'Restricted'
            // or even better: type.endsWith(']')
            //if (g.R) info.restricted = true;
          }
        }
      }

      info.type = type;
    } catch (err) {
      info.error = err; // use full error object
    }

    info.output = norm;
    return info;
  });
}
function check_whole(group, unique) {
  var maker;
  var shared = []; // TODO: can this be avoided?
  var _iterator8 = _createForOfIteratorHelper(unique),
    _step8;
  try {
    var _loop3 = function _loop3() {
      var cp = _step8.value;
      var whole = WHOLE_MAP.get(cp);
      if (whole === UNIQUE_PH) return {
        v: void 0
      }; // unique, non-confusable
      if (whole) {
        var set = whole.M.get(cp); // groups which have a character that look-like this character
        maker = maker ? maker.filter(function (g) {
          return set.has(g);
        }) : _toConsumableArray(set);
        if (!maker.length) return {
          v: void 0
        }; // confusable intersection is empty
      } else {
        shared.push(cp);
      }
    };
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _ret = _loop3();
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  if (maker) {
    // we have 1+ confusable
    // check if any of the remaning groups
    // contain the shared characters too
    var _iterator9 = _createForOfIteratorHelper(maker),
      _step9;
    try {
      var _loop2 = function _loop2() {
        var g = _step9.value;
        if (shared.every(function (cp) {
          return g.V.has(cp);
        })) {
          throw new Error("whole-script confusable: ".concat(group.N, "/").concat(g.N));
        }
      };
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
  var groups = GROUPS;
  var _iterator10 = _createForOfIteratorHelper(unique),
    _step10;
  try {
    var _loop4 = function _loop4() {
      var cp = _step10.value;
      // note: we need to dodge CM that are whitelisted
      // but that code isn't currently necessary
      var gs = groups.filter(function (g) {
        return g.V.has(cp);
      });
      if (!gs.length) {
        if (groups === GROUPS) {
          // the character was composed of valid parts
          // but it's NFC form is invalid
          throw error_disallowed(cp); // this should be rare
        } else {
          // there is no group that contains all these characters
          // throw using the highest priority group that matched
          // https://www.unicode.org/reports/tr39/#mixed_script_confusables
          throw error_group_member(groups[0], cp);
        }
      }
      groups = gs;
      if (gs.length == 1) return "break"; // there is only one group left
    };
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _ret2 = _loop4();
      if (_ret2 === "break") break;
    }
    // there are at least 1 group(s) with all of these characters
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  return groups;
}

// throw on first error
function flatten(split) {
  return split.map(function (_ref6) {
    var input = _ref6.input,
      error = _ref6.error,
      output = _ref6.output;
    if (error) {
      // don't print label again if just a single label
      var msg = error.message;
      throw new Error(split.length == 1 ? msg : "Invalid label \"".concat(safe_str_from_cps(input), "\": ").concat(msg));
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  // TODO: add cp to error?
  return new Error("disallowed character: ".concat(quoted_cp(cp)));
}
function error_group_member(g, cp) {
  var quoted = quoted_cp(cp);
  var gg = GROUPS.find(function (g) {
    return g.P.has(cp);
  });
  if (gg) {
    quoted = "".concat(gg.N, " ").concat(quoted);
  }
  return new Error("illegal mixture: ".concat(g.N, " + ").concat(quoted));
}
function error_placement(where) {
  return new Error("illegal placement: ".concat(where));
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
function check_group(g, cps) {
  var V = g.V,
    M = g.M;
  var _iterator11 = _createForOfIteratorHelper(cps),
    _step11;
  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var cp = _step11.value;
      if (!V.has(cp)) {
        throw error_group_member(g, cp);
      }
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
  if (M >= 0) {
    // we know it can't be cm leading
    // we know the previous character isn't an emoji
    var decomposed = nfd(cps);
    for (var _i41 = 1, e = decomposed.length; _i41 < e; _i41++) {
      if (CM.has(cps[_i41])) {
        var _j4 = _i41 + 1;
        while (_j4 < e && CM.has(cps[_j4])) _j4++;
        if (_j4 - _i41 > M) {
          throw new Error("too many combining marks: ".concat(g.N, " \"").concat(str_from_cps(cps.slice(_i41 - 1, _j4)), "\" (").concat(_j4 - _i41, "/").concat(M, ")"));
        }
        _i41 = _j4;
      }
    }
  }
  // *** this code currently isn't needed ***
  /*
  let cm_whitelist = M instanceof Map;
  for (let i = 0, e = cps.length; i < e; ) {
  	let cp = cps[i++];
  	let seqs = cm_whitelist && M.get(cp);
  	if (seqs) { 
  		// list of codepoints that can follow
  		// if this exists, this will always be 1+
  		let j = i;
  		while (j < e && CM.has(cps[j])) j++;
  		let cms = cps.slice(i, j);
  		let match = seqs.find(seq => !compare_arrays(seq, cms));
  		if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
  		i = j;
  	} else if (!V.has(cp)) {
  		// https://www.unicode.org/reports/tr39/#mixed_script_confusables
  		let quoted = quoted_cp(cp);
  		for (let cp of cps) {
  			let u = UNIQUE.get(cp);
  			if (u && u !== g) {
  				// if both scripts are restricted this error is confusing
  				// because we don't differentiate RestrictedA from RestrictedB 
  				if (!u.R) quoted = `${quoted} is ${u.N}`;
  				break;
  			}
  		}
  		throw new Error(`disallowed ${g.N} character: ${quoted}`);
  		//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
  		//throw new Error(`${g.N} does not allow: ${quoted}`);
  	}
  }
  if (!cm_whitelist) {
  	let decomposed = nfd(cps);
  	for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
  		if (CM.has(cps[i])) {
  			let j = i + 1;
  			while (j < e && CM.has(cps[j])) j++;
  			if (j - i > M) {
  				throw new Error(`too many combining marks: "${str_from_cps(cps.slice(i-1, j))}" (${j-i}/${M})`);
  			}
  			i = j;
  		}
  	}
  }
  */
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abc💩d") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
function process(input, nf) {
  var ret = [];
  var chars = [];
  input = input.slice().reverse(); // flip so we can pop
  while (input.length) {
    var emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(emoji);
    } else {
      var cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        var cps = MAPPED.get(cp);
        if (cps) {
          var _chars;
          (_chars = chars).push.apply(_chars, _toConsumableArray(cps));
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter(function (cp) {
    return cp != FE0F;
  });
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// allows optional FE0F
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
  var node = EMOJI_ROOT;
  var emoji;
  var saved;
  var stack = [];
  var pos = cps.length;
  if (eaten) eaten.length = 0; // clear input buffer (if needed)
  var _loop5 = function _loop5() {
    var cp = cps[--pos];
    node = node.B.find(function (x) {
      return x.Q.has(cp);
    });
    if (!node) return "break";
    if (node.S) {
      // remember
      saved = cp;
    } else if (node.C) {
      // check exclusion
      if (cp === saved) return "break";
    }
    stack.push(cp);
    if (node.F) {
      stack.push(FE0F);
      if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F
    }

    if (node.V) {
      // this is a valid emoji (so far)
      emoji = conform_emoji_copy(stack, node);
      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // copy input (if needed)
      cps.length = pos; // truncate
    }
  };
  while (pos) {
    var _ret3 = _loop5();
    if (_ret3 === "break") break;
  }
  /*
  // *** this code currently isn't needed ***
  if (!emoji) {
  	let cp = cps[cps.length-1];
  	if (EMOJI_SOLO.has(cp)) {
  		if (eaten) eaten.push(cp);
  		emoji = Emoji.of(cp);
  		cps.pop();
  	}
  }
  */
  return emoji;
}

// create a copy and fix any unicode quirks
function conform_emoji_copy(cps, node) {
  var copy = Emoji.from(cps); // copy stack
  if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)
  return copy;
}

// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
  // *** this code currently isn't needed ***
  //let ret = [...EMOJI_SOLO].map(x => [x]);
  var ret = [];
  build(EMOJI_ROOT, []);
  return ret.sort(compare_arrays);
  function build(node, cps, saved) {
    if (node.S) {
      saved = cps[cps.length - 1];
    } else if (node.C) {
      if (saved === cps[cps.length - 1]) return;
    }
    if (node.F) cps.push(FE0F);
    if (node.V) ret.push(conform_emoji_copy(cps, node));
    var _iterator12 = _createForOfIteratorHelper(node.B),
      _step12;
    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var br = _step12.value;
        var _iterator13 = _createForOfIteratorHelper(br.Q),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var cp = _step13.value;
            build(br, [].concat(_toConsumableArray(cps), [cp]), saved);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
  }
}

// ************************************************************
// tokenizer 

var TY_VALID = 'valid';
var TY_MAPPED = 'mapped';
var TY_IGNORED = 'ignored';
var TY_DISALLOWED = 'disallowed';
var TY_EMOJI = 'emoji';
var TY_NFC = 'nfc';
var TY_STOP = 'stop';
function ens_tokenize(name) {
  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref7$nf = _ref7.nf,
    nf = _ref7$nf === void 0 ? true : _ref7$nf;
  var input = explode_cp(name).reverse();
  var eaten = [];
  var tokens = [];
  while (input.length) {
    var emoji = consume_emoji_reversed(input, eaten);
    if (emoji) {
      tokens.push({
        type: TY_EMOJI,
        emoji: emoji,
        input: eaten.slice(),
        cps: filter_fe0f(emoji)
      });
    } else {
      var cp = input.pop();
      if (cp == STOP) {
        tokens.push({
          type: TY_STOP,
          cp: cp
        });
      } else if (VALID.has(cp)) {
        tokens.push({
          type: TY_VALID,
          cps: [cp]
        });
      } else if (IGNORED.has(cp)) {
        tokens.push({
          type: TY_IGNORED,
          cp: cp
        });
      } else {
        var cps = MAPPED.get(cp);
        if (cps) {
          tokens.push({
            type: TY_MAPPED,
            cp: cp,
            cps: cps.slice()
          });
        } else {
          tokens.push({
            type: TY_DISALLOWED,
            cp: cp
          });
        }
      }
    }
  }
  if (nf) {
    for (var _i42 = 0, start = -1; _i42 < tokens.length; _i42++) {
      var token = tokens[_i42];
      if (is_valid_or_mapped(token.type)) {
        if (requires_check(token.cps)) {
          // normalization might be needed
          var end = _i42 + 1;
          for (var pos = end; pos < tokens.length; pos++) {
            // find adjacent text
            var _tokens$pos = tokens[pos],
              type = _tokens$pos.type,
              _cps = _tokens$pos.cps;
            if (is_valid_or_mapped(type)) {
              if (!requires_check(_cps)) break;
              end = pos + 1;
            } else if (type !== TY_IGNORED) {
              // || type !== TY_DISALLOWED) { 
              break;
            }
          }
          if (start < 0) start = _i42;
          var slice = tokens.slice(start, end);
          var cps0 = slice.flatMap(function (x) {
            return is_valid_or_mapped(x.type) ? x.cps : [];
          }); // strip junk tokens
          var _cps2 = nfc(cps0);
          if (compare_arrays(_cps2, cps0)) {
            // bundle into an nfc token
            tokens.splice(start, end - start, {
              type: TY_NFC,
              input: cps0,
              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
              cps: _cps2,
              tokens0: collapse_valid_tokens(slice),
              tokens: ens_tokenize(str_from_cps(_cps2), {
                nf: false
              })
            });
            _i42 = start;
          } else {
            _i42 = end - 1; // skip to end of slice
          }

          start = -1; // reset
        } else {
          start = _i42; // remember last
        }
      } else if (token.type !== TY_IGNORED) {
        // 20221024: is this correct?
        start = -1; // reset
      }
    }
  }

  return collapse_valid_tokens(tokens);
}
function is_valid_or_mapped(type) {
  return type == TY_VALID || type == TY_MAPPED;
}
function requires_check(cps) {
  return cps.some(function (cp) {
    return NFC_CHECK.has(cp);
  });
}
function collapse_valid_tokens(tokens) {
  for (var _i43 = 0; _i43 < tokens.length; _i43++) {
    if (tokens[_i43].type == TY_VALID) {
      var _j5 = _i43 + 1;
      while (_j5 < tokens.length && tokens[_j5].type == TY_VALID) _j5++;
      tokens.splice(_i43, _j5 - _i43, {
        type: TY_VALID,
        cps: tokens.slice(_i43, _j5).flatMap(function (x) {
          return x.cps;
        })
      });
    }
  }
  return tokens;
}
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  var bytes = toUtf8Bytes(ensNormalize(name));
  var comps = [];
  if (name.length === 0) {
    return comps;
  }
  var last = 0;
  for (var _i44 = 0; _i44 < bytes.length; _i44++) {
    var d = bytes[_i44];
    // A separator (i.e. "."); copy this component
    if (d === 0x2e) {
      comps.push(checkComponent(bytes.slice(last, _i44)));
      last = _i44 + 1;
    }
  }
  // There was a stray separator at the end of the name
  assertArgument(last < bytes.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
/**
 *  Returns the ENS %%name%% normalized.
 */
function ensNormalize(name) {
  try {
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, "invalid ENS name (".concat(error.message, ")"), "name", name);
  }
}
/**
 *  Returns ``true`` if %%name%% is a valid ENS name.
 */
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {}
  return false;
}
/**
 *  Returns the [[link-namehash]] for %%name%%.
 */
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  var result = Zeros;
  var comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
/**
 *  Returns the DNS encoded %%name%%.
 *
 *  This is used for various parts of ENS name resolution, such
 *  as the wildcard resolution.
 */
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map(function (comp) {
    // DNS does not allow components over 63 bytes in length
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    var bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map(function (storageKey, index) {
      assertArgument(isHexString(storageKey, 32), "invalid slot", "storageKeys[".concat(index, "]"), storageKey);
      return storageKey.toLowerCase();
    })
  };
}
/**
 *  Returns a [[AccessList]] from any ethers-supported access-list structure.
 */
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map(function (set, index) {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", "value[".concat(index, "]"), set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && _typeof(set) === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && _typeof(value) === "object", "invalid access list", "value", value);
  var result = Object.keys(value).map(function (addr) {
    var storageKeys = value[addr].reduce(function (accum, storageKey) {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort(function (a, b) {
    return a.address.localeCompare(b.address);
  });
  return result;
}

/**
 *  Returns the address for the %%key%%.
 *
 *  The key may be any standard form of public key or a private key.
 */
function computeAddress(key) {
  var pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
/**
 *  Returns the recovered address for the private key that was
 *  used to sign %%digest%% that resulted in %%signature%%.
 */
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
var BN_0$4 = BigInt(0);
var BN_2$2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_0$4;
  }
  var value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  var value = getBigInt(_value, "value");
  var result = toBeArray(value);
  assertArgument(result.length <= 32, "value too large", "tx.".concat(name), value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map(function (set) {
    return [set.address, set.storageKeys];
  });
}
function _parseLegacy(data) {
  var fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  var tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  // Legacy unsigned transaction
  if (fields.length === 6) {
    return tx;
  }
  var v = handleUint(fields[6], "v");
  var r = handleUint(fields[7], "r");
  var s = handleUint(fields[8], "s");
  if (r === BN_0$4 && s === BN_0$4) {
    // EIP-155 unsigned transaction
    tx.chainId = v;
  } else {
    // Compute the EIP-155 chain ID (or 0 for legacy)
    var chainId = (v - BN_35) / BN_2$2;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    // Signed Legacy Transaction
    assertArgument(chainId !== BN_0$4 || v === BN_27 || v === BN_28, "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v
    });
    tx.hash = keccak256(data);
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  var fields = [formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? getAddress(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x"];
  var chainId = BN_0$4;
  if (tx.chainId != null) {
    // A chainId was provided; if non-zero we'll use EIP-155
    chainId = getBigInt(tx.chainId, "tx.chainId");
    // We have a chainId in the tx and an EIP-155 v in the signature,
    // make sure they agree with each other
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (sig) {
    // No chainId provided, but the signature is signing with EIP-155; derive chainId
    var legacy = sig.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  // Requesting an unsigned transaction
  if (!sig) {
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  // We pushed a chainId and null r, s on for hashing only; remove those
  var v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields, serialize) {
  var yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  var r = zeroPadValue(fields[1], 32);
  var s = zeroPadValue(fields[2], 32);
  var signature = Signature.from({
    r: r,
    s: s,
    yParity: yParity
  });
  tx.signature = signature;
}
function _parseEip1559(data) {
  var fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  var maxPriorityFeePerGas = handleUint(fields[2], "maxPriorityFeePerGas");
  var maxFeePerGas = handleUint(fields[3], "maxFeePerGas");
  var tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: maxPriorityFeePerGas,
    maxFeePerGas: maxFeePerGas,
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  // Unsigned EIP-1559 Transaction
  if (fields.length === 9) {
    return tx;
  }
  tx.hash = keccak256(data);
  _parseEipSignature(tx, fields.slice(9), _serializeEip1559);
  return tx;
}
function _serializeEip1559(tx, sig) {
  var fields = [formatNumber(tx.chainId || 0, "chainId"), formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? getAddress(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x", formatAccessList(tx.accessList || [])];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  var fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  var tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  // Unsigned EIP-2930 Transaction
  if (fields.length === 8) {
    return tx;
  }
  tx.hash = keccak256(data);
  _parseEipSignature(tx, fields.slice(8), _serializeEip2930);
  return tx;
}
function _serializeEip2930(tx, sig) {
  var fields = [formatNumber(tx.chainId || 0, "chainId"), formatNumber(tx.nonce || 0, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit || 0, "gasLimit"), tx.to != null ? getAddress(tx.to) : "0x", formatNumber(tx.value || 0, "value"), tx.data || "0x", formatAccessList(tx.accessList || [])];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
/**
 *  A **Transaction** describes an operation to be executed on
 *  Ethereum by an Externally Owned Account (EOA). It includes
 *  who (the [[to]] address), what (the [[data]]) and how much (the
 *  [[value]] in ether) the operation should entail.
 *
 *  @example:
 *    tx = new Transaction()
 *    //_result:
 *
 *    tx.data = "0x1234";
 *    //_result:
 */
var _type = /*#__PURE__*/new WeakMap();
var _to3 = /*#__PURE__*/new WeakMap();
var _data4 = /*#__PURE__*/new WeakMap();
var _nonce = /*#__PURE__*/new WeakMap();
var _gasLimit = /*#__PURE__*/new WeakMap();
var _gasPrice = /*#__PURE__*/new WeakMap();
var _maxPriorityFeePerGas = /*#__PURE__*/new WeakMap();
var _maxFeePerGas = /*#__PURE__*/new WeakMap();
var _value2 = /*#__PURE__*/new WeakMap();
var _chainId = /*#__PURE__*/new WeakMap();
var _sig2 = /*#__PURE__*/new WeakMap();
var _accessList = /*#__PURE__*/new WeakMap();
var Transaction = /*#__PURE__*/function () {
  /**
   *  Creates a new Transaction with default values.
   */
  function Transaction() {
    _classCallCheck(this, Transaction);
    _classPrivateFieldInitSpec(this, _type, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _to3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _data4, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _nonce, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _gasLimit, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _gasPrice, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maxPriorityFeePerGas, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maxFeePerGas, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _value2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _chainId, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _sig2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _accessList, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _type, null);
    _classPrivateFieldSet(this, _to3, null);
    _classPrivateFieldSet(this, _nonce, 0);
    _classPrivateFieldSet(this, _gasLimit, BigInt(0));
    _classPrivateFieldSet(this, _gasPrice, null);
    _classPrivateFieldSet(this, _maxPriorityFeePerGas, null);
    _classPrivateFieldSet(this, _maxFeePerGas, null);
    _classPrivateFieldSet(this, _data4, "0x");
    _classPrivateFieldSet(this, _value2, BigInt(0));
    _classPrivateFieldSet(this, _chainId, BigInt(0));
    _classPrivateFieldSet(this, _sig2, null);
    _classPrivateFieldSet(this, _accessList, null);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  _createClass(Transaction, [{
    key: "type",
    get:
    /**
     *  The transaction type.
     *
     *  If null, the type will be automatically inferred based on
     *  explicit properties.
     */
    function get() {
      return _classPrivateFieldGet(this, _type);
    },
    set: function set(value) {
      switch (value) {
        case null:
          _classPrivateFieldSet(this, _type, null);
          break;
        case 0:
        case "legacy":
          _classPrivateFieldSet(this, _type, 0);
          break;
        case 1:
        case "berlin":
        case "eip-2930":
          _classPrivateFieldSet(this, _type, 1);
          break;
        case 2:
        case "london":
        case "eip-1559":
          _classPrivateFieldSet(this, _type, 2);
          break;
        default:
          assertArgument(false, "unsupported transaction type", "type", value);
      }
    }
    /**
     *  The name of the transaction type.
     */
  }, {
    key: "typeName",
    get: function get() {
      switch (this.type) {
        case 0:
          return "legacy";
        case 1:
          return "eip-2930";
        case 2:
          return "eip-1559";
      }
      return null;
    }
    /**
     *  The ``to`` address for the transaction or ``null`` if the
     *  transaction is an ``init`` transaction.
     */
  }, {
    key: "to",
    get: function get() {
      return _classPrivateFieldGet(this, _to3);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _to3, value == null ? null : getAddress(value));
    }
    /**
     *  The transaction nonce.
     */
  }, {
    key: "nonce",
    get: function get() {
      return _classPrivateFieldGet(this, _nonce);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _nonce, getNumber(value, "value"));
    }
    /**
     *  The gas limit.
     */
  }, {
    key: "gasLimit",
    get: function get() {
      return _classPrivateFieldGet(this, _gasLimit);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _gasLimit, getBigInt(value));
    }
    /**
     *  The gas price.
     *
     *  On legacy networks this defines the fee that will be paid. On
     *  EIP-1559 networks, this should be ``null``.
     */
  }, {
    key: "gasPrice",
    get: function get() {
      var value = _classPrivateFieldGet(this, _gasPrice);
      if (value == null && (this.type === 0 || this.type === 1)) {
        return BN_0$4;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
    }
    /**
     *  The maximum priority fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
  }, {
    key: "maxPriorityFeePerGas",
    get: function get() {
      var value = _classPrivateFieldGet(this, _maxPriorityFeePerGas);
      if (value == null) {
        if (this.type === 2) {
          return BN_0$4;
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
    }
    /**
     *  The maximum total fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
  }, {
    key: "maxFeePerGas",
    get: function get() {
      var value = _classPrivateFieldGet(this, _maxFeePerGas);
      if (value == null) {
        if (this.type === 2) {
          return BN_0$4;
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
    }
    /**
     *  The transaction data. For ``init`` transactions this is the
     *  deployment code.
     */
  }, {
    key: "data",
    get: function get() {
      return _classPrivateFieldGet(this, _data4);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _data4, hexlify(value));
    }
    /**
     *  The amount of ether to send in this transactions.
     */
  }, {
    key: "value",
    get: function get() {
      return _classPrivateFieldGet(this, _value2);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _value2, getBigInt(value, "value"));
    }
    /**
     *  The chain ID this transaction is valid on.
     */
  }, {
    key: "chainId",
    get: function get() {
      return _classPrivateFieldGet(this, _chainId);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _chainId, getBigInt(value));
    }
    /**
     *  If signed, the signature for this transaction.
     */
  }, {
    key: "signature",
    get: function get() {
      return _classPrivateFieldGet(this, _sig2) || null;
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _sig2, value == null ? null : Signature.from(value));
    }
    /**
     *  The access list.
     *
     *  An access list permits discounted (but pre-paid) access to
     *  bytecode and state variable access within contract execution.
     */
  }, {
    key: "accessList",
    get: function get() {
      var value = _classPrivateFieldGet(this, _accessList) || null;
      if (value == null) {
        if (this.type === 1 || this.type === 2) {
          return [];
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _accessList, value == null ? null : accessListify(value));
    }
  }, {
    key: "hash",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return keccak256(this.serialized);
    }
    /**
     *  The pre-image hash of this transaction.
     *
     *  This is the digest that a [[Signer]] must sign to authorize
     *  this transaction.
     */
  }, {
    key: "unsignedHash",
    get: function get() {
      return keccak256(this.unsignedSerialized);
    }
    /**
     *  The sending address, if signed. Otherwise, ``null``.
     */
  }, {
    key: "from",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return recoverAddress(this.unsignedHash, this.signature);
    }
    /**
     *  The public key of the sender, if signed. Otherwise, ``null``.
     */
  }, {
    key: "fromPublicKey",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
    }
    /**
     *  Returns true if signed.
     *
     *  This provides a Type Guard that properties requiring a signed
     *  transaction are non-null.
     */
  }, {
    key: "isSigned",
    value: function isSigned() {
      //isSigned(): this is SignedTransaction {
      return this.signature != null;
    }
    /**
     *  The serialized transaction.
     *
     *  This throws if the transaction is unsigned. For the pre-image,
     *  use [[unsignedSerialized]].
     */
  }, {
    key: "serialized",
    get: function get() {
      assert$1(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
      });
      switch (this.inferType()) {
        case 0:
          return _serializeLegacy(this, this.signature);
        case 1:
          return _serializeEip2930(this, this.signature);
        case 2:
          return _serializeEip1559(this, this.signature);
      }
      assert$1(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
      });
    }
    /**
     *  The transaction pre-image.
     *
     *  The hash of this is the digest which needs to be signed to
     *  authorize this transaction.
     */
  }, {
    key: "unsignedSerialized",
    get: function get() {
      switch (this.inferType()) {
        case 0:
          return _serializeLegacy(this);
        case 1:
          return _serializeEip2930(this);
        case 2:
          return _serializeEip1559(this);
      }
      assert$1(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: ".unsignedSerialized"
      });
    }
    /**
     *  Return the most "likely" type; currently the highest
     *  supported transaction type.
     */
  }, {
    key: "inferType",
    value: function inferType() {
      return this.inferTypes().pop();
    }
    /**
     *  Validates the explicit properties and returns a list of compatible
     *  transaction types.
     */
  }, {
    key: "inferTypes",
    value: function inferTypes() {
      // Checks that there are no conflicting properties set
      var hasGasPrice = this.gasPrice != null;
      var hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
      var hasAccessList = this.accessList != null;
      //if (hasGasPrice && hasFee) {
      //    throw new Error("transaction cannot have gasPrice and maxFeePerGas");
      //}
      if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
        assert$1(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
          value: this
        });
      }
      //if (this.type === 2 && hasGasPrice) {
      //    throw new Error("eip-1559 transaction cannot have gasPrice");
      //}
      assert$1(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
        value: this
      });
      assert$1(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", {
        value: this
      });
      var types = [];
      // Explicit type
      if (this.type != null) {
        types.push(this.type);
      } else {
        if (hasFee) {
          types.push(2);
        } else if (hasGasPrice) {
          types.push(1);
          if (!hasAccessList) {
            types.push(0);
          }
        } else if (hasAccessList) {
          types.push(1);
          types.push(2);
        } else {
          types.push(0);
          types.push(1);
          types.push(2);
        }
      }
      types.sort();
      return types;
    }
    /**
     *  Returns true if this transaction is a legacy transaction (i.e.
     *  ``type === 0``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isLegacy",
    value: function isLegacy() {
      return this.type === 0;
    }
    /**
     *  Returns true if this transaction is berlin hardform transaction (i.e.
     *  ``type === 1``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isBerlin",
    value: function isBerlin() {
      return this.type === 1;
    }
    /**
     *  Returns true if this transaction is london hardform transaction (i.e.
     *  ``type === 2``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isLondon",
    value: function isLondon() {
      return this.type === 2;
    }
    /**
     *  Create a copy of this transaciton.
     */
  }, {
    key: "clone",
    value: function clone() {
      return Transaction.from(this);
    }
    /**
     *  Return a JSON-friendly object.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var s = function s(v) {
        if (v == null) {
          return null;
        }
        return v.toString();
      };
      return {
        type: this.type,
        to: this.to,
        //            from: this.from,
        data: this.data,
        nonce: this.nonce,
        gasLimit: s(this.gasLimit),
        gasPrice: s(this.gasPrice),
        maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
        maxFeePerGas: s(this.maxFeePerGas),
        value: s(this.value),
        chainId: s(this.chainId),
        sig: this.signature ? this.signature.toJSON() : null,
        accessList: this.accessList
      };
    }
    /**
     *  Create a **Transaction** from a serialized transaction or a
     *  Transaction-like object.
     */
  }], [{
    key: "from",
    value: function from(tx) {
      if (tx == null) {
        return new Transaction();
      }
      if (typeof tx === "string") {
        var payload = getBytes(tx);
        if (payload[0] >= 0x7f) {
          // @TODO: > vs >= ??
          return Transaction.from(_parseLegacy(payload));
        }
        switch (payload[0]) {
          case 1:
            return Transaction.from(_parseEip2930(payload));
          case 2:
            return Transaction.from(_parseEip1559(payload));
        }
        assert$1(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
          operation: "from"
        });
      }
      var result = new Transaction();
      if (tx.type != null) {
        result.type = tx.type;
      }
      if (tx.to != null) {
        result.to = tx.to;
      }
      if (tx.nonce != null) {
        result.nonce = tx.nonce;
      }
      if (tx.gasLimit != null) {
        result.gasLimit = tx.gasLimit;
      }
      if (tx.gasPrice != null) {
        result.gasPrice = tx.gasPrice;
      }
      if (tx.maxPriorityFeePerGas != null) {
        result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
      }
      if (tx.maxFeePerGas != null) {
        result.maxFeePerGas = tx.maxFeePerGas;
      }
      if (tx.data != null) {
        result.data = tx.data;
      }
      if (tx.value != null) {
        result.value = tx.value;
      }
      if (tx.chainId != null) {
        result.chainId = tx.chainId;
      }
      if (tx.signature != null) {
        result.signature = Signature.from(tx.signature);
      }
      if (tx.accessList != null) {
        result.accessList = tx.accessList;
      }
      if (tx.hash != null) {
        assertArgument(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx);
        assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
      }
      if (tx.from != null) {
        assertArgument(result.isSigned(), "unsigned transaction cannot define from", "tx", tx);
        assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
      }
      return result;
    }
  }]);
  return Transaction;
}();
/**
 *  Transactions..
 *
 *  @_section api/transaction:Transactions  [about-transactions]
 */
exports.Transaction = Transaction;
null;

/**
 *  Computes the [[link-eip-191]] personal-sign message digest to sign.
 *
 *  This prefixes the message with [[MessagePrefix]] and the decimal length
 *  of %%message%% and computes the [[keccak256]] digest.
 *
 *  If %%message%% is a string, it is converted to its UTF-8 bytes
 *  first. To compute the digest of a [[DataHexString]], it must be converted
 *  to [bytes](getBytes).
 *
 *  @example:
 *    hashMessage("Hello World")
 *    //_result:
 *
 *    // Hashes the SIX (6) string characters, i.e.
 *    // [ "0", "x", "4", "2", "4", "3" ]
 *    hashMessage("0x4243")
 *    //_result:
 *
 *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
 *    hashMessage(getBytes("0x4243"))
 *    //_result:
 *
 *    // ...which is equal to using data
 *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))
 *    //_result:
 *
 */
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([toUtf8Bytes(MessagePrefix), toUtf8Bytes(String(message.length)), message]));
}
function verifyMessage(message, sig) {
  var digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  var match = type.match(regexNumber);
  if (match) {
    var _signed = match[1] === "int";
    var size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (_signed) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    var _size = parseInt(match[1]);
    assertArgument(String(_size) === match[1] && _size !== 0 && _size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === _size, "invalid value for ".concat(type), "value", value);
    if (isArray) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    var baseType = match[1];
    var count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, "invalid array length for ".concat(type), "value", value);
    var result = [];
    value.forEach(function (value) {
      result.push(_pack(baseType, value, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
// @TODO: Array Enum
/**
 *   Computes the [[link-solc-packed]] representation of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  var tight = [];
  types.forEach(function (type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
/**
 *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedKeccak256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
/**
 *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedSha256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedSha256(types, values) {
  return sha256(solidityPacked(types, values));
}

//import { TypedDataDomain, TypedDataField } from "@ethersproject/providerabstract-signer";
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_0$3 = BigInt(0);
var BN_1$1 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
;
;
function hexPadRight(value) {
  var bytes = getBytes(value);
  var padOffset = bytes.length % 32;
  if (padOffset) {
    return concat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
var hexTrue = toBeHex(BN_1$1, 32);
var hexFalse = toBeHex(BN_0$3, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function (value) {
    assertArgument(typeof value === "string", "invalid domain value for ".concat(JSON.stringify(key)), "domain.".concat(key), value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function chainId(value) {
    return getBigInt(value, "domain.chainId");
  },
  verifyingContract: function verifyingContract(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {}
    assertArgument(false, "invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
  },
  salt: function salt(value) {
    var bytes = getBytes(value, "domain.salt");
    assertArgument(bytes.length === 32, "invalid domain value \"salt\"", "domain.salt", value);
    return hexlify(bytes);
  }
};
function getBaseEncoder(type) {
  // intXX and uintXX
  {
    var match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      var _signed2 = match[1] === "";
      var width = parseInt(match[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type);
      var boundsUpper = mask(BN_MAX_UINT256, _signed2 ? width - 1 : width);
      var boundsLower = _signed2 ? (boundsUpper + BN_1$1) * BN__1 : BN_0$3;
      return function (_value) {
        var value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, "value out-of-bounds for ".concat(type), "value", value);
        return toBeHex(toTwos(value, 256), 32);
      };
    }
  }
  // bytesXX
  {
    var _match = type.match(/^bytes(\d+)$/);
    if (_match) {
      var _width2 = parseInt(_match[1]);
      assertArgument(_width2 !== 0 && _width2 <= 32 && _match[1] === String(_width2), "invalid bytes width", "type", type);
      return function (value) {
        var bytes = getBytes(value);
        assertArgument(bytes.length === _width2, "invalid length for ".concat(type), "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function (value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function (value) {
        return keccak256(value);
      };
    case "string":
      return function (value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return "".concat(name, "(").concat(fields.map(function (_ref8) {
    var name = _ref8.name,
      type = _ref8.type;
    return type + " " + name;
  }).join(","), ")");
}
var _types = /*#__PURE__*/new WeakMap();
var _fullTypes = /*#__PURE__*/new WeakMap();
var _encoderCache = /*#__PURE__*/new WeakMap();
var _getEncoder = /*#__PURE__*/new WeakSet();
var TypedDataEncoder = /*#__PURE__*/function () {
  function TypedDataEncoder(types) {
    _classCallCheck(this, TypedDataEncoder);
    _classPrivateMethodInitSpec(this, _getEncoder);
    _defineProperty(this, "primaryType", void 0);
    _classPrivateFieldInitSpec(this, _types, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _fullTypes, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _encoderCache, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _types, JSON.stringify(types));
    _classPrivateFieldSet(this, _fullTypes, new Map());
    _classPrivateFieldSet(this, _encoderCache, new Map());
    // Link struct types to their direct child structs
    var links = new Map();
    // Link structs to structs which contain them as a child
    var parents = new Map();
    // Link all subtypes within a given struct
    var subtypes = new Map();
    Object.keys(types).forEach(function (type) {
      links.set(type, new Set());
      parents.set(type, []);
      subtypes.set(type, new Set());
    });
    for (var name in types) {
      var uniqueNames = new Set();
      var _iterator14 = _createForOfIteratorHelper(types[name]),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var field = _step14.value;
          // Check each field has a unique name
          assertArgument(!uniqueNames.has(field.name), "duplicate variable name ".concat(JSON.stringify(field.name), " in ").concat(JSON.stringify(name)), "types", types);
          uniqueNames.add(field.name);
          // Get the base type (drop any array specifiers)
          var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
          assertArgument(baseType !== name, "circular type reference to ".concat(JSON.stringify(baseType)), "types", types);
          // Is this a base encoding type?
          var encoder = getBaseEncoder(baseType);
          if (encoder) {
            continue;
          }
          assertArgument(parents.has(baseType), "unknown type ".concat(JSON.stringify(baseType)), "types", types);
          // Add linkage
          parents.get(baseType).push(name);
          links.get(name).add(baseType);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    // Deduce the primary type
    var primaryTypes = Array.from(parents.keys()).filter(function (n) {
      return parents.get(n).length === 0;
    });
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types);
    assertArgument(primaryTypes.length === 1, "ambiguous primary types or unused types: ".concat(primaryTypes.map(function (t) {
      return JSON.stringify(t);
    }).join(", ")), "types", types);
    defineProperties(this, {
      primaryType: primaryTypes[0]
    });
    // Check for circular type references
    function checkCircular(type, found) {
      assertArgument(!found.has(type), "circular type reference to ".concat(JSON.stringify(type)), "types", types);
      found.add(type);
      var _iterator15 = _createForOfIteratorHelper(links.get(type)),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var child = _step15.value;
          if (!parents.has(child)) {
            continue;
          }
          // Recursively check children
          checkCircular(child, found);
          // Mark all ancestors as having this decendant
          var _iterator16 = _createForOfIteratorHelper(found),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var subtype = _step16.value;
              subtypes.get(subtype).add(child);
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      found["delete"](type);
    }
    checkCircular(this.primaryType, new Set());
    // Compute each fully describe type
    var _iterator17 = _createForOfIteratorHelper(subtypes),
      _step17;
    try {
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        var _step17$value = _slicedToArray(_step17.value, 2),
          _name = _step17$value[0],
          set = _step17$value[1];
        var st = Array.from(set);
        st.sort();
        _classPrivateFieldGet(this, _fullTypes).set(_name, encodeType(_name, types[_name]) + st.map(function (t) {
          return encodeType(t, types[t]);
        }).join(""));
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
  }
  _createClass(TypedDataEncoder, [{
    key: "types",
    get: function get() {
      return JSON.parse(_classPrivateFieldGet(this, _types));
    }
  }, {
    key: "getEncoder",
    value: function getEncoder(type) {
      var encoder = _classPrivateFieldGet(this, _encoderCache).get(type);
      if (!encoder) {
        encoder = _classPrivateMethodGet(this, _getEncoder, _getEncoder2).call(this, type);
        _classPrivateFieldGet(this, _encoderCache).set(type, encoder);
      }
      return encoder;
    }
  }, {
    key: "encodeType",
    value: function encodeType(name) {
      var result = _classPrivateFieldGet(this, _fullTypes).get(name);
      assertArgument(result, "unknown type: ".concat(JSON.stringify(name)), "name", name);
      return result;
    }
  }, {
    key: "encodeData",
    value: function encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, value) {
      return keccak256(this.encodeData(name, value));
    }
  }, {
    key: "encode",
    value: function encode(value) {
      return this.encodeData(this.primaryType, value);
    }
  }, {
    key: "hash",
    value: function hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
  }, {
    key: "_visit",
    value: function _visit(type, value, callback) {
      var _this19 = this;
      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return callback(type, value);
        }
      }
      // Array
      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        assertArgument(!match[3] || parseInt(match[3]) === value.length, "array length mismatch; expected length ".concat(parseInt(match[3])), "value", value);
        return value.map(function (v) {
          return _this19._visit(match[1], v, callback);
        });
      }
      // Struct
      var fields = this.types[type];
      if (fields) {
        return fields.reduce(function (accum, _ref9) {
          var name = _ref9.name,
            type = _ref9.type;
          accum[name] = _this19._visit(type, value[name], callback);
          return accum;
        }, {});
      }
      assertArgument(false, "unknown type: ".concat(type), "type", type);
    }
  }, {
    key: "visit",
    value: function visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
  }], [{
    key: "from",
    value: function from(types) {
      return new TypedDataEncoder(types);
    }
  }, {
    key: "getPrimaryType",
    value: function getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name, value);
    }
  }, {
    key: "hashDomain",
    value: function hashDomain(domain) {
      var domainFields = [];
      for (var name in domain) {
        var type = domainFieldTypes[name];
        assertArgument(type, "invalid typed-data domain key: ".concat(JSON.stringify(name)), "domain", domain);
        domainFields.push({
          name: name,
          type: type
        });
      }
      domainFields.sort(function (a, b) {
        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", {
        EIP712Domain: domainFields
      }, domain);
    }
  }, {
    key: "encode",
    value: function encode(domain, types, value) {
      return concat(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
    }
  }, {
    key: "hash",
    value: function hash(domain, types, value) {
      return keccak256(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
  }, {
    key: "resolveNames",
    value: function () {
      var _resolveNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(domain, types, value, resolveName) {
        var ensCache, encoder, name;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              // Make a copy to isolate it from the object passed in
              domain = Object.assign({}, domain);
              // Look up all ENS names
              ensCache = {}; // Do we need to look up the domain's verifyingContract?
              if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
              }
              // We are going to use the encoder to visit all the base values
              encoder = TypedDataEncoder.from(types); // Get a list of all the addresses
              encoder.visit(value, function (type, value) {
                if (type === "address" && !isHexString(value, 20)) {
                  ensCache[value] = "0x";
                }
                return value;
              });
              // Lookup each name
              _context11.t0 = _regeneratorRuntime().keys(ensCache);
            case 6:
              if ((_context11.t1 = _context11.t0()).done) {
                _context11.next = 13;
                break;
              }
              name = _context11.t1.value;
              _context11.next = 10;
              return resolveName(name);
            case 10:
              ensCache[name] = _context11.sent;
              _context11.next = 6;
              break;
            case 13:
              // Replace the domain verifyingContract if needed
              if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
              }
              // Replace all ENS names with their address
              value = encoder.visit(value, function (type, value) {
                if (type === "address" && ensCache[value]) {
                  return ensCache[value];
                }
                return value;
              });
              return _context11.abrupt("return", {
                domain: domain,
                value: value
              });
            case 16:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function resolveNames(_x51, _x52, _x53, _x54) {
        return _resolveNames.apply(this, arguments);
      }
      return resolveNames;
    }()
  }, {
    key: "getPayload",
    value: function getPayload(domain, types, value) {
      // Validate the domain fields
      TypedDataEncoder.hashDomain(domain);
      // Derive the EIP712Domain Struct reference type
      var domainValues = {};
      var domainTypes = [];
      domainFieldNames.forEach(function (name) {
        var value = domain[name];
        if (value == null) {
          return;
        }
        domainValues[name] = domainChecks[name](value);
        domainTypes.push({
          name: name,
          type: domainFieldTypes[name]
        });
      });
      var encoder = TypedDataEncoder.from(types);
      var typesWithDomain = Object.assign({}, types);
      assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
      typesWithDomain.EIP712Domain = domainTypes;
      // Validate the data structures and types
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, function (type, value) {
          // bytes
          if (type.match(/^bytes(\d*)/)) {
            return hexlify(getBytes(value));
          }
          // uint or int
          if (type.match(/^u?int/)) {
            return getBigInt(value).toString();
          }
          switch (type) {
            case "address":
              return value.toLowerCase();
            case "bool":
              return !!value;
            case "string":
              assertArgument(typeof value === "string", "invalid string", "value", value);
              return value;
          }
          assertArgument(false, "unsupported type", "type", type);
        })
      };
    }
  }]);
  return TypedDataEncoder;
}();
/**
 *  About hashing here...
 *
 *  @_section: api/hashing:Hashing Utilities  [about-hashing]
 */
/**
 *  About frgaments...
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
exports.TypedDataEncoder = TypedDataEncoder;
function _getEncoder2(type) {
  var _this104 = this;
  // Basic encoder type (address, bool, uint256, etc)
  {
    var encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  // Array
  var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (match) {
    var subtype = match[1];
    var subEncoder = this.getEncoder(subtype);
    return function (value) {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, "array length mismatch; expected length ".concat(parseInt(match[3])), "value", value);
      var result = value.map(subEncoder);
      if (_classPrivateFieldGet(_this104, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  // Struct
  var fields = this.types[type];
  if (fields) {
    var encodedType = id(_classPrivateFieldGet(this, _fullTypes).get(type));
    return function (value) {
      var values = fields.map(function (_ref49) {
        var name = _ref49.name,
          type = _ref49.type;
        var result = _this104.getEncoder(type)(value[name]);
        if (_classPrivateFieldGet(_this104, _fullTypes).has(type)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, "unknown type: ".concat(type), "type", type);
}
;
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
  var result = new Set();
  items.forEach(function (k) {
    return result.add(k);
  });
  return Object.freeze(result);
}
// Visibility Keywords
var _kwVisib = "constant external internal payable private public pure view";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
// All Keywords
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
// Single character tokens
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
// Parser regexes to consume the next token
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var _offset2 = /*#__PURE__*/new WeakMap();
var _tokens = /*#__PURE__*/new WeakMap();
var _subTokenString = /*#__PURE__*/new WeakSet();
var TokenString = /*#__PURE__*/function () {
  function TokenString(tokens) {
    _classCallCheck(this, TokenString);
    _classPrivateMethodInitSpec(this, _subTokenString);
    _classPrivateFieldInitSpec(this, _offset2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _tokens, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _offset2, 0);
    _classPrivateFieldSet(this, _tokens, tokens.slice());
  }
  _createClass(TokenString, [{
    key: "offset",
    get: function get() {
      return _classPrivateFieldGet(this, _offset2);
    }
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(this, _tokens).length - _classPrivateFieldGet(this, _offset2);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new TokenString(_classPrivateFieldGet(this, _tokens));
    }
  }, {
    key: "reset",
    value: function reset() {
      _classPrivateFieldSet(this, _offset2, 0);
    }
  }, {
    key: "popKeyword",
    value:
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    function popKeyword(allowed) {
      var top = this.peek();
      if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
        throw new Error("expected keyword ".concat(top.text));
      }
      return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  }, {
    key: "popType",
    value: function popType(type) {
      if (this.peek().type !== type) {
        throw new Error("expected ".concat(type, "; got ").concat(JSON.stringify(this.peek())));
      }
      return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
  }, {
    key: "popParen",
    value: function popParen() {
      var top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      var result = _classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset2) + 1, top.match + 1);
      _classPrivateFieldSet(this, _offset2, top.match + 1);
      return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  }, {
    key: "popParams",
    value: function popParams() {
      var top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      var result = [];
      while (_classPrivateFieldGet(this, _offset2) < top.match - 1) {
        var link = this.peek().linkNext;
        result.push(_classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset2) + 1, link));
        _classPrivateFieldSet(this, _offset2, link);
      }
      _classPrivateFieldSet(this, _offset2, top.match + 1);
      return result;
    }
    // Returns the top Token, throwing if out of tokens
  }, {
    key: "peek",
    value: function peek() {
      if (_classPrivateFieldGet(this, _offset2) >= _classPrivateFieldGet(this, _tokens).length) {
        throw new Error("out-of-bounds");
      }
      return _classPrivateFieldGet(this, _tokens)[_classPrivateFieldGet(this, _offset2)];
    }
    // Returns the next value, if it is a keyword in `allowed`
  }, {
    key: "peekKeyword",
    value: function peekKeyword(allowed) {
      var top = this.peekType("KEYWORD");
      return top != null && allowed.has(top) ? top : null;
    }
    // Returns the value of the next token if it is `type`
  }, {
    key: "peekType",
    value: function peekType(type) {
      if (this.length === 0) {
        return null;
      }
      var top = this.peek();
      return top.type === type ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
  }, {
    key: "pop",
    value: function pop() {
      var _this$offset, _this$offset2;
      var result = this.peek();
      _classPrivateFieldSet(this, _offset2, (_this$offset = _classPrivateFieldGet(this, _offset2), _this$offset2 = _this$offset++, _this$offset)), _this$offset2;
      return result;
    }
  }, {
    key: "toString",
    value: function toString() {
      var tokens = [];
      for (var _i45 = _classPrivateFieldGet(this, _offset2); _i45 < _classPrivateFieldGet(this, _tokens).length; _i45++) {
        var token = _classPrivateFieldGet(this, _tokens)[_i45];
        tokens.push("".concat(token.type, ":").concat(token.text));
      }
      return "<TokenString ".concat(tokens.join(" "), ">");
    }
  }]);
  return TokenString;
}();
function _subTokenString2() {
  var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return new TokenString(_classPrivateFieldGet(this, _tokens).slice(from, to).map(function (t) {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
    return t;
  }));
}
function lex(text) {
  var tokens = [];
  var throwError = function throwError(message) {
    var token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error("invalid token ".concat(token, " at ").concat(offset, ": ").concat(message));
  };
  var brackets = [];
  var commas = [];
  var offset = 0;
  while (offset < text.length) {
    // Strip off any leading whitespace
    var cur = text.substring(offset);
    var match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    var token = {
      depth: brackets.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset: offset,
      value: -1
    };
    tokens.push(token);
    var type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        // Remove the CLOSE_BRACKET
        var suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          var value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error("unexpected token ".concat(JSON.stringify(cur[0]), " at position ").concat(offset));
  }
  return new TokenString(tokens.map(function (t) {
    return Object.freeze(t);
  }));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
  var included = [];
  for (var key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error("conflicting types: ".concat(included.join(", ")));
  }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    var keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error("expected ".concat(type, ", got ").concat(keyword));
    }
  }
  return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
  var keywords = new Set();
  while (true) {
    var keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error("duplicate keywords: ".concat(JSON.stringify(keyword)));
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
  var modifiers = consumeKeywords(tokens, KwVisib);
  // Detect conflicting modifiers
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  // Process mutability states
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  // Process legacy `constant` last
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map(function (t) {
    return ParamType.from(t, allowIndexed);
  });
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error("unexpected tokens: ".concat(tokens.toString()));
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  var match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    // bytesXX
    var length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    // intXX or uintXX
    var size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
// Make the Fragment constructors effectively private
var _guard$2 = {};
var internal$1 = Symbol["for"]("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **PAramType**.
 */
var _walkAsync = /*#__PURE__*/new WeakSet();
var ParamType = /*#__PURE__*/function () {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */

  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */

  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */

  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */

  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */

  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */

  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */

  /**
   *  @private
   */
  function ParamType(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {
    _classCallCheck(this, ParamType);
    _classPrivateMethodInitSpec(this, _walkAsync);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "baseType", void 0);
    _defineProperty(this, "indexed", void 0);
    _defineProperty(this, "components", void 0);
    _defineProperty(this, "arrayLength", void 0);
    _defineProperty(this, "arrayChildren", void 0);
    assertPrivate(guard, _guard$2, "ParamType");
    Object.defineProperty(this, internal$1, {
      value: ParamTypeInternal
    });
    if (_components) {
      _components = Object.freeze(_components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (_components == null) {
        throw new Error("");
      }
    } else if (_components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name: name,
      type: type,
      baseType: baseType,
      indexed: indexed,
      components: _components,
      arrayLength: arrayLength,
      arrayChildren: arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  _createClass(ParamType, [{
    key: "format",
    value: function format(_format3) {
      if (_format3 == null) {
        _format3 = "sighash";
      }
      if (_format3 === "json") {
        var _result3 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: this.name || undefined
        };
        if (typeof this.indexed === "boolean") {
          _result3.indexed = this.indexed;
        }
        if (this.isTuple()) {
          _result3.components = this.components.map(function (c) {
            return JSON.parse(c.format(_format3));
          });
        }
        return JSON.stringify(_result3);
      }
      var result = "";
      // Array
      if (this.isArray()) {
        result += this.arrayChildren.format(_format3);
        result += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]");
      } else {
        if (this.isTuple()) {
          if (_format3 !== "sighash") {
            result += this.type;
          }
          result += "(" + this.components.map(function (comp) {
            return comp.format(_format3);
          }).join(_format3 === "full" ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (_format3 !== "sighash") {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (_format3 === "full" && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    }
    /*
     *  Returns true if %%value%% is an Array type.
     *
     *  This provides a type gaurd ensuring that the
     *  [[arrayChildren]] and [[arrayLength]] are non-null.
     */
    //static isArray(value: any): value is { arrayChildren: ParamType, arrayLength: number } {
    //    return value && (value.baseType === "array")
    //}
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
  }, {
    key: "isArray",
    value: function isArray() {
      return this.baseType === "array";
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
  }, {
    key: "isTuple",
    value: function isTuple() {
      return this.baseType === "tuple";
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
  }, {
    key: "isIndexable",
    value: function isIndexable() {
      return this.indexed != null;
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
  }, {
    key: "walk",
    value: function walk(value, process) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invlaid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        var _this = this;
        return value.map(function (v) {
          return _this.arrayChildren.walk(v, process);
        });
      }
      if (this.isTuple()) {
        if (!Array.isArray(value)) {
          throw new Error("invlaid tuple value");
        }
        if (value.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        var _this20 = this;
        return value.map(function (v, i) {
          return _this20.components[i].walk(v, process);
        });
      }
      return process(this.type, value);
    }
  }, {
    key: "walkAsync",
    value:
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS naes by walking and resolving each
     *  ``"address"`` type.
     */
    function () {
      var _walkAsync3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(value, process) {
        var promises, result;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              promises = [];
              result = [value];
              _classPrivateMethodGet(this, _walkAsync, _walkAsync2).call(this, promises, value, process, function (value) {
                result[0] = value;
              });
              if (!promises.length) {
                _context12.next = 6;
                break;
              }
              _context12.next = 6;
              return Promise.all(promises);
            case 6:
              return _context12.abrupt("return", result[0]);
            case 7:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function walkAsync(_x55, _x56) {
        return _walkAsync3.apply(this, arguments);
      }
      return walkAsync;
    }()
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
  }], [{
    key: "from",
    value: function from(obj, allowIndexed) {
      if (ParamType.isParamType(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return ParamType.from(lex(obj), allowIndexed);
      } else if (obj instanceof TokenString) {
        var _type2 = "",
          baseType = "";
        var comps = null;
        if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
          // Tuple
          baseType = "tuple";
          comps = obj.popParams().map(function (t) {
            return ParamType.from(t);
          });
          _type2 = "tuple(".concat(comps.map(function (c) {
            return c.format();
          }).join(","), ")");
        } else {
          // Normal
          _type2 = verifyBasicType(obj.popType("TYPE"));
          baseType = _type2;
        }
        // Check for Array
        var arrayChildren = null;
        var arrayLength = null;
        while (obj.length && obj.peekType("BRACKET")) {
          var bracket = obj.pop(); //arrays[i];
          arrayChildren = new ParamType(_guard$2, "", _type2, baseType, null, comps, arrayLength, arrayChildren);
          arrayLength = bracket.value;
          _type2 += bracket.text;
          baseType = "array";
          comps = null;
        }
        var _indexed = null;
        var keywords = consumeKeywords(obj, KwModifiers);
        if (keywords.has("indexed")) {
          if (!allowIndexed) {
            throw new Error("");
          }
          _indexed = true;
        }
        var _name2 = obj.peekType("ID") ? obj.pop().text : "";
        if (obj.length) {
          throw new Error("leftover tokens");
        }
        return new ParamType(_guard$2, _name2, _type2, baseType, _indexed, comps, arrayLength, arrayChildren);
      }
      var name = obj.name;
      assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
      var indexed = obj.indexed;
      if (indexed != null) {
        assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
        indexed = !!indexed;
      }
      var type = obj.type;
      var arrayMatch = type.match(regexArrayType);
      if (arrayMatch) {
        var _arrayLength = parseInt(arrayMatch[2] || "-1");
        var _arrayChildren = ParamType.from({
          type: arrayMatch[1],
          components: obj.components
        });
        return new ParamType(_guard$2, name || "", type, "array", indexed, null, _arrayLength, _arrayChildren);
      }
      if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
        var _comps = obj.components != null ? obj.components.map(function (c) {
          return ParamType.from(c);
        }) : null;
        var tuple = new ParamType(_guard$2, name || "", type, "tuple", indexed, _comps, null, null);
        // @TODO: use lexer to validate and normalize type
        return tuple;
      }
      type = verifyBasicType(obj.type);
      return new ParamType(_guard$2, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
  }, {
    key: "isParamType",
    value: function isParamType(value) {
      return value && value[internal$1] === ParamTypeInternal;
    }
  }]);
  return ParamType;
}();
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
exports.ParamType = ParamType;
function _walkAsync2(promises, value, process, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invlaid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    var childType = this.arrayChildren;
    var _result6 = value.slice();
    _result6.forEach(function (value, index) {
      _classPrivateMethodGet(childType, _walkAsync, _walkAsync2).call(childType, promises, value, process, function (value) {
        _result6[index] = value;
      });
    });
    setValue(_result6);
    return;
  }
  if (this.isTuple()) {
    var components = this.components;
    // Convert the object into an array
    var _result7;
    if (Array.isArray(value)) {
      _result7 = value.slice();
    } else {
      if (value == null || _typeof(value) !== "object") {
        throw new Error("invlaid tuple value");
      }
      _result7 = components.map(function (param) {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error("missing value for component ".concat(param.name));
        }
        return value[param.name];
      });
    }
    if (_result7.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    _result7.forEach(function (value, index) {
      var _components$index;
      _classPrivateMethodGet(_components$index = components[index], _walkAsync, _walkAsync2).call(_components$index, promises, value, process, function (value) {
        _result7[index] = value;
      });
    });
    setValue(_result7);
    return;
  }
  var result = process(this.type, value);
  if (result.then) {
    promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee206() {
      return _regeneratorRuntime().wrap(function _callee206$(_context208) {
        while (1) switch (_context208.prev = _context208.next) {
          case 0:
            _context208.t0 = setValue;
            _context208.next = 3;
            return result;
          case 3:
            _context208.t1 = _context208.sent;
            (0, _context208.t0)(_context208.t1);
          case 5:
          case "end":
            return _context208.stop();
        }
      }, _callee206);
    }))());
  } else {
    setValue(result);
  }
}
var Fragment = /*#__PURE__*/function () {
  /**
   *  The type of the fragment.
   */

  /**
   *  The inputs for the fragment.
   */

  /**
   *  @private
   */
  function Fragment(guard, type, inputs) {
    _classCallCheck(this, Fragment);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "inputs", void 0);
    assertPrivate(guard, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, {
      type: type,
      inputs: inputs
    });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  _createClass(Fragment, null, [{
    key: "from",
    value: function from(obj) {
      if (typeof obj === "string") {
        // Try parsing JSON...
        try {
          Fragment.from(JSON.parse(obj));
        } catch (e) {}
        // ...otherwise, use the human-readable lexer
        return Fragment.from(lex(obj));
      }
      if (obj instanceof TokenString) {
        // Human-readable ABI (already lexed)
        var type = obj.peekKeyword(KwTypes);
        switch (type) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
      } else if (_typeof(obj) === "object") {
        // JSON ABI
        switch (obj.type) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
        assert$1(false, "unsupported type: ".concat(obj.type), "UNSUPPORTED_OPERATION", {
          operation: "Fragment.from"
        });
      }
      assertArgument(false, "unsupported frgament object", "obj", obj);
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
  }, {
    key: "isConstructor",
    value: function isConstructor(value) {
      return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
  }, {
    key: "isError",
    value: function isError(value) {
      return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
  }, {
    key: "isEvent",
    value: function isEvent(value) {
      return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
  }, {
    key: "isFunction",
    value: function isFunction(value) {
      return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
  }, {
    key: "isStruct",
    value: function isStruct(value) {
      return StructFragment.isFragment(value);
    }
  }]);
  return Fragment;
}();
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
exports.Fragment = Fragment;
var NamedFragment = /*#__PURE__*/function (_Fragment) {
  _inherits(NamedFragment, _Fragment);
  var _super23 = _createSuper(NamedFragment);
  /**
   *  The name of the fragment.
   */

  /**
   *  @private
   */
  function NamedFragment(guard, type, name, inputs) {
    var _this21;
    _classCallCheck(this, NamedFragment);
    _this21 = _super23.call(this, guard, type, inputs);
    _defineProperty(_assertThisInitialized(_this21), "name", void 0);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(_assertThisInitialized(_this21), {
      name: name
    });
    return _this21;
  }
  return _createClass(NamedFragment);
}(Fragment);
function joinParams(format, params) {
  return "(" + params.map(function (p) {
    return p.format(format);
  }).join(format === "full" ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
var ErrorFragment = /*#__PURE__*/function (_NamedFragment) {
  _inherits(ErrorFragment, _NamedFragment);
  var _super24 = _createSuper(ErrorFragment);
  /**
   *  @private
   */
  function ErrorFragment(guard, name, inputs) {
    var _this22;
    _classCallCheck(this, ErrorFragment);
    _this22 = _super24.call(this, guard, "error", name, inputs);
    Object.defineProperty(_assertThisInitialized(_this22), internal$1, {
      value: ErrorFragmentInternal
    });
    return _this22;
  }
  /**
   *  The Custom Error selector.
   */
  _createClass(ErrorFragment, [{
    key: "selector",
    get: function get() {
      return id(this.format("sighash")).substring(0, 10);
    }
  }, {
    key: "format",
    value: function format(_format4) {
      if (_format4 == null) {
        _format4 = "sighash";
      }
      if (_format4 === "json") {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map(function (input) {
            return JSON.parse(input.format(_format4));
          })
        });
      }
      var result = [];
      if (_format4 !== "sighash") {
        result.push("error");
      }
      result.push(this.name + joinParams(_format4, this.inputs));
      return result.join(" ");
    }
  }], [{
    key: "from",
    value: function from(obj) {
      if (ErrorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return ErrorFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var name = consumeName("error", obj);
        var inputs = consumeParams(obj);
        consumeEoi(obj);
        return new ErrorFragment(_guard$2, name, inputs);
      }
      return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === ErrorFragmentInternal;
    }
  }]);
  return ErrorFragment;
}(NamedFragment);
/**
 *  A Fragment which represents an Event.
 */
exports.ErrorFragment = ErrorFragment;
var EventFragment = /*#__PURE__*/function (_NamedFragment2) {
  _inherits(EventFragment, _NamedFragment2);
  var _super25 = _createSuper(EventFragment);
  /**
   *  @private
   */
  function EventFragment(guard, name, inputs, anonymous) {
    var _this23;
    _classCallCheck(this, EventFragment);
    _this23 = _super25.call(this, guard, "event", name, inputs);
    _defineProperty(_assertThisInitialized(_this23), "anonymous", void 0);
    Object.defineProperty(_assertThisInitialized(_this23), internal$1, {
      value: EventFragmentInternal
    });
    defineProperties(_assertThisInitialized(_this23), {
      anonymous: anonymous
    });
    return _this23;
  }
  /**
   *  The Event topic hash.
   */
  _createClass(EventFragment, [{
    key: "topicHash",
    get: function get() {
      return id(this.format("sighash"));
    }
  }, {
    key: "format",
    value: function format(_format5) {
      if (_format5 == null) {
        _format5 = "sighash";
      }
      if (_format5 === "json") {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format5));
          })
        });
      }
      var result = [];
      if (_format5 !== "sighash") {
        result.push("event");
      }
      result.push(this.name + joinParams(_format5, this.inputs));
      if (_format5 !== "sighash" && this.anonymous) {
        result.push("anonymous");
      }
      return result.join(" ");
    }
  }], [{
    key: "getTopicHash",
    value: function getTopicHash(name, params) {
      params = (params || []).map(function (p) {
        return ParamType.from(p);
      });
      var fragment = new EventFragment(_guard$2, name, params, false);
      return fragment.topicHash;
    }
  }, {
    key: "from",
    value: function from(obj) {
      if (EventFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return EventFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var name = consumeName("event", obj);
        var inputs = consumeParams(obj, true);
        var anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
        consumeEoi(obj);
        return new EventFragment(_guard$2, name, inputs, anonymous);
      }
      return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(function (p) {
        return ParamType.from(p, true);
      }) : [], !!obj.anonymous);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === EventFragmentInternal;
    }
  }]);
  return EventFragment;
}(NamedFragment);
/**
 *  A Fragment which represents a constructor.
 */
exports.EventFragment = EventFragment;
var ConstructorFragment = /*#__PURE__*/function (_Fragment2) {
  _inherits(ConstructorFragment, _Fragment2);
  var _super26 = _createSuper(ConstructorFragment);
  /**
   *  @private
   */
  function ConstructorFragment(guard, type, inputs, payable, gas) {
    var _this24;
    _classCallCheck(this, ConstructorFragment);
    _this24 = _super26.call(this, guard, type, inputs);
    _defineProperty(_assertThisInitialized(_this24), "payable", void 0);
    _defineProperty(_assertThisInitialized(_this24), "gas", void 0);
    Object.defineProperty(_assertThisInitialized(_this24), internal$1, {
      value: ConstructorFragmentInternal
    });
    defineProperties(_assertThisInitialized(_this24), {
      payable: payable,
      gas: gas
    });
    return _this24;
  }
  _createClass(ConstructorFragment, [{
    key: "format",
    value: function format(_format6) {
      assert$1(_format6 != null && _format6 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
        operation: "format(sighash)"
      });
      if (_format6 === "json") {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.payable ? "payable" : "undefined",
          payable: this.payable,
          gas: this.gas != null ? this.gas : undefined,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format6));
          })
        });
      }
      var result = ["constructor".concat(joinParams(_format6, this.inputs))];
      result.push(this.payable ? "payable" : "nonpayable");
      if (this.gas != null) {
        result.push("@".concat(this.gas.toString()));
      }
      return result.join(" ");
    }
  }], [{
    key: "from",
    value: function from(obj) {
      if (ConstructorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return ConstructorFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        consumeKeywords(obj, setify(["constructor"]));
        var inputs = consumeParams(obj);
        var payable = !!consumeKeywords(obj, setify(["payable"])).has("payable");
        var gas = consumeGas(obj);
        consumeEoi(obj);
        return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
      }
      return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === ConstructorFragmentInternal;
    }
  }]);
  return ConstructorFragment;
}(Fragment);
/**
 *  A Fragment which represents a method.
 */
exports.ConstructorFragment = ConstructorFragment;
var FallbackFragment = /*#__PURE__*/function (_Fragment3) {
  _inherits(FallbackFragment, _Fragment3);
  var _super27 = _createSuper(FallbackFragment);
  /**
   *  If the function can be sent value during invocation.
   */

  function FallbackFragment(guard, inputs, payable) {
    var _this25;
    _classCallCheck(this, FallbackFragment);
    _this25 = _super27.call(this, guard, "fallback", inputs);
    _defineProperty(_assertThisInitialized(_this25), "payable", void 0);
    Object.defineProperty(_assertThisInitialized(_this25), internal$1, {
      value: FallbackFragmentInternal
    });
    defineProperties(_assertThisInitialized(_this25), {
      payable: payable
    });
    return _this25;
  }
  _createClass(FallbackFragment, [{
    key: "format",
    value: function format(_format7) {
      var type = this.inputs.length === 0 ? "receive" : "fallback";
      if (_format7 === "json") {
        var stateMutability = this.payable ? "payable" : "nonpayable";
        return JSON.stringify({
          type: type,
          stateMutability: stateMutability
        });
      }
      return "".concat(type, "()").concat(this.payable ? " payable" : "");
    }
  }], [{
    key: "from",
    value: function from(obj) {
      if (FallbackFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return FallbackFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var errorObj = obj.toString();
        var topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
        assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
        var type = obj.popKeyword(setify(["fallback", "receive"]));
        // receive()
        if (type === "receive") {
          var _inputs = consumeParams(obj);
          assertArgument(_inputs.length === 0, "receive cannot have arguments", "obj.inputs", _inputs);
          consumeKeywords(obj, setify(["payable"]));
          consumeEoi(obj);
          return new FallbackFragment(_guard$2, [], true);
        }
        // fallback() [payable]
        // fallback(bytes) [payable] returns (bytes)
        var inputs = consumeParams(obj);
        if (inputs.length) {
          assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map(function (i) {
            return i.format("minimal");
          }).join(", "));
        } else {
          inputs = [ParamType.from("bytes")];
        }
        var mutability = consumeMutability(obj);
        assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          var outputs = consumeParams(obj);
          assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map(function (i) {
            return i.format("minimal");
          }).join(", "));
        }
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, inputs, mutability === "payable");
      }
      if (obj.type === "receive") {
        return new FallbackFragment(_guard$2, [], true);
      }
      if (obj.type === "fallback") {
        var _inputs2 = [ParamType.from("bytes")];
        var payable = obj.stateMutability === "payable";
        return new FallbackFragment(_guard$2, _inputs2, payable);
      }
      assertArgument(false, "invalid fallback description", "obj", obj);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === FallbackFragmentInternal;
    }
  }]);
  return FallbackFragment;
}(Fragment);
/**
 *  A Fragment which represents a method.
 */
var FunctionFragment = /*#__PURE__*/function (_NamedFragment3) {
  _inherits(FunctionFragment, _NamedFragment3);
  var _super28 = _createSuper(FunctionFragment);
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */

  /**
   *  The returned types for the result of calling this function.
   */

  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */

  /**
   *  If the function can be sent value during invocation.
   */

  /**
   *  The amount of gas to send when calling this function
   */

  /**
   *  @private
   */
  function FunctionFragment(guard, name, stateMutability, inputs, outputs, gas) {
    var _this26;
    _classCallCheck(this, FunctionFragment);
    _this26 = _super28.call(this, guard, "function", name, inputs);
    _defineProperty(_assertThisInitialized(_this26), "constant", void 0);
    _defineProperty(_assertThisInitialized(_this26), "outputs", void 0);
    _defineProperty(_assertThisInitialized(_this26), "stateMutability", void 0);
    _defineProperty(_assertThisInitialized(_this26), "payable", void 0);
    _defineProperty(_assertThisInitialized(_this26), "gas", void 0);
    Object.defineProperty(_assertThisInitialized(_this26), internal$1, {
      value: FunctionFragmentInternal
    });
    outputs = Object.freeze(outputs.slice());
    var constant = stateMutability === "view" || stateMutability === "pure";
    var payable = stateMutability === "payable";
    defineProperties(_assertThisInitialized(_this26), {
      constant: constant,
      gas: gas,
      outputs: outputs,
      payable: payable,
      stateMutability: stateMutability
    });
    return _this26;
  }
  /**
   *  The Function selector.
   */
  _createClass(FunctionFragment, [{
    key: "selector",
    get: function get() {
      return id(this.format("sighash")).substring(0, 10);
    }
  }, {
    key: "format",
    value: function format(_format8) {
      if (_format8 == null) {
        _format8 = "sighash";
      }
      if (_format8 === "json") {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
          payable: this.payable,
          gas: this.gas != null ? this.gas : undefined,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format8));
          }),
          outputs: this.outputs.map(function (o) {
            return JSON.parse(o.format(_format8));
          })
        });
      }
      var result = [];
      if (_format8 !== "sighash") {
        result.push("function");
      }
      result.push(this.name + joinParams(_format8, this.inputs));
      if (_format8 !== "sighash") {
        if (this.stateMutability !== "nonpayable") {
          result.push(this.stateMutability);
        }
        if (this.outputs && this.outputs.length) {
          result.push("returns");
          result.push(joinParams(_format8, this.outputs));
        }
        if (this.gas != null) {
          result.push("@".concat(this.gas.toString()));
        }
      }
      return result.join(" ");
    }
  }], [{
    key: "getSelector",
    value: function getSelector(name, params) {
      params = (params || []).map(function (p) {
        return ParamType.from(p);
      });
      var fragment = new FunctionFragment(_guard$2, name, "view", params, [], null);
      return fragment.selector;
    }
  }, {
    key: "from",
    value: function from(obj) {
      if (FunctionFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return FunctionFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var name = consumeName("function", obj);
        var inputs = consumeParams(obj);
        var mutability = consumeMutability(obj);
        var outputs = [];
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          outputs = consumeParams(obj);
        }
        var gas = consumeGas(obj);
        consumeEoi(obj);
        return new FunctionFragment(_guard$2, name, mutability, inputs, outputs, gas);
      }
      // @TODO: verifyState for stateMutability
      return new FunctionFragment(_guard$2, obj.name, obj.stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === FunctionFragmentInternal;
    }
  }]);
  return FunctionFragment;
}(NamedFragment);
/**
 *  A Fragment which represents a structure.
 */
exports.FunctionFragment = FunctionFragment;
var StructFragment = /*#__PURE__*/function (_NamedFragment4) {
  _inherits(StructFragment, _NamedFragment4);
  var _super29 = _createSuper(StructFragment);
  /**
   *  @private
   */
  function StructFragment(guard, name, inputs) {
    var _this27;
    _classCallCheck(this, StructFragment);
    _this27 = _super29.call(this, guard, "struct", name, inputs);
    Object.defineProperty(_assertThisInitialized(_this27), internal$1, {
      value: StructFragmentInternal
    });
    return _this27;
  }
  _createClass(StructFragment, [{
    key: "format",
    value: function format() {
      throw new Error("@TODO");
    }
  }], [{
    key: "from",
    value: function from(obj) {
      if (typeof obj === "string") {
        return StructFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var name = consumeName("struct", obj);
        var inputs = consumeParams(obj);
        consumeEoi(obj);
        return new StructFragment(_guard$2, name, inputs);
      }
      return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal$1] === StructFragmentInternal;
    }
  }]);
  return StructFragment;
}(NamedFragment);
/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](solc-abi-standard).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
var PanicReasons$1 = new Map();
PanicReasons$1.set(0x00, "GENERIC_PANIC");
PanicReasons$1.set(0x01, "ASSERT_FALSE");
PanicReasons$1.set(0x11, "OVERFLOW");
PanicReasons$1.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons$1.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons$1.set(0x22, "BAD_STORAGE_DATA");
PanicReasons$1.set(0x31, "STACK_UNDERFLOW");
PanicReasons$1.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(0x41, "OUT_OF_MEMORY");
PanicReasons$1.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
function _getBuiltinCallException(action, tx, data, abiCoder) {
  var message = "missing revert data";
  var reason = null;
  var invocation = null;
  var revert = null;
  if (data) {
    message = "execution reverted";
    var _bytes4 = getBytes(data);
    data = hexlify(data);
    if (_bytes4.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (_bytes4.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(_bytes4.slice(0, 4)) === "0x08c379a0") {
      // Error(string)
      try {
        reason = abiCoder.decode(["string"], _bytes4.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += ": ".concat(JSON.stringify(reason));
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(_bytes4.slice(0, 4)) === "0x4e487b71") {
      // Panic(uint256)
      try {
        var code = Number(abiCoder.decode(["uint256"], _bytes4.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = "Panic due to ".concat(PanicReasons$1.get(code) || "UNKNOWN", "(").concat(code, ")");
        message += ": ".concat(reason);
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  var transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action: action,
    data: data,
    reason: reason,
    transaction: transaction,
    invocation: invocation,
    revert: revert
  });
}
/**
  * About AbiCoder
  */
var _getCoder = /*#__PURE__*/new WeakSet();
var AbiCoder = /*#__PURE__*/function () {
  function AbiCoder() {
    _classCallCheck(this, AbiCoder);
    _classPrivateMethodInitSpec(this, _getCoder);
  }
  _createClass(AbiCoder, [{
    key: "getDefaultValue",
    value:
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    function getDefaultValue(types) {
      var _this28 = this;
      var coders = types.map(function (type) {
        return _classPrivateMethodGet(_this28, _getCoder, _getCoder2).call(_this28, ParamType.from(type));
      });
      var coder = new TupleCoder(coders, "_");
      return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
  }, {
    key: "encode",
    value: function encode(types, values) {
      var _this29 = this;
      assertArgumentCount(values.length, types.length, "types/values length mismatch");
      var coders = types.map(function (type) {
        return _classPrivateMethodGet(_this29, _getCoder, _getCoder2).call(_this29, ParamType.from(type));
      });
      var coder = new TupleCoder(coders, "_");
      var writer = new Writer();
      coder.encode(writer, values);
      return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
  }, {
    key: "decode",
    value: function decode(types, data, loose) {
      var _this30 = this;
      var coders = types.map(function (type) {
        return _classPrivateMethodGet(_this30, _getCoder, _getCoder2).call(_this30, ParamType.from(type));
      });
      var coder = new TupleCoder(coders, "_");
      return coder.decode(new Reader(data, loose));
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
  }], [{
    key: "defaultAbiCoder",
    value: function defaultAbiCoder() {
      if (defaultCoder == null) {
        defaultCoder = new AbiCoder();
      }
      return defaultCoder;
    }
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
  }, {
    key: "getBuiltinCallException",
    value: function getBuiltinCallException(action, tx, data) {
      return _getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
  }]);
  return AbiCoder;
}();
/**
 *  About bytes32 strings...
 *
 *  @_docloc: api/utils:Bytes32 Strings
 */
/**
 *  Encodes %%text%% as a Bytes32 string.
 */
exports.AbiCoder = AbiCoder;
function _getCoder2(param) {
  var _this105 = this;
  if (param.isArray()) {
    return new ArrayCoder(_classPrivateMethodGet(this, _getCoder, _getCoder2).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map(function (c) {
      return _classPrivateMethodGet(_this105, _getCoder, _getCoder2).call(_this105, c);
    }), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  // u?int[0-9]*
  var match = param.type.match(paramTypeNumber);
  if (match) {
    var size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  // bytes[0-9]+
  match = param.type.match(paramTypeBytes);
  if (match) {
    var _size2 = parseInt(match[1]);
    assertArgument(_size2 !== 0 && _size2 <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(_size2, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
}
function encodeBytes32String(text) {
  // Get the bytes
  var bytes = toUtf8Bytes(text);
  // Check we have room for null-termination
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  // Zero-pad (implicitly null-terminates)
  return zeroPadBytes(bytes, 32);
}
/**
 *  Encodes the Bytes32-encoded %%bytes%% into a string.
 */
function decodeBytes32String(_bytes) {
  var data = getBytes(_bytes, "bytes");
  // Must be 32 bytes with a null-termination
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  // Find the null termination
  var length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  // Determine the string value
  return toUtf8String(data.slice(0, length));
}

/**
 *  About Interface
 *
 *  @_subsection api/abi:Interfaces  [interfaces]
 */
var LogDescription = /*#__PURE__*/_createClass(function LogDescription(fragment, topic, args) {
  _classCallCheck(this, LogDescription);
  _defineProperty(this, "fragment", void 0);
  _defineProperty(this, "name", void 0);
  _defineProperty(this, "signature", void 0);
  _defineProperty(this, "topic", void 0);
  _defineProperty(this, "args", void 0);
  var name = fragment.name,
    signature = fragment.format();
  defineProperties(this, {
    fragment: fragment,
    name: name,
    signature: signature,
    topic: topic,
    args: args
  });
});
exports.LogDescription = LogDescription;
var TransactionDescription = /*#__PURE__*/_createClass(function TransactionDescription(fragment, selector, args, value) {
  _classCallCheck(this, TransactionDescription);
  _defineProperty(this, "fragment", void 0);
  _defineProperty(this, "name", void 0);
  _defineProperty(this, "args", void 0);
  _defineProperty(this, "signature", void 0);
  _defineProperty(this, "selector", void 0);
  _defineProperty(this, "value", void 0);
  var name = fragment.name,
    signature = fragment.format();
  defineProperties(this, {
    fragment: fragment,
    name: name,
    args: args,
    signature: signature,
    selector: selector,
    value: value
  });
});
exports.TransactionDescription = TransactionDescription;
var ErrorDescription = /*#__PURE__*/_createClass(function ErrorDescription(fragment, selector, args) {
  _classCallCheck(this, ErrorDescription);
  _defineProperty(this, "fragment", void 0);
  _defineProperty(this, "name", void 0);
  _defineProperty(this, "args", void 0);
  _defineProperty(this, "signature", void 0);
  _defineProperty(this, "selector", void 0);
  var name = fragment.name,
    signature = fragment.format();
  defineProperties(this, {
    fragment: fragment,
    name: name,
    args: args,
    signature: signature,
    selector: selector
  });
});
var Indexed = /*#__PURE__*/function () {
  function Indexed(hash) {
    _classCallCheck(this, Indexed);
    _defineProperty(this, "hash", void 0);
    _defineProperty(this, "_isIndexed", void 0);
    defineProperties(this, {
      hash: hash,
      _isIndexed: true
    });
  }
  _createClass(Indexed, null, [{
    key: "isIndexed",
    value: function isIndexed(value) {
      return !!(value && value._isIndexed);
    }
  }]);
  return Indexed;
}(); // https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
exports.Indexed = Indexed;
var PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: function reason(message) {
      return "reverted with reason string ".concat(JSON.stringify(message));
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: function reason(code) {
      var reason = "unknown panic code";
      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return "reverted with panic code 0x".concat(code.toString(16), " (").concat(reason, ")");
    }
  }
};
/**
 *  An Interface abstracts many of the low-level details for
 *  encoding and decoding the data on the blockchain.
 *
 *  An ABI provides information on how to encode data to send to
 *  a Contract, how to decode the results and events and how to
 *  interpret revert errors.
 *
 *  The ABI can be specified by [any supported format](InterfaceAbi).
 */
var _errors = /*#__PURE__*/new WeakMap();
var _events = /*#__PURE__*/new WeakMap();
var _functions = /*#__PURE__*/new WeakMap();
var _abiCoder = /*#__PURE__*/new WeakMap();
var _getFunction = /*#__PURE__*/new WeakSet();
var _getEvent = /*#__PURE__*/new WeakSet();
var Interface = /*#__PURE__*/function () {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */

  /**
   *  The Contract constructor.
   */

  /**
   *  The Fallback method, if any.
   */

  /**
   *  If receiving ether is supported.
   */

  //    #structs: Map<string, StructFragment>;

  /**
   *  Create a new Interface for the %%fragments%%.
   */
  function Interface(fragments) {
    var _this31 = this;
    _classCallCheck(this, Interface);
    // Find an event definition by any means necessary (unless it is ambiguous)
    _classPrivateMethodInitSpec(this, _getEvent);
    // Find a function definition by any means necessary (unless it is ambiguous)
    _classPrivateMethodInitSpec(this, _getFunction);
    _defineProperty(this, "fragments", void 0);
    _defineProperty(this, "deploy", void 0);
    _defineProperty(this, "fallback", void 0);
    _defineProperty(this, "receive", void 0);
    _classPrivateFieldInitSpec(this, _errors, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _events, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _functions, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _abiCoder, {
      writable: true,
      value: void 0
    });
    var abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    _classPrivateFieldSet(this, _functions, new Map());
    _classPrivateFieldSet(this, _errors, new Map());
    _classPrivateFieldSet(this, _events, new Map());
    //        this.#structs = new Map();
    var frags = [];
    var _iterator18 = _createForOfIteratorHelper(abi),
      _step18;
    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var a = _step18.value;
        try {
          frags.push(Fragment.from(a));
        } catch (error) {
          console.log("EE", error);
        }
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    var fallback = null;
    var receive = false;
    _classPrivateFieldSet(this, _abiCoder, this.getAbiCoder());
    // Add all fragments by their signature
    this.fragments.forEach(function (fragment, index) {
      var bucket;
      switch (fragment.type) {
        case "constructor":
          if (_this31.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          //checkNames(fragment, "input", fragment.inputs);
          defineProperties(_this31, {
            deploy: fragment
          });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", "fragments[".concat(index, "]"), fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          //checkNames(fragment, "input", fragment.inputs);
          //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
          bucket = _classPrivateFieldGet(_this31, _functions);
          break;
        case "event":
          //checkNames(fragment, "input", fragment.inputs);
          bucket = _classPrivateFieldGet(_this31, _events);
          break;
        case "error":
          bucket = _classPrivateFieldGet(_this31, _errors);
          break;
        default:
          return;
      }
      // Two identical entries; ignore it
      var signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    // If we do not have a constructor add a default
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, {
      fallback: fallback,
      receive: receive
    });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  _createClass(Interface, [{
    key: "format",
    value: function format(minimal) {
      var format = minimal ? "minimal" : "full";
      var abi = this.fragments.map(function (f) {
        return f.format(format);
      });
      return abi;
    }
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
  }, {
    key: "formatJson",
    value: function formatJson() {
      var abi = this.fragments.map(function (f) {
        return f.format("json");
      });
      // We need to re-bundle the JSON fragments a bit
      return JSON.stringify(abi.map(function (j) {
        return JSON.parse(j);
      }));
    }
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
  }, {
    key: "getAbiCoder",
    value: function getAbiCoder() {
      return AbiCoder.defaultAbiCoder();
    }
  }, {
    key: "getFunctionName",
    value:
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    function getFunctionName(key) {
      var fragment = _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);
      assertArgument(fragment, "no matching function", "key", key);
      return fragment.name;
    }
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
  }, {
    key: "getFunction",
    value: function getFunction(key, values) {
      return _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, values || null, true);
    }
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachFunction",
    value: function forEachFunction(callback) {
      var names = Array.from(_classPrivateFieldGet(this, _functions).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var _i46 = 0; _i46 < names.length; _i46++) {
        var name = names[_i46];
        callback(_classPrivateFieldGet(this, _functions).get(name), _i46);
      }
    }
  }, {
    key: "getEventName",
    value:
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    function getEventName(key) {
      var fragment = _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);
      assertArgument(fragment, "no matching event", "key", key);
      return fragment.name;
    }
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
  }, {
    key: "getEvent",
    value: function getEvent(key, values) {
      return _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, values || null, true);
    }
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachEvent",
    value: function forEachEvent(callback) {
      var names = Array.from(_classPrivateFieldGet(this, _events).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var _i47 = 0; _i47 < names.length; _i47++) {
        var name = names[_i47];
        callback(_classPrivateFieldGet(this, _events).get(name), _i47);
      }
    }
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
  }, {
    key: "getError",
    value: function getError(key, values) {
      if (isHexString(key)) {
        var selector = key.toLowerCase();
        if (BuiltinErrors[selector]) {
          return ErrorFragment.from(BuiltinErrors[selector].signature);
        }
        var _iterator19 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors).values()),
          _step19;
        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var fragment = _step19.value;
            if (selector === fragment.selector) {
              return fragment;
            }
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }
        return null;
      }
      // It is a bare name, look up the function (will return null if ambiguous)
      if (key.indexOf("(") === -1) {
        var matching = [];
        var _iterator20 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors)),
          _step20;
        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var _step20$value = _slicedToArray(_step20.value, 2),
              name = _step20$value[0],
              _fragment = _step20$value[1];
            if (name.split("(" /* fix:) */)[0] === key) {
              matching.push(_fragment);
            }
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
        if (matching.length === 0) {
          if (key === "Error") {
            return ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic") {
            return ErrorFragment.from("error Panic(uint256)");
          }
          return null;
        } else if (matching.length > 1) {
          var matchStr = matching.map(function (m) {
            return JSON.stringify(m.format());
          }).join(", ");
          assertArgument(false, "ambiguous error description (i.e. ".concat(matchStr, ")"), "name", key);
        }
        return matching[0];
      }
      // Normalize the signature and lookup the function
      key = ErrorFragment.from(key).format();
      if (key === "Error(string)") {
        return ErrorFragment.from("error Error(string)");
      }
      if (key === "Panic(uint256)") {
        return ErrorFragment.from("error Panic(uint256)");
      }
      var result = _classPrivateFieldGet(this, _errors).get(key);
      if (result) {
        return result;
      }
      return null;
    }
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachError",
    value: function forEachError(callback) {
      var names = Array.from(_classPrivateFieldGet(this, _errors).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var _i48 = 0; _i48 < names.length; _i48++) {
        var name = names[_i48];
        callback(_classPrivateFieldGet(this, _errors).get(name), _i48);
      }
    }
    // Get the 4-byte selector used by Solidity to identify a function
    /*
    getSelector(fragment: ErrorFragment | FunctionFragment): string {
    if (typeof(fragment) === "string") {
        const matches: Array<Fragment> = [ ];
         try { matches.push(this.getFunction(fragment)); } catch (error) { }
        try { matches.push(this.getError(<string>fragment)); } catch (_) { }
         if (matches.length === 0) {
            logger.throwArgumentError("unknown fragment", "key", fragment);
        } else if (matches.length > 1) {
            logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
        }
         fragment = matches[0];
    }
     return dataSlice(id(fragment.format()), 0, 4);
    }
    */
    // Get the 32-byte topic hash used by Solidity to identify an event
    /*
    getEventTopic(fragment: EventFragment): string {
        //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
        return id(fragment.format());
    }
    */
  }, {
    key: "_decodeParams",
    value: function _decodeParams(params, data) {
      return _classPrivateFieldGet(this, _abiCoder).decode(params, data);
    }
  }, {
    key: "_encodeParams",
    value: function _encodeParams(params, values) {
      return _classPrivateFieldGet(this, _abiCoder).encode(params, values);
    }
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
  }, {
    key: "encodeDeploy",
    value: function encodeDeploy(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
  }, {
    key: "decodeErrorResult",
    value: function decodeErrorResult(fragment, data) {
      if (typeof fragment === "string") {
        var _f2 = this.getError(fragment);
        assertArgument(_f2, "unknown error", "fragment", fragment);
        fragment = _f2;
      }
      assertArgument(dataSlice(data, 0, 4) === fragment.selector, "data signature does not match error ".concat(fragment.name, "."), "data", data);
      return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
  }, {
    key: "encodeErrorResult",
    value: function encodeErrorResult(fragment, values) {
      if (typeof fragment === "string") {
        var _f3 = this.getError(fragment);
        assertArgument(_f3, "unknown error", "fragment", fragment);
        fragment = _f3;
      }
      return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
    }
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
  }, {
    key: "decodeFunctionData",
    value: function decodeFunctionData(fragment, data) {
      if (typeof fragment === "string") {
        var _f4 = this.getFunction(fragment);
        assertArgument(_f4, "unknown function", "fragment", fragment);
        fragment = _f4;
      }
      assertArgument(dataSlice(data, 0, 4) === fragment.selector, "data signature does not match function ".concat(fragment.name, "."), "data", data);
      return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
  }, {
    key: "encodeFunctionData",
    value: function encodeFunctionData(fragment, values) {
      if (typeof fragment === "string") {
        var _f5 = this.getFunction(fragment);
        assertArgument(_f5, "unknown function", "fragment", fragment);
        fragment = _f5;
      }
      return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
  }, {
    key: "decodeFunctionResult",
    value: function decodeFunctionResult(fragment, data) {
      if (typeof fragment === "string") {
        var _f6 = this.getFunction(fragment);
        assertArgument(_f6, "unknown function", "fragment", fragment);
        fragment = _f6;
      }
      var message = "invalid length for result data";
      var bytes = getBytesCopy(data);
      if (bytes.length % 32 === 0) {
        try {
          return _classPrivateFieldGet(this, _abiCoder).decode(fragment.outputs, bytes);
        } catch (error) {
          message = "could not decode result data";
        }
      }
      // Call returned data with no error, but the data is junk
      assert$1(false, message, "BAD_DATA", {
        value: hexlify(bytes),
        info: {
          method: fragment.name,
          signature: fragment.format()
        }
      });
    }
  }, {
    key: "makeError",
    value: function makeError(_data, tx) {
      var data = getBytes(_data, "data");
      var error = AbiCoder.getBuiltinCallException("call", tx, data);
      // Not a built-in error; try finding a custom error
      var customPrefix = "execution reverted (unknown custom error)";
      if (error.message.startsWith(customPrefix)) {
        var selector = hexlify(data.slice(0, 4));
        var ef = this.getError(selector);
        if (ef) {
          try {
            var args = _classPrivateFieldGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
            error.revert = {
              name: ef.name,
              signature: ef.format(),
              args: args
            };
            error.reason = error.revert.signature;
            error.message = "execution reverted: ".concat(error.reason);
          } catch (e) {
            error.message = "execution reverted (coult not decode custom error)";
          }
        }
      }
      // Add the invocation, if available
      var parsed = this.parseTransaction(tx);
      if (parsed) {
        error.invocation = {
          method: parsed.name,
          signature: parsed.signature,
          args: parsed.args
        };
      }
      return error;
    }
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
  }, {
    key: "encodeFunctionResult",
    value: function encodeFunctionResult(fragment, values) {
      if (typeof fragment === "string") {
        var _f7 = this.getFunction(fragment);
        assertArgument(_f7, "unknown function", "fragment", fragment);
        fragment = _f7;
      }
      return hexlify(_classPrivateFieldGet(this, _abiCoder).encode(fragment.outputs, values || []));
    }
    /*
        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
            const promises: Array<Promise<>> = [ ];
            const process = function(type: ParamType, value: any): any {
                if (type.baseType === "array") {
                    return descend(type.child
                }
                if (type. === "address") {
                }
            };
    
            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                
            };
    
            const result: Array<any> = [ ];
            values.forEach((value, index) => {
                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            });
        }
    */
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  }, {
    key: "encodeFilterTopics",
    value: function encodeFilterTopics(fragment, values) {
      var _this32 = this;
      if (typeof fragment === "string") {
        var _f8 = this.getEvent(fragment);
        assertArgument(_f8, "unknown event", "eventFragment", fragment);
        fragment = _f8;
      }
      assert$1(values.length <= fragment.inputs.length, "too many arguments for ".concat(fragment.format()), "UNEXPECTED_ARGUMENT", {
        count: values.length,
        expectedCount: fragment.inputs.length
      });
      var topics = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      // @TODO: Use the coders for this; to properly support tuples, etc.
      var encodeTopic = function encodeTopic(param, value) {
        if (param.type === "string") {
          return id(value);
        } else if (param.type === "bytes") {
          return keccak256(hexlify(value));
        }
        if (param.type === "bool" && typeof value === "boolean") {
          value = value ? "0x01" : "0x00";
        }
        if (param.type.match(/^u?int/)) {
          value = toBeHex(value);
        }
        // Check addresses are valid
        if (param.type === "address") {
          _classPrivateFieldGet(_this32, _abiCoder).encode(["address"], [value]);
        }
        return zeroPadValue(hexlify(value), 32);
        //@TOOD should probably be return toHex(value, 32)
      };

      values.forEach(function (value, index) {
        var param = fragment.inputs[index];
        if (!param.indexed) {
          assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map(function (value) {
            return encodeTopic(param, value);
          }));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      // Trim off trailing nulls
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    }
  }, {
    key: "encodeEventLog",
    value: function encodeEventLog(fragment, values) {
      var _this33 = this;
      if (typeof fragment === "string") {
        var _f9 = this.getEvent(fragment);
        assertArgument(_f9, "unknown event", "eventFragment", fragment);
        fragment = _f9;
      }
      var topics = [];
      var dataTypes = [];
      var dataValues = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
      fragment.inputs.forEach(function (param, index) {
        var value = values[index];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push(id(value));
          } else if (param.type === "bytes") {
            topics.push(keccak256(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            // @TODO
            throw new Error("not implemented");
          } else {
            topics.push(_classPrivateFieldGet(_this33, _abiCoder).encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: _classPrivateFieldGet(this, _abiCoder).encode(dataTypes, dataValues),
        topics: topics
      };
    }
    // Decode a filter for the event and the search criteria
  }, {
    key: "decodeEventLog",
    value: function decodeEventLog(fragment, data, topics) {
      if (typeof fragment === "string") {
        var _f10 = this.getEvent(fragment);
        assertArgument(_f10, "unknown event", "eventFragment", fragment);
        fragment = _f10;
      }
      if (topics != null && !fragment.anonymous) {
        var eventTopic = fragment.topicHash;
        assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
        topics = topics.slice(1);
      }
      var indexed = [];
      var nonIndexed = [];
      var dynamic = [];
      fragment.inputs.forEach(function (param, index) {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(ParamType.from({
              type: "bytes32",
              name: param.name
            }));
            dynamic.push(true);
          } else {
            indexed.push(param);
            dynamic.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic.push(false);
        }
      });
      var resultIndexed = topics != null ? _classPrivateFieldGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
      var resultNonIndexed = _classPrivateFieldGet(this, _abiCoder).decode(nonIndexed, data, true);
      //const result: (Array<any> & { [ key: string ]: any }) = [ ];
      var values = [];
      var keys = [];
      var nonIndexedIndex = 0,
        indexedIndex = 0;
      fragment.inputs.forEach(function (param, index) {
        var value = null;
        if (param.indexed) {
          if (resultIndexed == null) {
            value = new Indexed(null);
          } else if (dynamic[index]) {
            value = new Indexed(resultIndexed[indexedIndex++]);
          } else {
            try {
              value = resultIndexed[indexedIndex++];
            } catch (error) {
              value = error;
            }
          }
        } else {
          try {
            value = resultNonIndexed[nonIndexedIndex++];
          } catch (error) {
            value = error;
          }
        }
        values.push(value);
        keys.push(param.name || null);
      });
      return Result.fromItems(values, keys);
    }
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
  }, {
    key: "parseTransaction",
    value: function parseTransaction(tx) {
      var data = getBytes(tx.data, "tx.data");
      var value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
      var fragment = this.getFunction(hexlify(data.slice(0, 4)));
      if (!fragment) {
        return null;
      }
      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
      return new TransactionDescription(fragment, fragment.selector, args, value);
    }
  }, {
    key: "parseCallResult",
    value: function parseCallResult(data) {
      throw new Error("@TODO");
    }
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
  }, {
    key: "parseLog",
    value: function parseLog(log) {
      var fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
      //        Probably not, because just because it is the only event in the ABI does
      //        not mean we have the full ABI; maybe just a fragment?
      return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching event cannot be found, returns null.
     */
  }, {
    key: "parseError",
    value: function parseError(data) {
      var hexData = hexlify(data);
      var fragment = this.getError(dataSlice(hexData, 0, 4));
      if (!fragment) {
        return null;
      }
      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
      return new ErrorDescription(fragment, fragment.selector, args);
    }
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
  }], [{
    key: "from",
    value: function from(value) {
      // Already an Interface, which is immutable
      if (value instanceof Interface) {
        return value;
      }
      // JSON
      if (typeof value === "string") {
        return new Interface(JSON.parse(value));
      }
      // Maybe an interface from an older version, or from a symlinked copy
      if (typeof value.format === "function") {
        return new Interface(value.format("json"));
      }
      // Array of fragments
      return new Interface(value);
    }
  }]);
  return Interface;
}();
/**
 *  Explain about ABI here...
 *
 *  @_section api/abi:Application Binary Interface  [about-abi]
 *  @_navTitle: ABI
 */
//import { resolveAddress } from "@ethersproject/address";
exports.Interface = Interface;
function _getFunction2(key, values, forceUnique) {
  // Selector
  if (isHexString(key)) {
    var selector = key.toLowerCase();
    var _iterator56 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions).values()),
      _step56;
    try {
      for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
        var fragment = _step56.value;
        if (selector === fragment.selector) {
          return fragment;
        }
      }
    } catch (err) {
      _iterator56.e(err);
    } finally {
      _iterator56.f();
    }
    return null;
  }
  // It is a bare name, look up the function (will return null if ambiguous)
  if (key.indexOf("(") === -1) {
    var matching = [];
    var _iterator57 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions)),
      _step57;
    try {
      for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
        var _step57$value = _slicedToArray(_step57.value, 2),
          name = _step57$value[0],
          _fragment2 = _step57$value[1];
        if (name.split("(" /* fix:) */)[0] === key) {
          matching.push(_fragment2);
        }
      }
    } catch (err) {
      _iterator57.e(err);
    } finally {
      _iterator57.f();
    }
    if (values) {
      var lastValue = values.length > 0 ? values[values.length - 1] : null;
      var valueLength = values.length;
      var allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      // Remove all matches that don't have a compatible length. The args
      // may contain an overrides, so the match may have n or n - 1 parameters
      for (var _i93 = matching.length - 1; _i93 >= 0; _i93--) {
        var inputs = matching[_i93].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(_i93, 1);
        }
      }
      // Remove all matches that don't match the Typed signature
      for (var _i94 = matching.length - 1; _i94 >= 0; _i94--) {
        var _inputs3 = matching[_i94].inputs;
        for (var _j11 = 0; _j11 < values.length; _j11++) {
          // Not a typed value
          if (!Typed.isTyped(values[_j11])) {
            continue;
          }
          // We are past the inputs
          if (_j11 >= _inputs3.length) {
            if (values[_j11].type === "overrides") {
              continue;
            }
            matching.splice(_i94, 1);
            break;
          }
          // Make sure the value type matches the input type
          if (values[_j11].type !== _inputs3[_j11].baseType) {
            matching.splice(_i94, 1);
            break;
          }
        }
      }
    }
    // We found a single matching signature with an overrides, but the
    // last value is something that cannot possibly be an options
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      var lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || _typeof(lastArg) !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      var matchStr = matching.map(function (m) {
        return JSON.stringify(m.format());
      }).join(", ");
      assertArgument(false, "ambiguous function description (i.e. matches ".concat(matchStr, ")"), "key", key);
    }
    return matching[0];
  }
  // Normalize the signature and lookup the function
  var result = _classPrivateFieldGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
}
function _getEvent2(key, values, forceUnique) {
  // EventTopic
  if (isHexString(key)) {
    var eventTopic = key.toLowerCase();
    var _iterator58 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events).values()),
      _step58;
    try {
      for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
        var fragment = _step58.value;
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
    } catch (err) {
      _iterator58.e(err);
    } finally {
      _iterator58.f();
    }
    return null;
  }
  // It is a bare name, look up the function (will return null if ambiguous)
  if (key.indexOf("(") === -1) {
    var matching = [];
    var _iterator59 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events)),
      _step59;
    try {
      for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
        var _step59$value = _slicedToArray(_step59.value, 2),
          name = _step59$value[0],
          _fragment3 = _step59$value[1];
        if (name.split("(" /* fix:) */)[0] === key) {
          matching.push(_fragment3);
        }
      }
    } catch (err) {
      _iterator59.e(err);
    } finally {
      _iterator59.f();
    }
    if (values) {
      // Remove all matches that don't have a compatible length.
      for (var _i95 = matching.length - 1; _i95 >= 0; _i95--) {
        if (matching[_i95].inputs.length < values.length) {
          matching.splice(_i95, 1);
        }
      }
      // Remove all matches that don't match the Typed signature
      for (var _i96 = matching.length - 1; _i96 >= 0; _i96--) {
        var inputs = matching[_i96].inputs;
        for (var _j12 = 0; _j12 < values.length; _j12++) {
          // Not a typed value
          if (!Typed.isTyped(values[_j12])) {
            continue;
          }
          // Make sure the value type matches the input type
          if (values[_j12].type !== inputs[_j12].baseType) {
            matching.splice(_i96, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      var matchStr = matching.map(function (m) {
        return JSON.stringify(m.format());
      }).join(", ");
      assertArgument(false, "ambiguous event description (i.e. matches ".concat(matchStr, ")"), "key", key);
    }
    return matching[0];
  }
  // Normalize the signature and lookup the function
  var result = _classPrivateFieldGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
}
var BN_0$2 = BigInt(0);
// -----------------------
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
// @TODO? <T extends FeeData = { }> implements Required<T>
/**
 *  A **FeeData** wraps all the fee-related values associated with
 *  the network.
 */
var FeeData = /*#__PURE__*/function () {
  /**
   *  The gas price for legacy networks.
   */

  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */

  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */

  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  function FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    _classCallCheck(this, FeeData);
    _defineProperty(this, "gasPrice", void 0);
    _defineProperty(this, "maxFeePerGas", void 0);
    _defineProperty(this, "maxPriorityFeePerGas", void 0);
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  _createClass(FeeData, [{
    key: "toJSON",
    value: function toJSON() {
      var gasPrice = this.gasPrice,
        maxFeePerGas = this.maxFeePerGas,
        maxPriorityFeePerGas = this.maxPriorityFeePerGas;
      return {
        _type: "FeeData",
        gasPrice: toJson(gasPrice),
        maxFeePerGas: toJson(maxFeePerGas),
        maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
      };
    }
  }]);
  return FeeData;
}();
exports.FeeData = FeeData;
;
function copyRequest(req) {
  var result = {};
  // These could be addresses, ENS names or Addressables
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  var bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  var _iterator21 = _createForOfIteratorHelper(bigIntKeys),
    _step21;
  try {
    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
      var key = _step21.value;
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = getBigInt(req[key], "request.".concat(key));
    }
  } catch (err) {
    _iterator21.e(err);
  } finally {
    _iterator21.f();
  }
  var numberKeys = "type,nonce".split(/,/);
  var _iterator22 = _createForOfIteratorHelper(numberKeys),
    _step22;
  try {
    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
      var _key14 = _step22.value;
      if (!(_key14 in req) || req[_key14] == null) {
        continue;
      }
      result[_key14] = getNumber(req[_key14], "request.".concat(_key14));
    }
  } catch (err) {
    _iterator22.e(err);
  } finally {
    _iterator22.f();
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipReadEnabled = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  return result;
}
/**
 *  A **Block** represents the data associated with a full block on
 *  Ethereum.
 */
var _transactions = /*#__PURE__*/new WeakMap();
_Symbol$iterator3 = Symbol.iterator;
var Block = /*#__PURE__*/function () {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */

  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */

  /**
   *  The block hash.
   */

  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */

  /**
   *  The block hash of the parent block.
   */

  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */

  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */

  /**
   *  The total gas limit for this block.
   */

  /**
   *  The total gas used in this block.
   */

  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */

  /**
   *  Any extra data the validator wished to include.
   */

  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */

  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  function Block(block, provider) {
    _classCallCheck(this, Block);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "number", void 0);
    _defineProperty(this, "hash", void 0);
    _defineProperty(this, "timestamp", void 0);
    _defineProperty(this, "parentHash", void 0);
    _defineProperty(this, "nonce", void 0);
    _defineProperty(this, "difficulty", void 0);
    _defineProperty(this, "gasLimit", void 0);
    _defineProperty(this, "gasUsed", void 0);
    _defineProperty(this, "miner", void 0);
    _defineProperty(this, "extraData", void 0);
    _defineProperty(this, "baseFeePerGas", void 0);
    _classPrivateFieldInitSpec(this, _transactions, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _transactions, block.transactions.map(function (tx) {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    defineProperties(this, {
      provider: provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      miner: block.miner,
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas)
    });
  }
  /**
   *  Returns the list of transaction hashes.
   */
  _createClass(Block, [{
    key: "transactions",
    get: function get() {
      return _classPrivateFieldGet(this, _transactions).map(function (tx) {
        if (typeof tx === "string") {
          return tx;
        }
        return tx.hash;
      });
    }
    /**
     *  Returns the complete transactions for blocks which
     *  prefetched them, by passing ``true`` to %%prefetchTxs%%
     *  into [[provider_getBlock]].
     */
  }, {
    key: "prefetchedTransactions",
    get: function get() {
      var txs = _classPrivateFieldGet(this, _transactions).slice();
      // Doesn't matter...
      if (txs.length === 0) {
        return [];
      }
      // Make sure we prefetched the transactions
      assert$1(_typeof(txs[0]) === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
        operation: "transactionResponses()"
      });
      return txs;
    }
    /**
     *  Returns a JSON-friendly value.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var baseFeePerGas = this.baseFeePerGas,
        difficulty = this.difficulty,
        extraData = this.extraData,
        gasLimit = this.gasLimit,
        gasUsed = this.gasUsed,
        hash = this.hash,
        miner = this.miner,
        nonce = this.nonce,
        number = this.number,
        parentHash = this.parentHash,
        timestamp = this.timestamp,
        transactions = this.transactions;
      return {
        _type: "Block",
        baseFeePerGas: toJson(baseFeePerGas),
        difficulty: toJson(difficulty),
        extraData: extraData,
        gasLimit: toJson(gasLimit),
        gasUsed: toJson(gasUsed),
        hash: hash,
        miner: miner,
        nonce: nonce,
        number: number,
        parentHash: parentHash,
        timestamp: timestamp,
        transactions: transactions
      };
    }
  }, {
    key: _Symbol$iterator3,
    value: function value() {
      var _this34 = this;
      var index = 0;
      var txs = this.transactions;
      return {
        next: function next() {
          if (index < _this34.length) {
            return {
              value: txs[index++],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
    /**
     *  The number of transactions in this block.
     */
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(this, _transactions).length;
    }
    /**
     *  The [[link-js-date]] this block was included at.
     */
  }, {
    key: "date",
    get: function get() {
      if (this.timestamp == null) {
        return null;
      }
      return new Date(this.timestamp * 1000);
    }
    /**
     *  Get the transaction at %%indexe%% within this block.
     */
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(indexOrHash) {
        var tx, _hash3, _iterator23, _step23, v;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              // Find the internal value by its index or hash
              tx = undefined;
              if (!(typeof indexOrHash === "number")) {
                _context13.next = 5;
                break;
              }
              tx = _classPrivateFieldGet(this, _transactions)[indexOrHash];
              _context13.next = 32;
              break;
            case 5:
              _hash3 = indexOrHash.toLowerCase();
              _iterator23 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _transactions));
              _context13.prev = 7;
              _iterator23.s();
            case 9:
              if ((_step23 = _iterator23.n()).done) {
                _context13.next = 24;
                break;
              }
              v = _step23.value;
              if (!(typeof v === "string")) {
                _context13.next = 18;
                break;
              }
              if (!(v !== _hash3)) {
                _context13.next = 14;
                break;
              }
              return _context13.abrupt("continue", 22);
            case 14:
              tx = v;
              return _context13.abrupt("break", 24);
            case 18:
              if (!(v.hash === _hash3)) {
                _context13.next = 20;
                break;
              }
              return _context13.abrupt("continue", 22);
            case 20:
              tx = v;
              return _context13.abrupt("break", 24);
            case 22:
              _context13.next = 9;
              break;
            case 24:
              _context13.next = 29;
              break;
            case 26:
              _context13.prev = 26;
              _context13.t0 = _context13["catch"](7);
              _iterator23.e(_context13.t0);
            case 29:
              _context13.prev = 29;
              _iterator23.f();
              return _context13.finish(29);
            case 32:
              if (!(tx == null)) {
                _context13.next = 34;
                break;
              }
              throw new Error("no such tx");
            case 34:
              if (!(typeof tx === "string")) {
                _context13.next = 40;
                break;
              }
              _context13.next = 37;
              return this.provider.getTransaction(tx);
            case 37:
              return _context13.abrupt("return", _context13.sent);
            case 40:
              return _context13.abrupt("return", tx);
            case 41:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[7, 26, 29, 32]]);
      }));
      function getTransaction(_x57) {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getPrefetchedTransaction",
    value: function getPrefetchedTransaction(indexOrHash) {
      var txs = this.prefetchedTransactions;
      if (typeof indexOrHash === "number") {
        return txs[indexOrHash];
      }
      indexOrHash = indexOrHash.toLowerCase();
      var _iterator24 = _createForOfIteratorHelper(txs),
        _step24;
      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var tx = _step24.value;
          if (tx.hash === indexOrHash) {
            return tx;
          }
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
      assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
    }
    /**
     *  Has this block been mined.
     *
     *  If true, the block has been typed-gaurded that all mined
     *  properties are non-null.
     */
  }, {
    key: "isMined",
    value: function isMined() {
      return !!this.hash;
    }
    /**
     *
     */
  }, {
    key: "isLondon",
    value: function isLondon() {
      return !!this.baseFeePerGas;
    }
  }, {
    key: "orphanedEvent",
    value: function orphanedEvent() {
      if (!this.isMined()) {
        throw new Error("");
      }
      return createOrphanedBlockFilter(this);
    }
  }]);
  return Block;
}(); //////////////////////
// Log
exports.Block = Block;
var Log = /*#__PURE__*/function () {
  function Log(log, provider) {
    _classCallCheck(this, Log);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "transactionHash", void 0);
    _defineProperty(this, "blockHash", void 0);
    _defineProperty(this, "blockNumber", void 0);
    _defineProperty(this, "removed", void 0);
    _defineProperty(this, "address", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "topics", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "transactionIndex", void 0);
    this.provider = provider;
    var topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics: topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  _createClass(Log, [{
    key: "toJSON",
    value: function toJSON() {
      var address = this.address,
        blockHash = this.blockHash,
        blockNumber = this.blockNumber,
        data = this.data,
        index = this.index,
        removed = this.removed,
        topics = this.topics,
        transactionHash = this.transactionHash,
        transactionIndex = this.transactionIndex;
      return {
        _type: "log",
        address: address,
        blockHash: blockHash,
        blockNumber: blockNumber,
        data: data,
        index: index,
        removed: removed,
        topics: topics,
        transactionHash: transactionHash,
        transactionIndex: transactionIndex
      };
    }
  }, {
    key: "getBlock",
    value: function () {
      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var block;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.provider.getBlock(this.blockHash);
            case 2:
              block = _context14.sent;
              assert$1(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
              return _context14.abrupt("return", block);
            case 5:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getBlock() {
        return _getBlock.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var tx;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.provider.getTransaction(this.transactionHash);
            case 2:
              tx = _context15.sent;
              assert$1(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
              return _context15.abrupt("return", tx);
            case 5:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function getTransaction() {
        return _getTransaction2.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getTransactionReceipt",
    value: function () {
      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var receipt;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.provider.getTransactionReceipt(this.transactionHash);
            case 2:
              receipt = _context16.sent;
              assert$1(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
              return _context16.abrupt("return", receipt);
            case 5:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function getTransactionReceipt() {
        return _getTransactionReceipt.apply(this, arguments);
      }
      return getTransactionReceipt;
    }()
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      return createRemovedLogFilter(this);
    }
  }]);
  return Log;
}(); //////////////////////
// Transaction Receipt
/*
export interface LegacyTransactionReceipt {
    byzantium: false;
    status: null;
    root: string;
}

export interface ByzantiumTransactionReceipt {
    byzantium: true;
    status: number;
    root: null;
}
*/
exports.Log = Log;
var _logs = /*#__PURE__*/new WeakMap();
_Symbol$iterator4 = Symbol.iterator;
var TransactionReceipt = /*#__PURE__*/function () {
  //readonly byzantium!: boolean;

  function TransactionReceipt(tx, provider) {
    _classCallCheck(this, TransactionReceipt);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "to", void 0);
    _defineProperty(this, "from", void 0);
    _defineProperty(this, "contractAddress", void 0);
    _defineProperty(this, "hash", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "blockHash", void 0);
    _defineProperty(this, "blockNumber", void 0);
    _defineProperty(this, "logsBloom", void 0);
    _defineProperty(this, "gasUsed", void 0);
    _defineProperty(this, "cumulativeGasUsed", void 0);
    _defineProperty(this, "gasPrice", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "status", void 0);
    _defineProperty(this, "root", void 0);
    _classPrivateFieldInitSpec(this, _logs, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _logs, Object.freeze(tx.logs.map(function (log) {
      return new Log(log, provider);
    })));
    defineProperties(this, {
      provider: provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      gasPrice: tx.effectiveGasPrice || tx.gasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  _createClass(TransactionReceipt, [{
    key: "logs",
    get: function get() {
      return _classPrivateFieldGet(this, _logs);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var to = this.to,
        from = this.from,
        contractAddress = this.contractAddress,
        hash = this.hash,
        index = this.index,
        blockHash = this.blockHash,
        blockNumber = this.blockNumber,
        logsBloom = this.logsBloom,
        logs = this.logs,
        status = this.status,
        root = this.root;
      return {
        _type: "TransactionReceipt",
        blockHash: blockHash,
        blockNumber: blockNumber,
        //byzantium, 
        contractAddress: contractAddress,
        cumulativeGasUsed: toJson(this.cumulativeGasUsed),
        from: from,
        gasPrice: toJson(this.gasPrice),
        gasUsed: toJson(this.gasUsed),
        hash: hash,
        index: index,
        logs: logs,
        logsBloom: logsBloom,
        root: root,
        status: status,
        to: to
      };
    }
  }, {
    key: "length",
    get: function get() {
      return this.logs.length;
    }
  }, {
    key: _Symbol$iterator4,
    value: function value() {
      var _this35 = this;
      var index = 0;
      return {
        next: function next() {
          if (index < _this35.length) {
            return {
              value: _this35.logs[index++],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
  }, {
    key: "fee",
    get: function get() {
      return this.gasUsed * this.gasPrice;
    }
  }, {
    key: "getBlock",
    value: function () {
      var _getBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var block;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.provider.getBlock(this.blockHash);
            case 2:
              block = _context17.sent;
              if (!(block == null)) {
                _context17.next = 5;
                break;
              }
              throw new Error("TODO");
            case 5:
              return _context17.abrupt("return", block);
            case 6:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function getBlock() {
        return _getBlock2.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        var tx;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this.provider.getTransaction(this.hash);
            case 2:
              tx = _context18.sent;
              if (!(tx == null)) {
                _context18.next = 5;
                break;
              }
              throw new Error("TODO");
            case 5:
              return _context18.abrupt("return", tx);
            case 6:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function getTransaction() {
        return _getTransaction3.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getResult",
    value: function () {
      var _getResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return this.provider.getTransactionResult(this.hash);
            case 2:
              return _context19.abrupt("return", _context19.sent);
            case 3:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function getResult() {
        return _getResult.apply(this, arguments);
      }
      return getResult;
    }()
  }, {
    key: "confirmations",
    value: function () {
      var _confirmations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.provider.getBlockNumber();
            case 2:
              _context20.t0 = _context20.sent;
              _context20.t1 = this.blockNumber;
              _context20.t2 = _context20.t0 - _context20.t1;
              return _context20.abrupt("return", _context20.t2 + 1);
            case 6:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function confirmations() {
        return _confirmations.apply(this, arguments);
      }
      return confirmations;
    }()
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      return createRemovedTransactionFilter(this);
    }
  }, {
    key: "reorderedEvent",
    value: function reorderedEvent(other) {
      assert$1(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "reorderedEvent(other)"
      });
      return createReorderedTransactionFilter(this, other);
    }
  }]);
  return TransactionReceipt;
}();
/*
export type ReplacementDetectionSetup = {
    to: string;
    from: string;
    value: bigint;
    data: string;
    nonce: number;
    block: number;
};
*/
exports.TransactionReceipt = TransactionReceipt;
var _startBlock = /*#__PURE__*/new WeakMap();
var TransactionResponse = /*#__PURE__*/function () {
  function TransactionResponse(tx, provider) {
    _classCallCheck(this, TransactionResponse);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockNumber", void 0);
    _defineProperty(this, "blockHash", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "hash", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "to", void 0);
    _defineProperty(this, "from", void 0);
    _defineProperty(this, "nonce", void 0);
    _defineProperty(this, "gasLimit", void 0);
    _defineProperty(this, "gasPrice", void 0);
    _defineProperty(this, "maxPriorityFeePerGas", void 0);
    _defineProperty(this, "maxFeePerGas", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "value", void 0);
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "signature", void 0);
    _defineProperty(this, "accessList", void 0);
    _classPrivateFieldInitSpec(this, _startBlock, {
      writable: true,
      value: void 0
    });
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    _classPrivateFieldSet(this, _startBlock, -1);
  }
  _createClass(TransactionResponse, [{
    key: "toJSON",
    value: function toJSON() {
      var blockNumber = this.blockNumber,
        blockHash = this.blockHash,
        index = this.index,
        hash = this.hash,
        type = this.type,
        to = this.to,
        from = this.from,
        nonce = this.nonce,
        data = this.data,
        signature = this.signature,
        accessList = this.accessList;
      return {
        _type: "TransactionReceipt",
        accessList: accessList,
        blockNumber: blockNumber,
        blockHash: blockHash,
        chainId: toJson(this.chainId),
        data: data,
        from: from,
        gasLimit: toJson(this.gasLimit),
        gasPrice: toJson(this.gasPrice),
        hash: hash,
        maxFeePerGas: toJson(this.maxFeePerGas),
        maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
        nonce: nonce,
        signature: signature,
        to: to,
        index: index,
        type: type,
        value: toJson(this.value)
      };
    }
  }, {
    key: "getBlock",
    value: function () {
      var _getBlock3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        var blockNumber, tx, block;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              blockNumber = this.blockNumber;
              if (!(blockNumber == null)) {
                _context21.next = 6;
                break;
              }
              _context21.next = 4;
              return this.getTransaction();
            case 4:
              tx = _context21.sent;
              if (tx) {
                blockNumber = tx.blockNumber;
              }
            case 6:
              if (!(blockNumber == null)) {
                _context21.next = 8;
                break;
              }
              return _context21.abrupt("return", null);
            case 8:
              block = this.provider.getBlock(blockNumber);
              if (!(block == null)) {
                _context21.next = 11;
                break;
              }
              throw new Error("TODO");
            case 11:
              return _context21.abrupt("return", block);
            case 12:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function getBlock() {
        return _getBlock3.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              return _context22.abrupt("return", this.provider.getTransaction(this.hash));
            case 1:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function getTransaction() {
        return _getTransaction4.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "wait",
    value: function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(_confirms, _timeout) {
        var _this36 = this;
        var confirms, timeout, startBlock, nextScan, stopScanning, checkReplacement, receipt, waiter;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              confirms = _confirms == null ? 1 : _confirms;
              timeout = _timeout == null ? 0 : _timeout;
              startBlock = _classPrivateFieldGet(this, _startBlock);
              nextScan = -1;
              stopScanning = startBlock === -1 ? true : false;
              checkReplacement = /*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
                  var _yield$resolvePropert, blockNumber, nonce, mined, block, _iterator25, _step25, _hash4, _i49, tx, _receipt, reason;
                  return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                    while (1) switch (_context23.prev = _context23.next) {
                      case 0:
                        if (!stopScanning) {
                          _context23.next = 2;
                          break;
                        }
                        return _context23.abrupt("return", null);
                      case 2:
                        _context23.next = 4;
                        return resolveProperties({
                          blockNumber: _this36.provider.getBlockNumber(),
                          nonce: _this36.provider.getTransactionCount(_this36.from)
                        });
                      case 4:
                        _yield$resolvePropert = _context23.sent;
                        blockNumber = _yield$resolvePropert.blockNumber;
                        nonce = _yield$resolvePropert.nonce;
                        if (!(nonce < _this36.nonce)) {
                          _context23.next = 10;
                          break;
                        }
                        startBlock = blockNumber;
                        return _context23.abrupt("return");
                      case 10:
                        if (!stopScanning) {
                          _context23.next = 12;
                          break;
                        }
                        return _context23.abrupt("return", null);
                      case 12:
                        _context23.next = 14;
                        return _this36.getTransaction();
                      case 14:
                        mined = _context23.sent;
                        if (!(mined && mined.blockNumber != null)) {
                          _context23.next = 17;
                          break;
                        }
                        return _context23.abrupt("return");
                      case 17:
                        // We were replaced; start scanning for that transaction
                        // Starting to scan; look back a few extra blocks for safety
                        if (nextScan === -1) {
                          nextScan = startBlock - 3;
                          if (nextScan < _classPrivateFieldGet(_this36, _startBlock)) {
                            nextScan = _classPrivateFieldGet(_this36, _startBlock);
                          }
                        }
                      case 18:
                        if (!(nextScan <= blockNumber)) {
                          _context23.next = 67;
                          break;
                        }
                        if (!stopScanning) {
                          _context23.next = 21;
                          break;
                        }
                        return _context23.abrupt("return", null);
                      case 21:
                        _context23.next = 23;
                        return _this36.provider.getBlock(nextScan, true);
                      case 23:
                        block = _context23.sent;
                        if (!(block == null)) {
                          _context23.next = 26;
                          break;
                        }
                        return _context23.abrupt("return");
                      case 26:
                        // We were mined; no replacement
                        _iterator25 = _createForOfIteratorHelper(block);
                        _context23.prev = 27;
                        _iterator25.s();
                      case 29:
                        if ((_step25 = _iterator25.n()).done) {
                          _context23.next = 35;
                          break;
                        }
                        _hash4 = _step25.value;
                        if (!(_hash4 === _this36.hash)) {
                          _context23.next = 33;
                          break;
                        }
                        return _context23.abrupt("return");
                      case 33:
                        _context23.next = 29;
                        break;
                      case 35:
                        _context23.next = 40;
                        break;
                      case 37:
                        _context23.prev = 37;
                        _context23.t0 = _context23["catch"](27);
                        _iterator25.e(_context23.t0);
                      case 40:
                        _context23.prev = 40;
                        _iterator25.f();
                        return _context23.finish(40);
                      case 43:
                        _i49 = 0;
                      case 44:
                        if (!(_i49 < block.length)) {
                          _context23.next = 64;
                          break;
                        }
                        _context23.next = 47;
                        return block.getTransaction(_i49);
                      case 47:
                        tx = _context23.sent;
                        if (!(tx.from === _this36.from && tx.nonce === _this36.nonce)) {
                          _context23.next = 61;
                          break;
                        }
                        if (!stopScanning) {
                          _context23.next = 51;
                          break;
                        }
                        return _context23.abrupt("return", null);
                      case 51:
                        _context23.next = 53;
                        return _this36.provider.getTransactionReceipt(tx.hash);
                      case 53:
                        _receipt = _context23.sent;
                        if (!(_receipt == null)) {
                          _context23.next = 56;
                          break;
                        }
                        return _context23.abrupt("return");
                      case 56:
                        if (!(blockNumber - _receipt.blockNumber + 1 < confirms)) {
                          _context23.next = 58;
                          break;
                        }
                        return _context23.abrupt("return");
                      case 58:
                        // The reason we were replaced
                        reason = "replaced";
                        if (tx.data === _this36.data && tx.to === _this36.to && tx.value === _this36.value) {
                          reason = "repriced";
                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
                          reason = "cancelled";
                        }
                        assert$1(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                          cancelled: reason === "replaced" || reason === "cancelled",
                          reason: reason,
                          replacement: tx.replaceableTransaction(startBlock),
                          hash: tx.hash,
                          receipt: _receipt
                        });
                      case 61:
                        _i49++;
                        _context23.next = 44;
                        break;
                      case 64:
                        nextScan++;
                        _context23.next = 18;
                        break;
                      case 67:
                        return _context23.abrupt("return");
                      case 68:
                      case "end":
                        return _context23.stop();
                    }
                  }, _callee23, null, [[27, 37, 40, 43]]);
                }));
                return function checkReplacement() {
                  return _ref10.apply(this, arguments);
                };
              }();
              _context26.next = 8;
              return this.provider.getTransactionReceipt(this.hash);
            case 8:
              receipt = _context26.sent;
              if (!receipt) {
                _context26.next = 18;
                break;
              }
              _context26.next = 12;
              return receipt.confirmations();
            case 12:
              _context26.t0 = _context26.sent;
              _context26.t1 = confirms;
              if (!(_context26.t0 >= _context26.t1)) {
                _context26.next = 16;
                break;
              }
              return _context26.abrupt("return", receipt);
            case 16:
              _context26.next = 22;
              break;
            case 18:
              _context26.next = 20;
              return checkReplacement();
            case 20:
              if (!(confirms === 0)) {
                _context26.next = 22;
                break;
              }
              return _context26.abrupt("return", null);
            case 22:
              waiter = new Promise(function (resolve, reject) {
                // List of things to cancel when we have a result (one way or the other)
                var cancellers = [];
                var cancel = function cancel() {
                  cancellers.forEach(function (c) {
                    return c();
                  });
                };
                // On cancel, stop scanning for replacements
                cancellers.push(function () {
                  stopScanning = true;
                });
                // Set up any timeout requested
                if (timeout > 0) {
                  var timer = setTimeout(function () {
                    cancel();
                    reject(makeError("wait for transaction timeout", "TIMEOUT"));
                  }, timeout);
                  cancellers.push(function () {
                    clearTimeout(timer);
                  });
                }
                var txListener = /*#__PURE__*/function () {
                  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(receipt) {
                    return _regeneratorRuntime().wrap(function _callee24$(_context24) {
                      while (1) switch (_context24.prev = _context24.next) {
                        case 0:
                          _context24.next = 2;
                          return receipt.confirmations();
                        case 2:
                          _context24.t0 = _context24.sent;
                          _context24.t1 = confirms;
                          if (!(_context24.t0 >= _context24.t1)) {
                            _context24.next = 7;
                            break;
                          }
                          cancel();
                          resolve(receipt);
                        case 7:
                        case "end":
                          return _context24.stop();
                      }
                    }, _callee24);
                  }));
                  return function txListener(_x60) {
                    return _ref11.apply(this, arguments);
                  };
                }();
                cancellers.push(function () {
                  _this36.provider.off(_this36.hash, txListener);
                });
                _this36.provider.on(_this36.hash, txListener);
                // We support replacement detection; start checking
                if (startBlock >= 0) {
                  var replaceListener = /*#__PURE__*/function () {
                    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
                      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                        while (1) switch (_context25.prev = _context25.next) {
                          case 0:
                            _context25.prev = 0;
                            _context25.next = 3;
                            return checkReplacement();
                          case 3:
                            _context25.next = 11;
                            break;
                          case 5:
                            _context25.prev = 5;
                            _context25.t0 = _context25["catch"](0);
                            if (!isError(_context25.t0, "TRANSACTION_REPLACED")) {
                              _context25.next = 11;
                              break;
                            }
                            cancel();
                            reject(_context25.t0);
                            return _context25.abrupt("return");
                          case 11:
                            // Rescheudle a check on the next block
                            if (!stopScanning) {
                              _this36.provider.once("block", replaceListener);
                            }
                          case 12:
                          case "end":
                            return _context25.stop();
                        }
                      }, _callee25, null, [[0, 5]]);
                    }));
                    return function replaceListener() {
                      return _ref12.apply(this, arguments);
                    };
                  }();
                  cancellers.push(function () {
                    _this36.provider.off("block", replaceListener);
                  });
                  _this36.provider.once("block", replaceListener);
                }
              });
              _context26.next = 25;
              return waiter;
            case 25:
              return _context26.abrupt("return", _context26.sent);
            case 26:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function wait(_x58, _x59) {
        return _wait.apply(this, arguments);
      }
      return wait;
    }()
  }, {
    key: "isMined",
    value: function isMined() {
      return this.blockHash != null;
    }
  }, {
    key: "isLegacy",
    value: function isLegacy() {
      return this.type === 0;
    }
  }, {
    key: "isBerlin",
    value: function isBerlin() {
      return this.type === 1;
    }
  }, {
    key: "isLondon",
    value: function isLondon() {
      return this.type === 2;
    }
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      assert$1(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      return createRemovedTransactionFilter(this);
    }
  }, {
    key: "reorderedEvent",
    value: function reorderedEvent(other) {
      assert$1(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      assert$1(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      return createReorderedTransactionFilter(this, other);
    }
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
  }, {
    key: "replaceableTransaction",
    value: function replaceableTransaction(startBlock) {
      assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
      var tx = new TransactionResponse(this, this.provider);
      _classPrivateFieldSet(tx, _startBlock, startBlock);
      return tx;
    }
  }]);
  return TransactionResponse;
}();
exports.TransactionResponse = TransactionResponse;
function createOrphanedBlockFilter(block) {
  return {
    orphan: "drop-block",
    hash: block.hash,
    number: block.number
  };
}
function createReorderedTransactionFilter(tx, other) {
  return {
    orphan: "reorder-transaction",
    tx: tx,
    other: other
  };
}
function createRemovedTransactionFilter(tx) {
  return {
    orphan: "drop-transaction",
    tx: tx
  };
}
function createRemovedLogFilter(log) {
  return {
    orphan: "drop-log",
    log: {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      address: log.address,
      data: log.data,
      topics: Object.freeze(log.topics.slice()),
      index: log.index
    }
  };
}

// import from provider.ts instead of index.ts to prevent circular dep
var EventLog = /*#__PURE__*/function (_Log) {
  _inherits(EventLog, _Log);
  var _super30 = _createSuper(EventLog);
  function EventLog(log, iface, fragment) {
    var _this37;
    _classCallCheck(this, EventLog);
    _this37 = _super30.call(this, log, log.provider);
    _defineProperty(_assertThisInitialized(_this37), "interface", void 0);
    _defineProperty(_assertThisInitialized(_this37), "fragment", void 0);
    _defineProperty(_assertThisInitialized(_this37), "args", void 0);
    var args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(_assertThisInitialized(_this37), {
      args: args,
      fragment: fragment,
      "interface": iface
    });
    return _this37;
  }
  _createClass(EventLog, [{
    key: "eventName",
    get: function get() {
      return this.fragment.name;
    }
  }, {
    key: "eventSignature",
    get: function get() {
      return this.fragment.format();
    }
  }]);
  return EventLog;
}(Log);
exports.EventLog = EventLog;
var _interface = /*#__PURE__*/new WeakMap();
var ContractTransactionReceipt = /*#__PURE__*/function (_TransactionReceipt) {
  _inherits(ContractTransactionReceipt, _TransactionReceipt);
  var _super31 = _createSuper(ContractTransactionReceipt);
  function ContractTransactionReceipt(iface, provider, tx) {
    var _this38;
    _classCallCheck(this, ContractTransactionReceipt);
    _this38 = _super31.call(this, tx, provider);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this38), _interface, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this38), _interface, iface);
    return _this38;
  }
  _createClass(ContractTransactionReceipt, [{
    key: "logs",
    get: function get() {
      var _this39 = this;
      return _get(_getPrototypeOf(ContractTransactionReceipt.prototype), "logs", this).map(function (log) {
        var fragment = log.topics.length ? _classPrivateFieldGet(_this39, _interface).getEvent(log.topics[0]) : null;
        if (fragment) {
          return new EventLog(log, _classPrivateFieldGet(_this39, _interface), fragment);
        } else {
          return log;
        }
      });
    }
  }]);
  return ContractTransactionReceipt;
}(TransactionReceipt);
exports.ContractTransactionReceipt = ContractTransactionReceipt;
var _interface2 = /*#__PURE__*/new WeakMap();
var ContractTransactionResponse = /*#__PURE__*/function (_TransactionResponse) {
  _inherits(ContractTransactionResponse, _TransactionResponse);
  var _super32 = _createSuper(ContractTransactionResponse);
  function ContractTransactionResponse(iface, provider, tx) {
    var _this40;
    _classCallCheck(this, ContractTransactionResponse);
    _this40 = _super32.call(this, tx, provider);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this40), _interface2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this40), _interface2, iface);
    return _this40;
  }
  _createClass(ContractTransactionResponse, [{
    key: "wait",
    value: function () {
      var _wait2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(confirms) {
        var receipt;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return _get(_getPrototypeOf(ContractTransactionResponse.prototype), "wait", this).call(this);
            case 2:
              receipt = _context27.sent;
              if (!(receipt == null)) {
                _context27.next = 5;
                break;
              }
              return _context27.abrupt("return", null);
            case 5:
              return _context27.abrupt("return", new ContractTransactionReceipt(_classPrivateFieldGet(this, _interface2), this.provider, receipt));
            case 6:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function wait(_x61) {
        return _wait2.apply(this, arguments);
      }
      return wait;
    }()
  }]);
  return ContractTransactionResponse;
}(TransactionResponse);
exports.ContractTransactionResponse = ContractTransactionResponse;
var ContractUnknownEventPayload = /*#__PURE__*/function (_EventPayload) {
  _inherits(ContractUnknownEventPayload, _EventPayload);
  var _super33 = _createSuper(ContractUnknownEventPayload);
  function ContractUnknownEventPayload(contract, listener, filter, log) {
    var _this41;
    _classCallCheck(this, ContractUnknownEventPayload);
    _this41 = _super33.call(this, contract, listener, filter);
    _defineProperty(_assertThisInitialized(_this41), "log", void 0);
    defineProperties(_assertThisInitialized(_this41), {
      log: log
    });
    return _this41;
  }
  _createClass(ContractUnknownEventPayload, [{
    key: "getBlock",
    value: function () {
      var _getBlock4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return this.log.getBlock();
            case 2:
              return _context28.abrupt("return", _context28.sent);
            case 3:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function getBlock() {
        return _getBlock4.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.log.getTransaction();
            case 2:
              return _context29.abrupt("return", _context29.sent);
            case 3:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function getTransaction() {
        return _getTransaction5.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getTransactionReceipt",
    value: function () {
      var _getTransactionReceipt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.log.getTransactionReceipt();
            case 2:
              return _context30.abrupt("return", _context30.sent);
            case 3:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function getTransactionReceipt() {
        return _getTransactionReceipt2.apply(this, arguments);
      }
      return getTransactionReceipt;
    }()
  }]);
  return ContractUnknownEventPayload;
}(EventPayload);
var ContractEventPayload = /*#__PURE__*/function (_ContractUnknownEvent) {
  _inherits(ContractEventPayload, _ContractUnknownEvent);
  var _super34 = _createSuper(ContractEventPayload);
  function ContractEventPayload(contract, listener, filter, fragment, _log) {
    var _this42;
    _classCallCheck(this, ContractEventPayload);
    _this42 = _super34.call(this, contract, listener, filter, new EventLog(_log, contract["interface"], fragment));
    var args = contract["interface"].decodeEventLog(fragment, _this42.log.data, _this42.log.topics);
    defineProperties(_assertThisInitialized(_this42), {
      args: args,
      fragment: fragment
    });
    return _this42;
  }
  _createClass(ContractEventPayload, [{
    key: "eventName",
    get: function get() {
      return this.fragment.name;
    }
  }, {
    key: "eventSignature",
    get: function get() {
      return this.fragment.format();
    }
  }]);
  return ContractEventPayload;
}(ContractUnknownEventPayload);
exports.ContractEventPayload = ContractEventPayload;
var BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
var _filter2 = /*#__PURE__*/new WeakMap();
var PreparedTopicFilter = /*#__PURE__*/function () {
  function PreparedTopicFilter(contract, fragment, args) {
    _classCallCheck(this, PreparedTopicFilter);
    _classPrivateFieldInitSpec(this, _filter2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "fragment", void 0);
    defineProperties(this, {
      fragment: fragment
    });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    // Recursively descend into args and resolve any addresses
    var runner = getRunner(contract.runner, "resolveName");
    var resolver = canResolve(runner) ? runner : null;
    _classPrivateFieldSet(this, _filter2, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
      var resolvedArgs;
      return _regeneratorRuntime().wrap(function _callee31$(_context31) {
        while (1) switch (_context31.prev = _context31.next) {
          case 0:
            _context31.next = 2;
            return Promise.all(fragment.inputs.map(function (param, index) {
              var arg = args[index];
              if (arg == null) {
                return null;
              }
              return param.walkAsync(args[index], function (type, value) {
                if (type === "address") {
                  return resolveAddress(value, resolver);
                }
                return value;
              });
            }));
          case 2:
            resolvedArgs = _context31.sent;
            return _context31.abrupt("return", contract["interface"].encodeFilterTopics(fragment, resolvedArgs));
          case 4:
          case "end":
            return _context31.stop();
        }
      }, _callee31);
    }))());
  }
  _createClass(PreparedTopicFilter, [{
    key: "getTopicFilter",
    value: function getTopicFilter() {
      return _classPrivateFieldGet(this, _filter2);
    }
  }]);
  return PreparedTopicFilter;
}(); // A = Arguments passed in as a tuple
// R = The result type of the call (i.e. if only one return type,
//     the qualified type, otherwise Result)
// D = The type the default call will return (i.e. R for view/pure,
//     TransactionResponse otherwise)
//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
function _WrappedMethodBase() {
  return Function;
}
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
/**
 *  @_ignore:
 */
function copyOverrides(_x62, _x63) {
  return _copyOverrides.apply(this, arguments);
}
/**
 *  @_ignore:
 */
function _copyOverrides() {
  _copyOverrides = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee207(arg, allowed) {
    var overrides;
    return _regeneratorRuntime().wrap(function _callee207$(_context209) {
      while (1) switch (_context209.prev = _context209.next) {
        case 0:
          // Create a shallow copy (we'll deep-ify anything needed during normalizing)
          overrides = copyRequest(Typed.dereference(arg, "overrides"));
          assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
          assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
          // Resolve any from
          if (!overrides.from) {
            _context209.next = 7;
            break;
          }
          _context209.next = 6;
          return resolveAddress(overrides.from);
        case 6:
          overrides.from = _context209.sent;
        case 7:
          return _context209.abrupt("return", overrides);
        case 8:
        case "end":
          return _context209.stop();
      }
    }, _callee207);
  }));
  return _copyOverrides.apply(this, arguments);
}
function resolveArgs(_x64, _x65, _x66) {
  return _resolveArgs.apply(this, arguments);
}
function _resolveArgs() {
  _resolveArgs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee208(_runner, inputs, args) {
    var runner, resolver;
    return _regeneratorRuntime().wrap(function _callee208$(_context210) {
      while (1) switch (_context210.prev = _context210.next) {
        case 0:
          // Recursively descend into args and resolve any addresses
          runner = getRunner(_runner, "resolveName");
          resolver = canResolve(runner) ? runner : null;
          _context210.next = 4;
          return Promise.all(inputs.map(function (param, index) {
            return param.walkAsync(args[index], function (type, value) {
              value = Typed.dereference(value, type);
              if (type === "address") {
                return resolveAddress(value, resolver);
              }
              return value;
            });
          }));
        case 4:
          return _context210.abrupt("return", _context210.sent);
        case 5:
        case "end":
          return _context210.stop();
      }
    }, _callee208);
  }));
  return _resolveArgs.apply(this, arguments);
}
var WrappedFallback = /*#__PURE__*/function () {
  function WrappedFallback(contract) {
    _classCallCheck(this, WrappedFallback);
    _defineProperty(this, "_contract", void 0);
    defineProperties(this, {
      _contract: contract
    });
    var proxy = new Proxy(this, {
      // Perform send when called
      apply: function () {
        var _apply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(target, thisArg, args) {
          return _regeneratorRuntime().wrap(function _callee32$(_context32) {
            while (1) switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return target.send.apply(target, _toConsumableArray(args));
              case 2:
                return _context32.abrupt("return", _context32.sent);
              case 3:
              case "end":
                return _context32.stop();
            }
          }, _callee32);
        }));
        function apply(_x67, _x68, _x69) {
          return _apply.apply(this, arguments);
        }
        return apply;
      }()
    });
    return proxy;
  }
  _createClass(WrappedFallback, [{
    key: "populateTransaction",
    value: function () {
      var _populateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(overrides) {
        var tx, iface, payable;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return copyOverrides(overrides, ["data"]);
            case 2:
              tx = _context33.sent;
              _context33.next = 5;
              return this._contract.getAddress();
            case 5:
              tx.to = _context33.sent;
              iface = this._contract["interface"]; // Only allow payable contracts to set non-zero value
              payable = iface.receive || iface.fallback && iface.fallback.payable;
              assertArgument(payable || (tx.value || BN_0$1) === BN_0$1, "cannot send value to non-payable contract", "overrides.value", tx.value);
              // Only allow fallback contracts to set non-empty data
              assertArgument(iface.fallback || (tx.data || "0x") === "0x", "cannot send data to receive-only contract", "overrides.data", tx.data);
              return _context33.abrupt("return", tx);
            case 11:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function populateTransaction(_x70) {
        return _populateTransaction.apply(this, arguments);
      }
      return populateTransaction;
    }()
  }, {
    key: "staticCall",
    value: function () {
      var _staticCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(overrides) {
        var runner, tx;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              runner = getRunner(this._contract.runner, "call");
              assert$1(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
              });
              _context34.next = 4;
              return this.populateTransaction(overrides);
            case 4:
              tx = _context34.sent;
              _context34.prev = 5;
              _context34.next = 8;
              return runner.call(tx);
            case 8:
              return _context34.abrupt("return", _context34.sent);
            case 11:
              _context34.prev = 11;
              _context34.t0 = _context34["catch"](5);
              if (!(isCallException(_context34.t0) && _context34.t0.data)) {
                _context34.next = 15;
                break;
              }
              throw this._contract["interface"].makeError(_context34.t0.data, tx);
            case 15:
              throw _context34.t0;
            case 16:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this, [[5, 11]]);
      }));
      function staticCall(_x71) {
        return _staticCall.apply(this, arguments);
      }
      return staticCall;
    }()
  }, {
    key: "send",
    value: function () {
      var _send3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(overrides) {
        var runner, tx, provider;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              runner = this._contract.runner;
              assert$1(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context35.t0 = runner;
              _context35.next = 5;
              return this.populateTransaction(overrides);
            case 5:
              _context35.t1 = _context35.sent;
              _context35.next = 8;
              return _context35.t0.sendTransaction.call(_context35.t0, _context35.t1);
            case 8:
              tx = _context35.sent;
              provider = getProvider(this._contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
              // meaningful error
              return _context35.abrupt("return", new ContractTransactionResponse(this._contract["interface"], provider, tx));
            case 11:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this);
      }));
      function send(_x72) {
        return _send3.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(overrides) {
        var runner;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              runner = getRunner(this._contract.runner, "estimateGas");
              assert$1(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
              });
              _context36.t0 = runner;
              _context36.next = 5;
              return this.populateTransaction(overrides);
            case 5:
              _context36.t1 = _context36.sent;
              _context36.next = 8;
              return _context36.t0.estimateGas.call(_context36.t0, _context36.t1);
            case 8:
              return _context36.abrupt("return", _context36.sent);
            case 9:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function estimateGas(_x73) {
        return _estimateGas.apply(this, arguments);
      }
      return estimateGas;
    }()
  }]);
  return WrappedFallback;
}();
var WrappedMethod = /*#__PURE__*/function (_WrappedMethodBase2) {
  _inherits(WrappedMethod, _WrappedMethodBase2);
  var _super35 = _createSuper(WrappedMethod);
  // Investigate!

  function WrappedMethod(contract, key) {
    var _this43;
    _classCallCheck(this, WrappedMethod);
    _this43 = _super35.call(this);
    _defineProperty(_assertThisInitialized(_this43), "name", "");
    _defineProperty(_assertThisInitialized(_this43), "_contract", void 0);
    _defineProperty(_assertThisInitialized(_this43), "_key", void 0);
    defineProperties(_assertThisInitialized(_this43), {
      name: contract["interface"].getFunctionName(key),
      _contract: contract,
      _key: key
    });
    var proxy = new Proxy(_assertThisInitialized(_this43), {
      // Perform the default operation for this fragment type
      apply: function () {
        var _apply2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(target, thisArg, args) {
          var fragment;
          return _regeneratorRuntime().wrap(function _callee37$(_context37) {
            while (1) switch (_context37.prev = _context37.next) {
              case 0:
                fragment = target.getFragment.apply(target, _toConsumableArray(args));
                if (!fragment.constant) {
                  _context37.next = 5;
                  break;
                }
                _context37.next = 4;
                return target.staticCall.apply(target, _toConsumableArray(args));
              case 4:
                return _context37.abrupt("return", _context37.sent);
              case 5:
                _context37.next = 7;
                return target.send.apply(target, _toConsumableArray(args));
              case 7:
                return _context37.abrupt("return", _context37.sent);
              case 8:
              case "end":
                return _context37.stop();
            }
          }, _callee37);
        }));
        function apply(_x74, _x75, _x76) {
          return _apply2.apply(this, arguments);
        }
        return apply;
      }()
    });
    return _possibleConstructorReturn(_this43, proxy);
  }
  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
  _createClass(WrappedMethod, [{
    key: "fragment",
    get: function get() {
      var fragment = this._contract["interface"].getFunction(this._key);
      assert$1(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment"
      });
      return fragment;
    }
  }, {
    key: "getFragment",
    value: function getFragment() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key15 = 0; _key15 < _len13; _key15++) {
        args[_key15] = arguments[_key15];
      }
      var fragment = this._contract["interface"].getFunction(this._key, args);
      assert$1(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment"
      });
      return fragment;
    }
  }, {
    key: "populateTransaction",
    value: function () {
      var _populateTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
        var _len14,
          args,
          _key16,
          fragment,
          overrides,
          resolvedArgs,
          _args35 = arguments;
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              for (_len14 = _args35.length, args = new Array(_len14), _key16 = 0; _key16 < _len14; _key16++) {
                args[_key16] = _args35[_key16];
              }
              fragment = this.getFragment.apply(this, args); // If an overrides was passed in, copy it and normalize the values
              overrides = {};
              if (!(fragment.inputs.length + 1 === args.length)) {
                _context38.next = 7;
                break;
              }
              _context38.next = 6;
              return copyOverrides(args.pop());
            case 6:
              overrides = _context38.sent;
            case 7:
              if (!(fragment.inputs.length !== args.length)) {
                _context38.next = 9;
                break;
              }
              throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            case 9:
              _context38.next = 11;
              return resolveArgs(this._contract.runner, fragment.inputs, args);
            case 11:
              resolvedArgs = _context38.sent;
              _context38.t0 = Object;
              _context38.t1 = {};
              _context38.t2 = overrides;
              _context38.next = 17;
              return resolveProperties({
                to: this._contract.getAddress(),
                data: this._contract["interface"].encodeFunctionData(fragment, resolvedArgs)
              });
            case 17:
              _context38.t3 = _context38.sent;
              return _context38.abrupt("return", _context38.t0.assign.call(_context38.t0, _context38.t1, _context38.t2, _context38.t3));
            case 19:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function populateTransaction() {
        return _populateTransaction2.apply(this, arguments);
      }
      return populateTransaction;
    }()
  }, {
    key: "staticCall",
    value: function () {
      var _staticCall2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
        var result,
          _args36 = arguments;
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _context39.next = 2;
              return this.staticCallResult.apply(this, _args36);
            case 2:
              result = _context39.sent;
              if (!(result.length === 1)) {
                _context39.next = 5;
                break;
              }
              return _context39.abrupt("return", result[0]);
            case 5:
              return _context39.abrupt("return", result);
            case 6:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this);
      }));
      function staticCall() {
        return _staticCall2.apply(this, arguments);
      }
      return staticCall;
    }()
  }, {
    key: "send",
    value: function () {
      var _send4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var runner,
          tx,
          provider,
          _args37 = arguments;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              runner = this._contract.runner;
              assert$1(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context40.t0 = runner;
              _context40.next = 5;
              return this.populateTransaction.apply(this, _args37);
            case 5:
              _context40.t1 = _context40.sent;
              _context40.next = 8;
              return _context40.t0.sendTransaction.call(_context40.t0, _context40.t1);
            case 8:
              tx = _context40.sent;
              provider = getProvider(this._contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
              // meaningful error
              return _context40.abrupt("return", new ContractTransactionResponse(this._contract["interface"], provider, tx));
            case 11:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
      function send() {
        return _send4.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var runner,
          _args38 = arguments;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              runner = getRunner(this._contract.runner, "estimateGas");
              assert$1(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
              });
              _context41.t0 = runner;
              _context41.next = 5;
              return this.populateTransaction.apply(this, _args38);
            case 5:
              _context41.t1 = _context41.sent;
              _context41.next = 8;
              return _context41.t0.estimateGas.call(_context41.t0, _context41.t1);
            case 8:
              return _context41.abrupt("return", _context41.sent);
            case 9:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
      function estimateGas() {
        return _estimateGas2.apply(this, arguments);
      }
      return estimateGas;
    }()
  }, {
    key: "staticCallResult",
    value: function () {
      var _staticCallResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        var runner,
          tx,
          result,
          fragment,
          _args39 = arguments;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              runner = getRunner(this._contract.runner, "call");
              assert$1(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
              });
              _context42.next = 4;
              return this.populateTransaction.apply(this, _args39);
            case 4:
              tx = _context42.sent;
              result = "0x";
              _context42.prev = 6;
              _context42.next = 9;
              return runner.call(tx);
            case 9:
              result = _context42.sent;
              _context42.next = 17;
              break;
            case 12:
              _context42.prev = 12;
              _context42.t0 = _context42["catch"](6);
              if (!(isCallException(_context42.t0) && _context42.t0.data)) {
                _context42.next = 16;
                break;
              }
              throw this._contract["interface"].makeError(_context42.t0.data, tx);
            case 16:
              throw _context42.t0;
            case 17:
              fragment = this.getFragment.apply(this, _args39);
              return _context42.abrupt("return", this._contract["interface"].decodeFunctionResult(fragment, result));
            case 19:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this, [[6, 12]]);
      }));
      function staticCallResult() {
        return _staticCallResult.apply(this, arguments);
      }
      return staticCallResult;
    }()
  }]);
  return WrappedMethod;
}(_WrappedMethodBase());
function _WrappedEventBase() {
  return Function;
}
var WrappedEvent = /*#__PURE__*/function (_WrappedEventBase2) {
  _inherits(WrappedEvent, _WrappedEventBase2);
  var _super36 = _createSuper(WrappedEvent);
  // @TODO: investigate 

  function WrappedEvent(contract, key) {
    var _this44;
    _classCallCheck(this, WrappedEvent);
    _this44 = _super36.call(this);
    _defineProperty(_assertThisInitialized(_this44), "name", "");
    _defineProperty(_assertThisInitialized(_this44), "_contract", void 0);
    _defineProperty(_assertThisInitialized(_this44), "_key", void 0);
    defineProperties(_assertThisInitialized(_this44), {
      name: contract["interface"].getEventName(key),
      _contract: contract,
      _key: key
    });
    return _possibleConstructorReturn(_this44, new Proxy(_assertThisInitialized(_this44), {
      // Perform the default operation for this fragment type
      apply: function apply(target, thisArg, args) {
        return new PreparedTopicFilter(contract, target.getFragment.apply(target, _toConsumableArray(args)), args);
      }
    }));
  }
  // Only works on non-ambiguous keys
  _createClass(WrappedEvent, [{
    key: "fragment",
    get: function get() {
      var fragment = this._contract["interface"].getEvent(this._key);
      assert$1(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment"
      });
      return fragment;
    }
  }, {
    key: "getFragment",
    value: function getFragment() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key17 = 0; _key17 < _len15; _key17++) {
        args[_key17] = arguments[_key17];
      }
      var fragment = this._contract["interface"].getEvent(this._key, args);
      assert$1(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment"
      });
      return fragment;
    }
  }]);
  return WrappedEvent;
}(_WrappedEventBase());
;
// The combination of TypeScrype, Private Fields and Proxies makes
// the world go boom; so we hide variables with some trickery keeping
// a symbol attached to each BaseContract which its sub-class (even
// via a Proxy) can reach and use to look up its internal values.
var internal = Symbol["for"]("_ethersInternal_contract");
var internalValues = new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && _typeof(value) === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
function getSubInfo(_x77, _x78) {
  return _getSubInfo.apply(this, arguments);
}
function _getSubInfo() {
  _getSubInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee209(contract, event) {
    var topics, fragment, topicHashify, tag;
    return _regeneratorRuntime().wrap(function _callee209$(_context211) {
      while (1) switch (_context211.prev = _context211.next) {
        case 0:
          fragment = null; // Convert named events to topicHash and get the fragment for
          // events which need deconstructing.
          if (!Array.isArray(event)) {
            _context211.next = 6;
            break;
          }
          topicHashify = function topicHashify(name) {
            if (isHexString(name, 32)) {
              return name;
            }
            var fragment = contract["interface"].getEvent(name);
            assertArgument(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
          }; // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
          topics = event.map(function (e) {
            if (e == null) {
              return null;
            }
            if (Array.isArray(e)) {
              return e.map(topicHashify);
            }
            return topicHashify(e);
          });
          _context211.next = 21;
          break;
        case 6:
          if (!(event === "*")) {
            _context211.next = 10;
            break;
          }
          topics = [null];
          _context211.next = 21;
          break;
        case 10:
          if (!(typeof event === "string")) {
            _context211.next = 14;
            break;
          }
          if (isHexString(event, 32)) {
            // Topic Hash
            topics = [event];
          } else {
            // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
            fragment = contract["interface"].getEvent(event);
            assertArgument(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
          }
          _context211.next = 21;
          break;
        case 14:
          if (!isDeferred(event)) {
            _context211.next = 20;
            break;
          }
          _context211.next = 17;
          return event.getTopicFilter();
        case 17:
          topics = _context211.sent;
          _context211.next = 21;
          break;
        case 20:
          if ("fragment" in event) {
            // ContractEvent; e.g. `contract.filter.Transfer`
            fragment = event.fragment;
            topics = [fragment.topicHash];
          } else {
            assertArgument(false, "unknown event name", "event", event);
          }
        case 21:
          // Normalize topics and sort TopicSets
          topics = topics.map(function (t) {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              var items = Array.from(new Set(t.map(function (t) {
                return t.toLowerCase();
              })).values());
              if (items.length === 1) {
                return items[0];
              }
              items.sort();
              return items;
            }
            return t.toLowerCase();
          });
          tag = topics.map(function (t) {
            if (t == null) {
              return "null";
            }
            if (Array.isArray(t)) {
              return t.join("|");
            }
            return t;
          }).join("&");
          return _context211.abrupt("return", {
            fragment: fragment,
            tag: tag,
            topics: topics
          });
        case 24:
        case "end":
          return _context211.stop();
      }
    }, _callee209);
  }));
  return _getSubInfo.apply(this, arguments);
}
function hasSub(_x79, _x80) {
  return _hasSub.apply(this, arguments);
}
function _hasSub() {
  _hasSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee210(contract, event) {
    var _getInternal5, subs;
    return _regeneratorRuntime().wrap(function _callee210$(_context212) {
      while (1) switch (_context212.prev = _context212.next) {
        case 0:
          _getInternal5 = getInternal(contract), subs = _getInternal5.subs;
          _context212.t1 = subs;
          _context212.next = 4;
          return getSubInfo(contract, event);
        case 4:
          _context212.t2 = _context212.sent.tag;
          _context212.t0 = _context212.t1.get.call(_context212.t1, _context212.t2);
          if (_context212.t0) {
            _context212.next = 8;
            break;
          }
          _context212.t0 = null;
        case 8:
          return _context212.abrupt("return", _context212.t0);
        case 9:
        case "end":
          return _context212.stop();
      }
    }, _callee210);
  }));
  return _hasSub.apply(this, arguments);
}
function getSub(_x81, _x82, _x83) {
  return _getSub.apply(this, arguments);
} // We use this to ensure one emit resolves before firing the next to
// ensure correct ordering (note this cannot throw and just adds the
// notice to the event queu using setTimeout).
function _getSub() {
  _getSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee212(contract, operation, event) {
    var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;
    return _regeneratorRuntime().wrap(function _callee212$(_context214) {
      while (1) switch (_context214.prev = _context214.next) {
        case 0:
          // Make sure our runner can actually subscribe to events
          provider = getProvider(contract.runner);
          assert$1(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
            operation: operation
          });
          _context214.next = 4;
          return getSubInfo(contract, event);
        case 4:
          _yield$getSubInfo2 = _context214.sent;
          fragment = _yield$getSubInfo2.fragment;
          tag = _yield$getSubInfo2.tag;
          topics = _yield$getSubInfo2.topics;
          _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;
          sub = subs.get(tag);
          if (!sub) {
            address = addr ? addr : contract;
            filter = {
              address: address,
              topics: topics
            };
            listener = function listener(log) {
              var foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = contract["interface"].getEvent(log.topics[0]);
                } catch (error) {}
              }
              // If fragment is null, we do not deconstruct the args to emit
              if (foundFragment) {
                var _foundFragment = foundFragment;
                var _args210 = fragment ? contract["interface"].decodeEventLog(fragment, log.data, log.topics) : [];
                _emit4(contract, event, _args210, function (listener) {
                  return new ContractEventPayload(contract, listener, event, _foundFragment, log);
                });
              } else {
                _emit4(contract, event, [], function (listener) {
                  return new ContractUnknownEventPayload(contract, listener, event, log);
                });
              }
            };
            starting = [];
            start = function start() {
              if (starting.length) {
                return;
              }
              starting.push(provider.on(filter, listener));
            };
            stop = /*#__PURE__*/function () {
              var _ref51 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee211() {
                var started;
                return _regeneratorRuntime().wrap(function _callee211$(_context213) {
                  while (1) switch (_context213.prev = _context213.next) {
                    case 0:
                      if (!(starting.length == 0)) {
                        _context213.next = 2;
                        break;
                      }
                      return _context213.abrupt("return");
                    case 2:
                      started = starting;
                      starting = [];
                      _context213.next = 6;
                      return Promise.all(started);
                    case 6:
                      provider.off(filter, listener);
                    case 7:
                    case "end":
                      return _context213.stop();
                  }
                }, _callee211);
              }));
              return function stop() {
                return _ref51.apply(this, arguments);
              };
            }();
            sub = {
              tag: tag,
              listeners: [],
              start: start,
              stop: stop
            };
            subs.set(tag, sub);
          }
          return _context214.abrupt("return", sub);
        case 12:
        case "end":
          return _context214.stop();
      }
    }, _callee212);
  }));
  return _getSub.apply(this, arguments);
}
var lastEmit = Promise.resolve();
function _emit(_x84, _x85, _x86, _x87) {
  return _emit2.apply(this, arguments);
}
function _emit2() {
  _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee213(contract, event, args, payloadFunc) {
    var sub, count;
    return _regeneratorRuntime().wrap(function _callee213$(_context215) {
      while (1) switch (_context215.prev = _context215.next) {
        case 0:
          _context215.next = 2;
          return lastEmit;
        case 2:
          _context215.next = 4;
          return hasSub(contract, event);
        case 4:
          sub = _context215.sent;
          if (sub) {
            _context215.next = 7;
            break;
          }
          return _context215.abrupt("return", false);
        case 7:
          count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(function (_ref52) {
            var listener = _ref52.listener,
              once = _ref52.once;
            var passArgs = Array.from(args);
            if (payloadFunc) {
              passArgs.push(payloadFunc(once ? null : listener));
            }
            try {
              listener.call.apply(listener, [contract].concat(passArgs));
            } catch (error) {}
            return !once;
          });
          return _context215.abrupt("return", count > 0);
        case 10:
        case "end":
          return _context215.stop();
      }
    }, _callee213);
  }));
  return _emit2.apply(this, arguments);
}
function _emit4(_x88, _x89, _x90, _x91) {
  return _emit3.apply(this, arguments);
}
function _emit3() {
  _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee214(contract, event, args, payloadFunc) {
    var resultPromise;
    return _regeneratorRuntime().wrap(function _callee214$(_context216) {
      while (1) switch (_context216.prev = _context216.next) {
        case 0:
          _context216.prev = 0;
          _context216.next = 3;
          return lastEmit;
        case 3:
          _context216.next = 7;
          break;
        case 5:
          _context216.prev = 5;
          _context216.t0 = _context216["catch"](0);
        case 7:
          resultPromise = _emit(contract, event, args, payloadFunc);
          lastEmit = resultPromise;
          _context216.next = 11;
          return resultPromise;
        case 11:
          return _context216.abrupt("return", _context216.sent);
        case 12:
        case "end":
          return _context216.stop();
      }
    }, _callee214, null, [[0, 5]]);
  }));
  return _emit3.apply(this, arguments);
}
var passProperties = ["then"];
var BaseContract = /*#__PURE__*/function () {
  function BaseContract(target, abi, runner, _deployTx) {
    var _this45 = this;
    _classCallCheck(this, BaseContract);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "interface", void 0);
    _defineProperty(this, "runner", void 0);
    _defineProperty(this, "filters", void 0);
    _defineProperty(this, internal, void 0);
    _defineProperty(this, "fallback", void 0);
    if (runner == null) {
      runner = null;
    }
    var iface = Interface.from(abi);
    defineProperties(this, {
      target: target,
      runner: runner,
      "interface": iface
    });
    Object.defineProperty(this, internal, {
      value: {}
    });
    var addrPromise;
    var addr = null;
    var deployTx = null;
    if (_deployTx) {
      var provider = getProvider(runner);
      // @TODO: the provider can be null; make a custom dummy provider that will throw a
      // meaningful error
      deployTx = new ContractTransactionResponse(this["interface"], provider, _deployTx);
    }
    var subs = new Map();
    // Resolve the target as the address
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        var resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then(function (addr) {
          if (addr == null) {
            throw new Error("TODO");
          }
          getInternal(_this45).addr = addr;
          return addr;
        });
      }
    } else {
      addrPromise = target.getAddress().then(function (addr) {
        if (addr == null) {
          throw new Error("TODO");
        }
        getInternal(_this45).addr = addr;
        return addr;
      });
    }
    // Set our private values
    setInternal(this, {
      addrPromise: addrPromise,
      addr: addr,
      deployTx: deployTx,
      subs: subs
    });
    // Add the event filters
    var filters = new Proxy({}, {
      get: function get(target, _prop, receiver) {
        // Pass important checks (like `then` for Promise) through
        if (passProperties.indexOf(_prop) >= 0) {
          return Reflect.get(target, _prop, receiver);
        }
        var prop = String(_prop);
        var result = _this45.getEvent(prop);
        if (result) {
          return result;
        }
        throw new Error("unknown contract event: ".concat(prop));
      }
    });
    defineProperties(this, {
      filters: filters
    });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? new WrappedFallback(this) : null
    });
    // Return a Proxy that will respond to functions
    return new Proxy(this, {
      get: function get(target, _prop, receiver) {
        if (_prop in target || passProperties.indexOf(_prop) >= 0) {
          return Reflect.get(target, _prop, receiver);
        }
        var prop = String(_prop);
        var result = target.getFunction(prop);
        if (result) {
          return result;
        }
        throw new Error("unknown contract method: ".concat(prop));
      }
    });
  }
  _createClass(BaseContract, [{
    key: "connect",
    value: function connect(runner) {
      return new BaseContract(this.target, this["interface"], runner);
    }
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _context43.next = 2;
              return getInternal(this).addrPromise;
            case 2:
              return _context43.abrupt("return", _context43.sent);
            case 3:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "getDeployedCode",
    value: function () {
      var _getDeployedCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {
        var provider, code;
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              provider = getProvider(this.runner);
              assert$1(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "getDeployedCode"
              });
              _context44.t0 = provider;
              _context44.next = 5;
              return this.getAddress();
            case 5:
              _context44.t1 = _context44.sent;
              _context44.next = 8;
              return _context44.t0.getCode.call(_context44.t0, _context44.t1);
            case 8:
              code = _context44.sent;
              if (!(code === "0x")) {
                _context44.next = 11;
                break;
              }
              return _context44.abrupt("return", null);
            case 11:
              return _context44.abrupt("return", code);
            case 12:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this);
      }));
      function getDeployedCode() {
        return _getDeployedCode.apply(this, arguments);
      }
      return getDeployedCode;
    }()
  }, {
    key: "waitForDeployment",
    value: function () {
      var _waitForDeployment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {
        var _this46 = this;
        var deployTx, code, provider;
        return _regeneratorRuntime().wrap(function _callee46$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              // We have the deployement transaction; just use that (throws if deployement fails)
              deployTx = this.deploymentTransaction();
              if (!deployTx) {
                _context46.next = 5;
                break;
              }
              _context46.next = 4;
              return deployTx.wait();
            case 4:
              return _context46.abrupt("return", this);
            case 5:
              _context46.next = 7;
              return this.getDeployedCode();
            case 7:
              code = _context46.sent;
              if (!(code != null)) {
                _context46.next = 10;
                break;
              }
              return _context46.abrupt("return", this);
            case 10:
              // Make sure we can subscribe to a provider event
              provider = getProvider(this.runner);
              assert$1(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "waitForDeployment"
              });
              return _context46.abrupt("return", new Promise(function (resolve, reject) {
                var checkCode = /*#__PURE__*/function () {
                  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {
                    var _code;
                    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
                      while (1) switch (_context45.prev = _context45.next) {
                        case 0:
                          _context45.prev = 0;
                          _context45.next = 3;
                          return _this46.getDeployedCode();
                        case 3:
                          _code = _context45.sent;
                          if (!(_code != null)) {
                            _context45.next = 6;
                            break;
                          }
                          return _context45.abrupt("return", resolve(_this46));
                        case 6:
                          provider.once("block", checkCode);
                          _context45.next = 12;
                          break;
                        case 9:
                          _context45.prev = 9;
                          _context45.t0 = _context45["catch"](0);
                          reject(_context45.t0);
                        case 12:
                        case "end":
                          return _context45.stop();
                      }
                    }, _callee45, null, [[0, 9]]);
                  }));
                  return function checkCode() {
                    return _ref14.apply(this, arguments);
                  };
                }();
                checkCode();
              }));
            case 13:
            case "end":
              return _context46.stop();
          }
        }, _callee46, this);
      }));
      function waitForDeployment() {
        return _waitForDeployment.apply(this, arguments);
      }
      return waitForDeployment;
    }()
  }, {
    key: "deploymentTransaction",
    value: function deploymentTransaction() {
      return getInternal(this).deployTx;
    }
  }, {
    key: "getFunction",
    value: function getFunction(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      return new WrappedMethod(this, key);
    }
  }, {
    key: "getEvent",
    value: function getEvent(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      return new WrappedEvent(this, key);
    }
  }, {
    key: "queryTransaction",
    value: function () {
      var _queryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(hash) {
        return _regeneratorRuntime().wrap(function _callee47$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              throw new Error("@TODO");
            case 1:
            case "end":
              return _context47.stop();
          }
        }, _callee47);
      }));
      function queryTransaction(_x92) {
        return _queryTransaction.apply(this, arguments);
      }
      return queryTransaction;
    }()
  }, {
    key: "queryFilter",
    value: function () {
      var _queryFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(event, fromBlock, toBlock) {
        var _this47 = this;
        var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;
        return _regeneratorRuntime().wrap(function _callee48$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              if (fromBlock == null) {
                fromBlock = 0;
              }
              if (toBlock == null) {
                toBlock = "latest";
              }
              _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;
              if (!addr) {
                _context48.next = 7;
                break;
              }
              _context48.t0 = addr;
              _context48.next = 10;
              break;
            case 7:
              _context48.next = 9;
              return addrPromise;
            case 9:
              _context48.t0 = _context48.sent;
            case 10:
              address = _context48.t0;
              _context48.next = 13;
              return getSubInfo(this, event);
            case 13:
              _yield$getSubInfo = _context48.sent;
              fragment = _yield$getSubInfo.fragment;
              topics = _yield$getSubInfo.topics;
              filter = {
                address: address,
                topics: topics,
                fromBlock: fromBlock,
                toBlock: toBlock
              };
              provider = getProvider(this.runner);
              assert$1(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
                operation: "queryFilter"
              });
              _context48.next = 21;
              return provider.getLogs(filter);
            case 21:
              return _context48.abrupt("return", _context48.sent.map(function (log) {
                var foundFragment = fragment;
                if (foundFragment == null) {
                  try {
                    foundFragment = _this47["interface"].getEvent(log.topics[0]);
                  } catch (error) {}
                }
                if (foundFragment) {
                  return new EventLog(log, _this47["interface"], foundFragment);
                } else {
                  return new Log(log, provider);
                }
              }));
            case 22:
            case "end":
              return _context48.stop();
          }
        }, _callee48, this);
      }));
      function queryFilter(_x93, _x94, _x95) {
        return _queryFilter.apply(this, arguments);
      }
      return queryFilter;
    }()
  }, {
    key: "on",
    value: function () {
      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee49$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              _context49.next = 2;
              return getSub(this, "on", event);
            case 2:
              sub = _context49.sent;
              sub.listeners.push({
                listener: listener,
                once: false
              });
              sub.start();
              return _context49.abrupt("return", this);
            case 6:
            case "end":
              return _context49.stop();
          }
        }, _callee49, this);
      }));
      function on(_x96, _x97) {
        return _on.apply(this, arguments);
      }
      return on;
    }()
  }, {
    key: "once",
    value: function () {
      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee50$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              _context50.next = 2;
              return getSub(this, "once", event);
            case 2:
              sub = _context50.sent;
              sub.listeners.push({
                listener: listener,
                once: true
              });
              sub.start();
              return _context50.abrupt("return", this);
            case 6:
            case "end":
              return _context50.stop();
          }
        }, _callee50, this);
      }));
      function once(_x98, _x99) {
        return _once.apply(this, arguments);
      }
      return once;
    }()
  }, {
    key: "emit",
    value: function () {
      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51(event) {
        var _len16,
          args,
          _key18,
          _args48 = arguments;
        return _regeneratorRuntime().wrap(function _callee51$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              for (_len16 = _args48.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key18 = 1; _key18 < _len16; _key18++) {
                args[_key18 - 1] = _args48[_key18];
              }
              _context51.next = 3;
              return _emit4(this, event, args, null);
            case 3:
              return _context51.abrupt("return", _context51.sent);
            case 4:
            case "end":
              return _context51.stop();
          }
        }, _callee51, this);
      }));
      function emit(_x100) {
        return _emit5.apply(this, arguments);
      }
      return emit;
    }()
  }, {
    key: "listenerCount",
    value: function () {
      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(event) {
        var sub, _getInternal2, subs, total, _iterator26, _step26, listeners;
        return _regeneratorRuntime().wrap(function _callee52$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              if (!event) {
                _context52.next = 7;
                break;
              }
              _context52.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context52.sent;
              if (sub) {
                _context52.next = 6;
                break;
              }
              return _context52.abrupt("return", 0);
            case 6:
              return _context52.abrupt("return", sub.listeners.length);
            case 7:
              _getInternal2 = getInternal(this), subs = _getInternal2.subs;
              total = 0;
              _iterator26 = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                  listeners = _step26.value.listeners;
                  total += listeners.length;
                }
              } catch (err) {
                _iterator26.e(err);
              } finally {
                _iterator26.f();
              }
              return _context52.abrupt("return", total);
            case 12:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this);
      }));
      function listenerCount(_x101) {
        return _listenerCount.apply(this, arguments);
      }
      return listenerCount;
    }()
  }, {
    key: "listeners",
    value: function () {
      var _listeners2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(event) {
        var sub, _getInternal3, subs, result, _iterator27, _step27, _listeners3;
        return _regeneratorRuntime().wrap(function _callee53$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              if (!event) {
                _context53.next = 7;
                break;
              }
              _context53.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context53.sent;
              if (sub) {
                _context53.next = 6;
                break;
              }
              return _context53.abrupt("return", []);
            case 6:
              return _context53.abrupt("return", sub.listeners.map(function (_ref15) {
                var listener = _ref15.listener;
                return listener;
              }));
            case 7:
              _getInternal3 = getInternal(this), subs = _getInternal3.subs;
              result = [];
              _iterator27 = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                  _listeners3 = _step27.value.listeners;
                  result = result.concat(_listeners3.map(function (_ref16) {
                    var listener = _ref16.listener;
                    return listener;
                  }));
                }
              } catch (err) {
                _iterator27.e(err);
              } finally {
                _iterator27.f();
              }
              return _context53.abrupt("return", result);
            case 12:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this);
      }));
      function listeners(_x102) {
        return _listeners2.apply(this, arguments);
      }
      return listeners;
    }()
  }, {
    key: "off",
    value: function () {
      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(event, listener) {
        var sub, index;
        return _regeneratorRuntime().wrap(function _callee54$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              _context54.next = 2;
              return hasSub(this, event);
            case 2:
              sub = _context54.sent;
              if (sub) {
                _context54.next = 5;
                break;
              }
              return _context54.abrupt("return", this);
            case 5:
              if (listener) {
                index = sub.listeners.map(function (_ref17) {
                  var listener = _ref17.listener;
                  return listener;
                }).indexOf(listener);
                if (index >= 0) {
                  sub.listeners.splice(index, 1);
                }
              }
              if (listener == null || sub.listeners.length === 0) {
                sub.stop();
                getInternal(this).subs["delete"](sub.tag);
              }
              return _context54.abrupt("return", this);
            case 8:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this);
      }));
      function off(_x103, _x104) {
        return _off.apply(this, arguments);
      }
      return off;
    }()
  }, {
    key: "removeAllListeners",
    value: function () {
      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(event) {
        var sub, _getInternal4, subs, _iterator28, _step28, _step28$value, tag, stop;
        return _regeneratorRuntime().wrap(function _callee55$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              if (!event) {
                _context55.next = 10;
                break;
              }
              _context55.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context55.sent;
              if (sub) {
                _context55.next = 6;
                break;
              }
              return _context55.abrupt("return", this);
            case 6:
              sub.stop();
              getInternal(this).subs["delete"](sub.tag);
              _context55.next = 13;
              break;
            case 10:
              _getInternal4 = getInternal(this), subs = _getInternal4.subs;
              _iterator28 = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                  _step28$value = _step28.value, tag = _step28$value.tag, stop = _step28$value.stop;
                  stop();
                  subs["delete"](tag);
                }
              } catch (err) {
                _iterator28.e(err);
              } finally {
                _iterator28.f();
              }
            case 13:
              return _context55.abrupt("return", this);
            case 14:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this);
      }));
      function removeAllListeners(_x105) {
        return _removeAllListeners.apply(this, arguments);
      }
      return removeAllListeners;
    }() // Alias for "on"
  }, {
    key: "addListener",
    value: function () {
      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(event, listener) {
        return _regeneratorRuntime().wrap(function _callee56$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              _context56.next = 2;
              return this.on(event, listener);
            case 2:
              return _context56.abrupt("return", _context56.sent);
            case 3:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this);
      }));
      function addListener(_x106, _x107) {
        return _addListener.apply(this, arguments);
      }
      return addListener;
    }() // Alias for "off"
  }, {
    key: "removeListener",
    value: function () {
      var _removeListener2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(event, listener) {
        return _regeneratorRuntime().wrap(function _callee57$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              _context57.next = 2;
              return this.off(event, listener);
            case 2:
              return _context57.abrupt("return", _context57.sent);
            case 3:
            case "end":
              return _context57.stop();
          }
        }, _callee57, this);
      }));
      function removeListener(_x108, _x109) {
        return _removeListener2.apply(this, arguments);
      }
      return removeListener;
    }()
  }], [{
    key: "buildClass",
    value: function buildClass(abi) {
      var CustomContract = /*#__PURE__*/function (_BaseContract) {
        _inherits(CustomContract, _BaseContract);
        var _super37 = _createSuper(CustomContract);
        function CustomContract(address) {
          var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          _classCallCheck(this, CustomContract);
          return _super37.call(this, address, abi, runner);
        }
        return _createClass(CustomContract);
      }(BaseContract);
      return CustomContract;
    }
  }, {
    key: "from",
    value: function from(target, abi, runner) {
      if (runner == null) {
        runner = null;
      }
      var contract = new this(target, abi, runner);
      return contract;
    }
  }]);
  return BaseContract;
}();
exports.BaseContract = BaseContract;
function _ContractBase() {
  return BaseContract;
}
var Contract = /*#__PURE__*/function (_ContractBase2) {
  _inherits(Contract, _ContractBase2);
  var _super38 = _createSuper(Contract);
  function Contract() {
    _classCallCheck(this, Contract);
    return _super38.apply(this, arguments);
  }
  return _createClass(Contract);
}(_ContractBase()); // A = Arguments to the constructor
// I = Interface of deployed contracts
exports.Contract = Contract;
var ContractFactory = /*#__PURE__*/function () {
  function ContractFactory(abi, bytecode, runner) {
    _classCallCheck(this, ContractFactory);
    _defineProperty(this, "interface", void 0);
    _defineProperty(this, "bytecode", void 0);
    _defineProperty(this, "runner", void 0);
    var iface = Interface.from(abi);
    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (_typeof(bytecode) === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties(this, {
      bytecode: bytecode,
      "interface": iface,
      runner: runner || null
    });
  }
  _createClass(ContractFactory, [{
    key: "getDeployTransaction",
    value: function () {
      var _getDeployTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
        var overrides,
          fragment,
          _len17,
          args,
          _key19,
          resolvedArgs,
          data,
          _args55 = arguments;
        return _regeneratorRuntime().wrap(function _callee58$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              overrides = {};
              fragment = this["interface"].deploy;
              for (_len17 = _args55.length, args = new Array(_len17), _key19 = 0; _key19 < _len17; _key19++) {
                args[_key19] = _args55[_key19];
              }
              if (!(fragment.inputs.length + 1 === args.length)) {
                _context58.next = 7;
                break;
              }
              _context58.next = 6;
              return copyOverrides(args.pop());
            case 6:
              overrides = _context58.sent;
            case 7:
              if (!(fragment.inputs.length !== args.length)) {
                _context58.next = 9;
                break;
              }
              throw new Error("incorrect number of arguments to constructor");
            case 9:
              _context58.next = 11;
              return resolveArgs(this.runner, fragment.inputs, args);
            case 11:
              resolvedArgs = _context58.sent;
              data = concat([this.bytecode, this["interface"].encodeDeploy(resolvedArgs)]);
              return _context58.abrupt("return", Object.assign({}, overrides, {
                data: data
              }));
            case 14:
            case "end":
              return _context58.stop();
          }
        }, _callee58, this);
      }));
      function getDeployTransaction() {
        return _getDeployTransaction.apply(this, arguments);
      }
      return getDeployTransaction;
    }()
  }, {
    key: "deploy",
    value: function () {
      var _deploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {
        var tx,
          sentTx,
          address,
          _args56 = arguments;
        return _regeneratorRuntime().wrap(function _callee59$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              _context59.next = 2;
              return this.getDeployTransaction.apply(this, _args56);
            case 2:
              tx = _context59.sent;
              assert$1(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context59.next = 6;
              return this.runner.sendTransaction(tx);
            case 6:
              sentTx = _context59.sent;
              address = getCreateAddress(sentTx);
              return _context59.abrupt("return", new BaseContract(address, this["interface"], this.runner, sentTx));
            case 9:
            case "end":
              return _context59.stop();
          }
        }, _callee59, this);
      }));
      function deploy() {
        return _deploy.apply(this, arguments);
      }
      return deploy;
    }()
  }, {
    key: "connect",
    value: function connect(runner) {
      return new ContractFactory(this["interface"], this.bytecode, runner);
    }
  }], [{
    key: "fromSolidity",
    value: function fromSolidity(output, runner) {
      assertArgument(output != null, "bad compiler output", "output", output);
      if (typeof output === "string") {
        output = JSON.parse(output);
      }
      var abi = output.abi;
      var bytecode = "";
      if (output.bytecode) {
        bytecode = output.bytecode;
      } else if (output.evm && output.evm.bytecode) {
        bytecode = output.evm.bytecode;
      }
      return new this(abi, bytecode, runner);
    }
  }]);
  return ContractFactory;
}();
/**
 *  About contracts...
 *
 *  @_section: api/contract:Contracts  [about-contracts]
 */
/**
 *  About ENS Resolver
 *
 *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]
 */
// @TODO: This should use the fetch-data:ipfs gateway
// Trim off the ipfs:// prefix and return the default gateway URL
exports.ContractFactory = ContractFactory;
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return "https://gateway.ipfs.io/ipfs/".concat(link);
}
;
;
/**
 *  A provider plugin super-class for processing multicoin address types.
 */
var MulticoinProviderPlugin = /*#__PURE__*/function () {
  function MulticoinProviderPlugin(name) {
    _classCallCheck(this, MulticoinProviderPlugin);
    _defineProperty(this, "name", void 0);
    defineProperties(this, {
      name: name
    });
  }
  _createClass(MulticoinProviderPlugin, [{
    key: "connect",
    value: function connect(proivder) {
      return this;
    }
  }, {
    key: "supportsCoinType",
    value: function supportsCoinType(coinType) {
      return false;
    }
  }, {
    key: "encodeAddress",
    value: function () {
      var _encodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(coinType, address) {
        return _regeneratorRuntime().wrap(function _callee60$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              throw new Error("unsupported coin");
            case 1:
            case "end":
              return _context60.stop();
          }
        }, _callee60);
      }));
      function encodeAddress(_x110, _x111) {
        return _encodeAddress.apply(this, arguments);
      }
      return encodeAddress;
    }()
  }, {
    key: "decodeAddress",
    value: function () {
      var _decodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61(coinType, data) {
        return _regeneratorRuntime().wrap(function _callee61$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              throw new Error("unsupported coin");
            case 1:
            case "end":
              return _context61.stop();
          }
        }, _callee61);
      }));
      function decodeAddress(_x112, _x113) {
        return _decodeAddress.apply(this, arguments);
      }
      return decodeAddress;
    }()
  }]);
  return MulticoinProviderPlugin;
}();
var BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
/**
 *  A basic multicoin provider plugin.
 */
var BasicMulticoinProviderPlugin = /*#__PURE__*/function (_MulticoinProviderPlu) {
  _inherits(BasicMulticoinProviderPlugin, _MulticoinProviderPlu);
  var _super39 = _createSuper(BasicMulticoinProviderPlugin);
  function BasicMulticoinProviderPlugin() {
    _classCallCheck(this, BasicMulticoinProviderPlugin);
    return _super39.call(this, BasicMulticoinPluginId);
  }
  return _createClass(BasicMulticoinProviderPlugin);
}(MulticoinProviderPlugin);
var matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
var matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
/**
 *  A connected object to a resolved ENS name resolver, which can be
 *  used to query additional details.
 */
var _supports = /*#__PURE__*/new WeakMap();
var _resolver = /*#__PURE__*/new WeakMap();
var _fetch = /*#__PURE__*/new WeakSet();
var EnsResolver = /*#__PURE__*/function () {
  /**
   *  The connected provider.
   */

  /**
   *  The address of the resolver.
   */

  /**
   *  The name this resovler was resolved against.
   */

  // For EIP-2544 names, the ancestor that provided the resolver

  function EnsResolver(provider, address, name) {
    _classCallCheck(this, EnsResolver);
    _classPrivateMethodInitSpec(this, _fetch);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "address", void 0);
    _defineProperty(this, "name", void 0);
    _classPrivateFieldInitSpec(this, _supports, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _resolver, {
      writable: true,
      value: void 0
    });
    defineProperties(this, {
      provider: provider,
      address: address,
      name: name
    });
    _classPrivateFieldSet(this, _supports, null);
    _classPrivateFieldSet(this, _resolver, new Contract(address, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (address)", "function text(bytes32, string) view returns (string)", "function contenthash() view returns (bytes)"], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  _createClass(EnsResolver, [{
    key: "supportsWildcard",
    value: function () {
      var _supportsWildcard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {
        var _this48 = this;
        return _regeneratorRuntime().wrap(function _callee63$(_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              if (_classPrivateFieldGet(this, _supports) == null) {
                _classPrivateFieldSet(this, _supports, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62() {
                  return _regeneratorRuntime().wrap(function _callee62$(_context62) {
                    while (1) switch (_context62.prev = _context62.next) {
                      case 0:
                        _context62.prev = 0;
                        _context62.next = 3;
                        return _classPrivateFieldGet(_this48, _resolver).supportsInterface("0x9061b923");
                      case 3:
                        return _context62.abrupt("return", _context62.sent);
                      case 6:
                        _context62.prev = 6;
                        _context62.t0 = _context62["catch"](0);
                        if (!isError(_context62.t0, "CALL_EXCEPTION")) {
                          _context62.next = 10;
                          break;
                        }
                        return _context62.abrupt("return", false);
                      case 10:
                        // Let future attempts try again...
                        _classPrivateFieldSet(_this48, _supports, null);
                        throw _context62.t0;
                      case 12:
                      case "end":
                        return _context62.stop();
                    }
                  }, _callee62, null, [[0, 6]]);
                }))());
              }
              _context63.next = 3;
              return _classPrivateFieldGet(this, _supports);
            case 3:
              return _context63.abrupt("return", _context63.sent);
            case 4:
            case "end":
              return _context63.stop();
          }
        }, _callee63, this);
      }));
      function supportsWildcard() {
        return _supportsWildcard.apply(this, arguments);
      }
      return supportsWildcard;
    }()
  }, {
    key: "getAddress",
    value:
    /**
     *  Resolves to the address for %%coinType%% or null if the
     *  provided %%coinType%% has not been configured.
     */
    function () {
      var _getAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64(coinType) {
        var result, coinPlugin, _iterator29, _step29, plugin, data, address;
        return _regeneratorRuntime().wrap(function _callee64$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              if (coinType == null) {
                coinType = 60;
              }
              if (!(coinType === 60)) {
                _context64.next = 16;
                break;
              }
              _context64.prev = 2;
              _context64.next = 5;
              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, "addr(bytes32)");
            case 5:
              result = _context64.sent;
              if (!(result == null || result === ZeroAddress)) {
                _context64.next = 8;
                break;
              }
              return _context64.abrupt("return", null);
            case 8:
              return _context64.abrupt("return", result);
            case 11:
              _context64.prev = 11;
              _context64.t0 = _context64["catch"](2);
              if (!isError(_context64.t0, "CALL_EXCEPTION")) {
                _context64.next = 15;
                break;
              }
              return _context64.abrupt("return", null);
            case 15:
              throw _context64.t0;
            case 16:
              coinPlugin = null;
              _iterator29 = _createForOfIteratorHelper(this.provider.plugins);
              _context64.prev = 18;
              _iterator29.s();
            case 20:
              if ((_step29 = _iterator29.n()).done) {
                _context64.next = 29;
                break;
              }
              plugin = _step29.value;
              if (plugin instanceof MulticoinProviderPlugin) {
                _context64.next = 24;
                break;
              }
              return _context64.abrupt("continue", 27);
            case 24:
              if (!plugin.supportsCoinType(coinType)) {
                _context64.next = 27;
                break;
              }
              coinPlugin = plugin;
              return _context64.abrupt("break", 29);
            case 27:
              _context64.next = 20;
              break;
            case 29:
              _context64.next = 34;
              break;
            case 31:
              _context64.prev = 31;
              _context64.t1 = _context64["catch"](18);
              _iterator29.e(_context64.t1);
            case 34:
              _context64.prev = 34;
              _iterator29.f();
              return _context64.finish(34);
            case 37:
              if (!(coinPlugin == null)) {
                _context64.next = 39;
                break;
              }
              return _context64.abrupt("return", null);
            case 39:
              _context64.next = 41;
              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, "addr(bytes32,uint)", [coinType]);
            case 41:
              data = _context64.sent;
              if (!(data == null || data === "0x")) {
                _context64.next = 44;
                break;
              }
              return _context64.abrupt("return", null);
            case 44:
              _context64.next = 46;
              return coinPlugin.encodeAddress(coinType, data);
            case 46:
              address = _context64.sent;
              if (!(address != null)) {
                _context64.next = 49;
                break;
              }
              return _context64.abrupt("return", address);
            case 49:
              assert$1(false, "invalid coin data", "UNSUPPORTED_OPERATION", {
                operation: "getAddress(".concat(coinType, ")"),
                info: {
                  coinType: coinType,
                  data: data
                }
              });
            case 50:
            case "end":
              return _context64.stop();
          }
        }, _callee64, this, [[2, 11], [18, 31, 34, 37]]);
      }));
      function getAddress(_x114) {
        return _getAddress2.apply(this, arguments);
      }
      return getAddress;
    }()
    /**
     *  Resovles to the EIP-643 text record for %%key%%, or ``null``
     *  if unconfigured.
     */
  }, {
    key: "getText",
    value: function () {
      var _getText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65(key) {
        var data;
        return _regeneratorRuntime().wrap(function _callee65$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              _context65.next = 2;
              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, "text(bytes32,string)", [key]);
            case 2:
              data = _context65.sent;
              if (!(data == null || data === "0x")) {
                _context65.next = 5;
                break;
              }
              return _context65.abrupt("return", null);
            case 5:
              return _context65.abrupt("return", data);
            case 6:
            case "end":
              return _context65.stop();
          }
        }, _callee65, this);
      }));
      function getText(_x115) {
        return _getText.apply(this, arguments);
      }
      return getText;
    }()
    /**
     *  Rsolves to the content-hash or ``null`` if unconfigured.
     */
  }, {
    key: "getContentHash",
    value: function () {
      var _getContentHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee66() {
        var data, ipfs, scheme, length, swarm;
        return _regeneratorRuntime().wrap(function _callee66$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              _context66.next = 2;
              return _classPrivateMethodGet(this, _fetch, _fetch2).call(this, "contenthash()");
            case 2:
              data = _context66.sent;
              if (!(data == null || data === "0x")) {
                _context66.next = 5;
                break;
              }
              return _context66.abrupt("return", null);
            case 5:
              // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)
              ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
              if (!ipfs) {
                _context66.next = 11;
                break;
              }
              scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
              length = parseInt(ipfs[4], 16);
              if (!(ipfs[5].length === length * 2)) {
                _context66.next = 11;
                break;
              }
              return _context66.abrupt("return", "".concat(scheme, "://").concat(encodeBase58("0x" + ipfs[2])));
            case 11:
              // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
              swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
              if (!(swarm && swarm[1].length === 64)) {
                _context66.next = 14;
                break;
              }
              return _context66.abrupt("return", "bzz://".concat(swarm[1]));
            case 14:
              assert$1(false, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
                operation: "getContentHash()",
                info: {
                  data: data
                }
              });
            case 15:
            case "end":
              return _context66.stop();
          }
        }, _callee66, this);
      }));
      function getContentHash() {
        return _getContentHash.apply(this, arguments);
      }
      return getContentHash;
    }()
    /**
     *  Resolves to the avatar url or ``null`` if the avatar is either
     *  unconfigured or incorrectly configured (e.g. references an NFT
     *  not owned by the address).
     *
     *  If diagnosing issues with configurations, the [[_getAvatar]]
     *  method may be useful.
     */
  }, {
    key: "getAvatar",
    value: function () {
      var _getAvatar2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee67() {
        var avatar;
        return _regeneratorRuntime().wrap(function _callee67$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              _context67.next = 2;
              return this._getAvatar();
            case 2:
              avatar = _context67.sent;
              return _context67.abrupt("return", avatar.url);
            case 4:
            case "end":
              return _context67.stop();
          }
        }, _callee67, this);
      }));
      function getAvatar() {
        return _getAvatar2.apply(this, arguments);
      }
      return getAvatar;
    }()
    /**
     *  When resolving an avatar, there are many steps involved, such
     *  fetching metadata and possibly validating ownership of an
     *  NFT.
     *
     *  This method can be used to examine each step and the value it
     *  was working from.
     */
  }, {
    key: "_getAvatar",
    value: function () {
      var _getAvatar3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee68() {
        var linkage, avatar, _i50, match, scheme, url, selector, owner, comps, tokenId, contract, tokenOwner, balance, metadataUrl, metadata, response, _bytes5, imageUrl, ipfs;
        return _regeneratorRuntime().wrap(function _callee68$(_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              linkage = [{
                type: "name",
                value: this.name
              }];
              _context68.prev = 1;
              _context68.next = 4;
              return this.getText("avatar");
            case 4:
              avatar = _context68.sent;
              if (!(avatar == null)) {
                _context68.next = 8;
                break;
              }
              linkage.push({
                type: "!avatar",
                value: ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 8:
              linkage.push({
                type: "avatar",
                value: avatar
              });
              _i50 = 0;
            case 10:
              if (!(_i50 < matchers.length)) {
                _context68.next = 109;
                break;
              }
              match = avatar.match(matchers[_i50]);
              if (!(match == null)) {
                _context68.next = 14;
                break;
              }
              return _context68.abrupt("continue", 106);
            case 14:
              scheme = match[1].toLowerCase();
              _context68.t0 = scheme;
              _context68.next = _context68.t0 === "https" ? 18 : _context68.t0 === "data" ? 18 : _context68.t0 === "ipfs" ? 20 : _context68.t0 === "erc721" ? 24 : _context68.t0 === "erc1155" ? 24 : 106;
              break;
            case 18:
              linkage.push({
                type: "url",
                value: avatar
              });
              return _context68.abrupt("return", {
                linkage: linkage,
                url: avatar
              });
            case 20:
              url = getIpfsLink(avatar);
              linkage.push({
                type: "ipfs",
                value: avatar
              });
              linkage.push({
                type: "url",
                value: url
              });
              return _context68.abrupt("return", {
                linkage: linkage,
                url: url
              });
            case 24:
              // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
              selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
              linkage.push({
                type: scheme,
                value: avatar
              });
              // The owner of this name
              _context68.next = 28;
              return this.getAddress();
            case 28:
              owner = _context68.sent;
              if (!(owner == null)) {
                _context68.next = 32;
                break;
              }
              linkage.push({
                type: "!owner",
                value: ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 32:
              comps = (match[2] || "").split("/");
              if (!(comps.length !== 2)) {
                _context68.next = 36;
                break;
              }
              linkage.push({
                type: "!".concat(scheme, "caip"),
                value: match[2] || ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 36:
              tokenId = comps[1];
              contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider); // Check that this account owns the token
              if (!(scheme === "erc721")) {
                _context68.next = 48;
                break;
              }
              _context68.next = 41;
              return contract.ownerOf(tokenId);
            case 41:
              tokenOwner = _context68.sent;
              if (!(owner !== tokenOwner)) {
                _context68.next = 45;
                break;
              }
              linkage.push({
                type: "!owner",
                value: tokenOwner
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 45:
              linkage.push({
                type: "owner",
                value: tokenOwner
              });
              _context68.next = 56;
              break;
            case 48:
              if (!(scheme === "erc1155")) {
                _context68.next = 56;
                break;
              }
              _context68.next = 51;
              return contract.balanceOf(owner, tokenId);
            case 51:
              balance = _context68.sent;
              if (balance) {
                _context68.next = 55;
                break;
              }
              linkage.push({
                type: "!balance",
                value: "0"
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 55:
              linkage.push({
                type: "balance",
                value: balance.toString()
              });
            case 56:
              _context68.next = 58;
              return contract[selector](tokenId);
            case 58:
              metadataUrl = _context68.sent;
              if (!(metadataUrl == null || metadataUrl === "0x")) {
                _context68.next = 62;
                break;
              }
              linkage.push({
                type: "!metadata-url",
                value: ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 62:
              linkage.push({
                type: "metadata-url-base",
                value: metadataUrl
              });
              // ERC-1155 allows a generic {id} in the URL
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
                linkage.push({
                  type: "metadata-url-expanded",
                  value: metadataUrl
                });
              }
              // Transform IPFS metadata links
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({
                type: "metadata-url",
                value: metadataUrl
              });
              // Get the token metadata
              metadata = {};
              _context68.next = 69;
              return new FetchRequest(metadataUrl).send();
            case 69:
              response = _context68.sent;
              response.assertOk();
              _context68.prev = 71;
              metadata = response.bodyJson;
              _context68.next = 87;
              break;
            case 75:
              _context68.prev = 75;
              _context68.t1 = _context68["catch"](71);
              _context68.prev = 77;
              linkage.push({
                type: "!metadata",
                value: response.bodyText
              });
              _context68.next = 86;
              break;
            case 81:
              _context68.prev = 81;
              _context68.t2 = _context68["catch"](77);
              _bytes5 = response.body;
              if (_bytes5) {
                linkage.push({
                  type: "!metadata",
                  value: hexlify(_bytes5)
                });
              }
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 86:
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 87:
              if (metadata) {
                _context68.next = 90;
                break;
              }
              linkage.push({
                type: "!metadata",
                value: ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 90:
              linkage.push({
                type: "metadata",
                value: JSON.stringify(metadata)
              });
              // Pull the image URL out
              imageUrl = metadata.image;
              if (!(typeof imageUrl !== "string")) {
                _context68.next = 95;
                break;
              }
              linkage.push({
                type: "!imageUrl",
                value: ""
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 95:
              if (!imageUrl.match(/^(https:\/\/|data:)/i)) {
                _context68.next = 98;
                break;
              }
              _context68.next = 104;
              break;
            case 98:
              // Transform IPFS link to gateway
              ipfs = imageUrl.match(matcherIpfs);
              if (!(ipfs == null)) {
                _context68.next = 102;
                break;
              }
              linkage.push({
                type: "!imageUrl-ipfs",
                value: imageUrl
              });
              return _context68.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 102:
              linkage.push({
                type: "imageUrl-ipfs",
                value: imageUrl
              });
              imageUrl = getIpfsLink(imageUrl);
            case 104:
              linkage.push({
                type: "url",
                value: imageUrl
              });
              return _context68.abrupt("return", {
                linkage: linkage,
                url: imageUrl
              });
            case 106:
              _i50++;
              _context68.next = 10;
              break;
            case 109:
              _context68.next = 113;
              break;
            case 111:
              _context68.prev = 111;
              _context68.t3 = _context68["catch"](1);
            case 113:
              return _context68.abrupt("return", {
                linkage: linkage,
                url: null
              });
            case 114:
            case "end":
              return _context68.stop();
          }
        }, _callee68, this, [[1, 111], [71, 75], [77, 81]]);
      }));
      function _getAvatar() {
        return _getAvatar3.apply(this, arguments);
      }
      return _getAvatar;
    }()
  }], [{
    key: "getEnsAddress",
    value: function () {
      var _getEnsAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee69(provider) {
        var network, ensPlugin;
        return _regeneratorRuntime().wrap(function _callee69$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              _context69.next = 2;
              return provider.getNetwork();
            case 2:
              network = _context69.sent;
              ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens"); // No ENS...
              assert$1(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: {
                  network: network
                }
              });
              return _context69.abrupt("return", ensPlugin.address);
            case 6:
            case "end":
              return _context69.stop();
          }
        }, _callee69);
      }));
      function getEnsAddress(_x116) {
        return _getEnsAddress.apply(this, arguments);
      }
      return getEnsAddress;
    }()
  }, {
    key: "fromName",
    value:
    /**
     *  Resolve to the ENS resolver for %%name%% using %%provider%% or
     *  ``null`` if unconfigured.
     */
    function () {
      var _fromName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee70(provider, name) {
        var currentName, addr, resolver;
        return _regeneratorRuntime().wrap(function _callee70$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              currentName = name;
            case 1:
              if (!true) {
                _context70.next = 22;
                break;
              }
              if (!(currentName === "" || currentName === ".")) {
                _context70.next = 4;
                break;
              }
              return _context70.abrupt("return", null);
            case 4:
              if (!(name !== "eth" && currentName === "eth")) {
                _context70.next = 6;
                break;
              }
              return _context70.abrupt("return", null);
            case 6:
              _context70.next = 8;
              return _classStaticPrivateMethodGet(EnsResolver, EnsResolver, _getResolver).call(EnsResolver, provider, currentName);
            case 8:
              addr = _context70.sent;
              if (!(addr != null)) {
                _context70.next = 19;
                break;
              }
              resolver = new EnsResolver(provider, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use
              _context70.t0 = currentName !== name;
              if (!_context70.t0) {
                _context70.next = 16;
                break;
              }
              _context70.next = 15;
              return resolver.supportsWildcard();
            case 15:
              _context70.t0 = !_context70.sent;
            case 16:
              if (!_context70.t0) {
                _context70.next = 18;
                break;
              }
              return _context70.abrupt("return", null);
            case 18:
              return _context70.abrupt("return", resolver);
            case 19:
              // Get the parent node
              currentName = currentName.split(".").slice(1).join(".");
              _context70.next = 1;
              break;
            case 22:
            case "end":
              return _context70.stop();
          }
        }, _callee70);
      }));
      function fromName(_x117, _x118) {
        return _fromName.apply(this, arguments);
      }
      return fromName;
    }()
  }]);
  return EnsResolver;
}();
/**
 *  @_ignore
 */
exports.EnsResolver = EnsResolver;
function _fetch2(_x285, _x286) {
  return _fetch4.apply(this, arguments);
}
function _fetch4() {
  _fetch4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee226(funcName, params) {
    var iface, fragment, _classPrivateFieldGet3, result;
    return _regeneratorRuntime().wrap(function _callee226$(_context229) {
      while (1) switch (_context229.prev = _context229.next) {
        case 0:
          params = (params || []).slice();
          iface = _classPrivateFieldGet(this, _resolver)["interface"]; // The first parameters is always the nodehash
          params.unshift(namehash(this.name));
          fragment = null;
          _context229.next = 6;
          return this.supportsWildcard();
        case 6:
          if (!_context229.sent) {
            _context229.next = 11;
            break;
          }
          fragment = iface.getFunction(funcName);
          assert$1(fragment, "missing fragment", "UNKNOWN_ERROR", {
            info: {
              funcName: funcName
            }
          });
          params = [dnsEncode(this.name), iface.encodeFunctionData(fragment, params)];
          funcName = "resolve(bytes,bytes)";
        case 11:
          params.push({
            ccipReadEnable: true
          });
          _context229.prev = 12;
          _context229.next = 15;
          return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _resolver))[funcName].apply(_classPrivateFieldGet3, _toConsumableArray(params));
        case 15:
          result = _context229.sent;
          if (!fragment) {
            _context229.next = 18;
            break;
          }
          return _context229.abrupt("return", iface.decodeFunctionResult(fragment, result)[0]);
        case 18:
          return _context229.abrupt("return", result);
        case 21:
          _context229.prev = 21;
          _context229.t0 = _context229["catch"](12);
          if (isError(_context229.t0, "CALL_EXCEPTION")) {
            _context229.next = 25;
            break;
          }
          throw _context229.t0;
        case 25:
          return _context229.abrupt("return", null);
        case 26:
        case "end":
          return _context229.stop();
      }
    }, _callee226, this, [[12, 21]]);
  }));
  return _fetch4.apply(this, arguments);
}
function _getResolver(_x287, _x288) {
  return _getResolver4.apply(this, arguments);
}
function _getResolver4() {
  _getResolver4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee227(provider, name) {
    var ensAddr, contract, addr;
    return _regeneratorRuntime().wrap(function _callee227$(_context230) {
      while (1) switch (_context230.prev = _context230.next) {
        case 0:
          _context230.next = 2;
          return EnsResolver.getEnsAddress(provider);
        case 2:
          ensAddr = _context230.sent;
          _context230.prev = 3;
          contract = new Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], provider);
          _context230.next = 7;
          return contract.resolver(namehash(name), {
            enableCcipRead: true
          });
        case 7:
          addr = _context230.sent;
          if (!(addr === ZeroAddress)) {
            _context230.next = 10;
            break;
          }
          return _context230.abrupt("return", null);
        case 10:
          return _context230.abrupt("return", addr);
        case 13:
          _context230.prev = 13;
          _context230.t0 = _context230["catch"](3);
          throw _context230.t0;
        case 16:
          return _context230.abrupt("return", null);
        case 17:
        case "end":
          return _context230.stop();
      }
    }, _callee227, null, [[3, 13]]);
  }));
  return _getResolver4.apply(this, arguments);
}
var BN_0 = BigInt(0);
function allowNull(format, nullValue) {
  return function (value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format) {
  return function (array) {
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map(function (i) {
      return format(i);
    });
  };
}
// Requires an object which matches a fleet of other formatters
// Any FormatFunc may return `undefined` to have the value omitted
// from the result object. Calls preserve `this`.
function object(format, altNames) {
  return function (value) {
    var result = {};
    for (var key in format) {
      var srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        var _iterator30 = _createForOfIteratorHelper(altNames[key]),
          _step30;
        try {
          for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
            var altKey = _step30.value;
            if (altKey in value) {
              srcKey = altKey;
              break;
            }
          }
        } catch (err) {
          _iterator30.e(err);
        } finally {
          _iterator30.f();
        }
      }
      try {
        var nv = format[key](value[srcKey]);
        if (nv !== undefined) {
          result[key] = nv;
        }
      } catch (error) {
        var message = error instanceof Error ? error.message : "not-an-error";
        assert$1(false, "invalid value for value.".concat(key, " (").concat(message, ")"), "BAD_DATA", {
          value: value
        });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, "invalid boolean; ".concat(JSON.stringify(value)), "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
function formatUint256(value) {
  if (!isHexString(value)) {
    throw new Error("invalid uint256");
  }
  return zeroPadValue(value, 32);
}
var _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: formatBoolean,
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  miner: allowNull(getAddress),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
});
function formatBlock(value) {
  var result = _formatBlock(value);
  result.transactions = value.transactions.map(function (tx) {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
var _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
var _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  // Some clients (TestRPC) do strange things like return 0x0 for the
  // 0 address; correct this to be a real address
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  var result = object({
    hash: formatHash,
    type: function type(value) {
      if (value === "0x" || value == null) {
        return 0;
      }
      return getNumber(value);
    },
    accessList: allowNull(accessListify, null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    //confirmations: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(value);
  // If to and creates are empty, populate the creates from the value
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  // @TODO: Check fee data
  // Add an access list to supported transaction types
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  // Compute the signature
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  // Some backends omit ChainId on legacy transactions, but we can compute it
  if (result.chainId == null) {
    var chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  // @TODO: check chainID
  /*
  if (value.chainId != null) {
      let chainId = value.chainId;
       if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
      }
       result.chainId = chainId;
   } else {
      let chainId = value.networkId;
       // geth-etc returns chainId
      if (chainId == null && result.v == null) {
          chainId = value.chainId;
      }
       if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
      }
       if (typeof(chainId) !== "number" && result.v != null) {
          chainId = (result.v - 35) / 2;
          if (chainId < 0) { chainId = 0; }
          chainId = parseInt(chainId);
      }
       if (typeof(chainId) !== "number") { chainId = 0; }
       result.chainId = chainId;
  }
  */
  // 0x0000... should actually be null
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
var NetworkPlugin = /*#__PURE__*/function () {
  function NetworkPlugin(name) {
    _classCallCheck(this, NetworkPlugin);
    _defineProperty(this, "name", void 0);
    defineProperties(this, {
      name: name
    });
  }
  _createClass(NetworkPlugin, [{
    key: "clone",
    value: function clone() {
      return new NetworkPlugin(this.name);
    }
  }]);
  return NetworkPlugin;
}();
var GasCostPlugin = /*#__PURE__*/function (_NetworkPlugin) {
  _inherits(GasCostPlugin, _NetworkPlugin);
  var _super40 = _createSuper(GasCostPlugin);
  function GasCostPlugin(effectiveBlock, costs) {
    var _this49;
    _classCallCheck(this, GasCostPlugin);
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    _this49 = _super40.call(this, "org.ethers.network.plugins.GasCost#".concat(effectiveBlock || 0));
    _defineProperty(_assertThisInitialized(_this49), "effectiveBlock", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txBase", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txCreate", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txDataZero", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txDataNonzero", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txAccessListStorageKey", void 0);
    _defineProperty(_assertThisInitialized(_this49), "txAccessListAddress", void 0);
    var props = {
      effectiveBlock: effectiveBlock
    };
    function set(name, nullish) {
      var value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", "invalud value for ".concat(name), "costs", costs);
      props[name] = value;
    }
    set("txBase", 21000);
    set("txCreate", 32000);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(_assertThisInitialized(_this49), props);
    return _this49;
  }
  _createClass(GasCostPlugin, [{
    key: "clone",
    value: function clone() {
      return new GasCostPlugin(this.effectiveBlock, this);
    }
  }]);
  return GasCostPlugin;
}(NetworkPlugin); // Networks shoudl use this plugin to specify the contract address
// and network necessary to resolve ENS names.
var EnsPlugin = /*#__PURE__*/function (_NetworkPlugin2) {
  _inherits(EnsPlugin, _NetworkPlugin2);
  var _super41 = _createSuper(EnsPlugin);
  // The ENS contract address

  // The network ID that the ENS contract lives on

  function EnsPlugin(address, targetNetwork) {
    var _this50;
    _classCallCheck(this, EnsPlugin);
    _this50 = _super41.call(this, "org.ethers.plugins.network.Ens");
    _defineProperty(_assertThisInitialized(_this50), "address", void 0);
    _defineProperty(_assertThisInitialized(_this50), "targetNetwork", void 0);
    defineProperties(_assertThisInitialized(_this50), {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
    return _this50;
  }
  _createClass(EnsPlugin, [{
    key: "clone",
    value: function clone() {
      return new EnsPlugin(this.address, this.targetNetwork);
    }
  }]);
  return EnsPlugin;
}(NetworkPlugin);
var _feeDataFunc = /*#__PURE__*/new WeakMap();
var FeeDataNetworkPlugin = /*#__PURE__*/function (_NetworkPlugin3) {
  _inherits(FeeDataNetworkPlugin, _NetworkPlugin3);
  var _super42 = _createSuper(FeeDataNetworkPlugin);
  function FeeDataNetworkPlugin(feeDataFunc) {
    var _this51;
    _classCallCheck(this, FeeDataNetworkPlugin);
    _this51 = _super42.call(this, "org.ethers.plugins.network.FeeData");
    _classPrivateFieldInitSpec(_assertThisInitialized(_this51), _feeDataFunc, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this51), _feeDataFunc, feeDataFunc);
    return _this51;
  }
  _createClass(FeeDataNetworkPlugin, [{
    key: "feeDataFunc",
    get: function get() {
      return _classPrivateFieldGet(this, _feeDataFunc);
    }
  }, {
    key: "getFeeData",
    value: function () {
      var _getFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee71(provider) {
        return _regeneratorRuntime().wrap(function _callee71$(_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              _context71.next = 2;
              return _classPrivateFieldGet(this, _feeDataFunc).call(this, provider);
            case 2:
              return _context71.abrupt("return", _context71.sent);
            case 3:
            case "end":
              return _context71.stop();
          }
        }, _callee71, this);
      }));
      function getFeeData(_x119) {
        return _getFeeData.apply(this, arguments);
      }
      return getFeeData;
    }()
  }, {
    key: "clone",
    value: function clone() {
      return new FeeDataNetworkPlugin(_classPrivateFieldGet(this, _feeDataFunc));
    }
  }]);
  return FeeDataNetworkPlugin;
}(NetworkPlugin);
/*
export class CustomBlockNetworkPlugin extends NetworkPlugin {
    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;
    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;

    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {
        super("org.ethers.network-plugins.custom-block");
        this.#blockFunc = blockFunc;
        this.#blockWithTxsFunc = blockWithTxsFunc;
    }

    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {
        return await this.#blockFunc(provider, block);
    }

    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {
        return await this.#blockWithTxsFunc(provider, block);
    }

    clone(): CustomBlockNetworkPlugin {
        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);
    }
}
*/
/**
 *  About networks
 *
 *  @_subsection: api/providers:Networks  [networks]
 */
/* * * *
// Networks which operation against an L2 can use this plugin to
// specify how to access L1, for the purpose of resolving ENS,
// for example.
export class LayerOneConnectionPlugin extends NetworkPlugin {
    readonly provider!: Provider;
// @TODO: Rename to ChainAccess and allow for connecting to any chain
    constructor(provider: Provider) {
        super("org.ethers.plugins.layer-one-connection");
        defineProperties<LayerOneConnectionPlugin>(this, { provider });
    }

    clone(): LayerOneConnectionPlugin {
        return new LayerOneConnectionPlugin(this.provider);
    }
}
*/
/* * * *
export class PriceOraclePlugin extends NetworkPlugin {
    readonly address!: string;

    constructor(address: string) {
        super("org.ethers.plugins.price-oracle");
        defineProperties<PriceOraclePlugin>(this, { address });
    }

    clone(): PriceOraclePlugin {
        return new PriceOraclePlugin(this.address);
    }
}
*/
// Networks or clients with a higher need for security (such as clients
// that may automatically make CCIP requests without user interaction)
// can use this plugin to anonymize requests or intercept CCIP requests
// to notify and/or receive authorization from the user
/* * * *
export type FetchDataFunc = (req: Frozen<FetchRequest>) => Promise<FetchRequest>;
export class CcipPreflightPlugin extends NetworkPlugin {
    readonly fetchData!: FetchDataFunc;

    constructor(fetchData: FetchDataFunc) {
        super("org.ethers.plugins.ccip-preflight");
        defineProperties<CcipPreflightPlugin>(this, { fetchData });
    }

    clone(): CcipPreflightPlugin {
        return new CcipPreflightPlugin(this.fetchData);
    }
}
*/
var Networks = new Map();
// @TODO: Add a _ethersNetworkObj variable to better detect network ovjects
var _name3 = /*#__PURE__*/new WeakMap();
var _chainId2 = /*#__PURE__*/new WeakMap();
var _plugins = /*#__PURE__*/new WeakMap();
var Network = /*#__PURE__*/function () {
  function Network(name, chainId) {
    _classCallCheck(this, Network);
    _classPrivateFieldInitSpec(this, _name3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _chainId2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _plugins, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _name3, name);
    _classPrivateFieldSet(this, _chainId2, getBigInt(chainId));
    _classPrivateFieldSet(this, _plugins, new Map());
  }
  _createClass(Network, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        chainId: this.chainId
      };
    }
  }, {
    key: "name",
    get: function get() {
      return _classPrivateFieldGet(this, _name3);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _name3, value);
    }
  }, {
    key: "chainId",
    get: function get() {
      return _classPrivateFieldGet(this, _chainId2);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _chainId2, getBigInt(value, "chainId"));
    }
  }, {
    key: "plugins",
    get: function get() {
      return Array.from(_classPrivateFieldGet(this, _plugins).values());
    }
  }, {
    key: "attachPlugin",
    value: function attachPlugin(plugin) {
      if (_classPrivateFieldGet(this, _plugins).get(plugin.name)) {
        throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
      }
      _classPrivateFieldGet(this, _plugins).set(plugin.name, plugin.clone());
      return this;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return _classPrivateFieldGet(this, _plugins).get(name) || null;
    }
    // Gets a list of Plugins which match basename, ignoring any fragment
  }, {
    key: "getPlugins",
    value: function getPlugins(basename) {
      return this.plugins.filter(function (p) {
        return p.name.split("#")[0] === basename;
      });
    }
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Network(this.name, this.chainId);
      this.plugins.forEach(function (plugin) {
        clone.attachPlugin(plugin.clone());
      });
      return clone;
    }
  }, {
    key: "computeIntrinsicGas",
    value: function computeIntrinsicGas(tx) {
      var costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
      var gas = costs.txBase;
      if (tx.to == null) {
        gas += costs.txCreate;
      }
      if (tx.data) {
        for (var _i51 = 2; _i51 < tx.data.length; _i51 += 2) {
          if (tx.data.substring(_i51, _i51 + 2) === "00") {
            gas += costs.txDataZero;
          } else {
            gas += costs.txDataNonzero;
          }
        }
      }
      if (tx.accessList) {
        var accessList = accessListify(tx.accessList);
        for (var addr in accessList) {
          gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
        }
      }
      return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
  }], [{
    key: "from",
    value: function from(network) {
      injectCommonNetworks();
      // Default network
      if (network == null) {
        return Network.from("mainnet");
      }
      // Canonical name or chain ID
      if (typeof network === "number") {
        network = BigInt(network);
      }
      if (typeof network === "string" || typeof network === "bigint") {
        var networkFunc = Networks.get(network);
        if (networkFunc) {
          return networkFunc();
        }
        if (typeof network === "bigint") {
          return new Network("unknown", network);
        }
        assertArgument(false, "unknown network", "network", network);
      }
      // Clonable with network-like abilities
      if (typeof network.clone === "function") {
        var clone = network.clone();
        //if (typeof(network.name) !== "string" || typeof(network.chainId) !== "number") {
        //}
        return clone;
      }
      // Networkish
      if (_typeof(network) === "object") {
        assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
        var custom = new Network(network.name, network.chainId);
        if (network.ensAddress || network.ensNetwork != null) {
          custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
        }
        //if ((<any>network).layerOneConnection) {
        //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));
        //}
        return custom;
      }
      assertArgument(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
  }, {
    key: "register",
    value: function register(nameOrChainId, networkFunc) {
      if (typeof nameOrChainId === "number") {
        nameOrChainId = BigInt(nameOrChainId);
      }
      var existing = Networks.get(nameOrChainId);
      if (existing) {
        assertArgument(false, "conflicting network for ".concat(JSON.stringify(existing.name)), "nameOrChainId", nameOrChainId);
      }
      Networks.set(nameOrChainId, networkFunc);
    }
  }]);
  return Network;
}(); // See: https://chainlist.org
exports.Network = Network;
var injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  /// Register popular Ethereum networks
  function registerEth(name, chainId, options) {
    var func = function func() {
      var network = new Network(name, chainId);
      // We use 0 to disable ENS
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      if (options.priorityFee) {
        //                network.attachPlugin(new MaxPriorityFeePlugin(options.priorityFee));
      }
      /*
                  if (options.etherscan) {
                      const { url, apiKey } = options.etherscan;
                      network.attachPlugin(new EtherscanPlugin(url, apiKey));
                  }
      */
      network.attachPlugin(new GasCostPlugin());
      return network;
    };
    // Register the network by name and chain ID
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach(function (name) {
        Network.register(name, func);
      });
    }
  }
  registerEth("mainnet", 1, {
    ensNetwork: 1,
    altNames: ["homestead"]
  });
  registerEth("ropsten", 3, {
    ensNetwork: 3
  });
  registerEth("rinkeby", 4, {
    ensNetwork: 4
  });
  registerEth("goerli", 5, {
    ensNetwork: 5
  });
  registerEth("kovan", 42, {
    ensNetwork: 42
  });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("xdai", 100, {
    ensNetwork: 1
  });
  // Polygon has a 35 gwei maxPriorityFee requirement
  registerEth("matic", 137, {
    ensNetwork: 1,
    //        priorityFee: 35000000000,
    etherscan: {
      apiKey: "W6T8DJW654GNTQ34EFEYYP3EZD9DD27CT7",
      url: "https:/\/api.polygonscan.com/"
    }
  });
  registerEth("maticMumbai", 80001, {
    //        priorityFee: 35000000000,
    etherscan: {
      apiKey: "W6T8DJW654GNTQ34EFEYYP3EZD9DD27CT7",
      url: "https:/\/api-testnet.polygonscan.com/"
    }
  });
  registerEth("bnb", 56, {
    ensNetwork: 1,
    etherscan: {
      apiKey: "EVTS3CU31AATZV72YQ55TPGXGMVIFUQ9M9",
      url: "http:/\/api.bscscan.com"
    }
  });
  registerEth("bnbt", 97, {
    etherscan: {
      apiKey: "EVTS3CU31AATZV72YQ55TPGXGMVIFUQ9M9",
      url: "http:/\/api-testnet.bscscan.com"
    }
  });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
function getPollingSubscriber(provider, event) {
  if (event === "block") {
    return new PollingBlockSubscriber(provider);
  }
  if (isHexString(event, 32)) {
    return new PollingTransactionSubscriber(provider, event);
  }
  assert$1(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
    operation: "getPollingSubscriber",
    info: {
      event: event
    }
  });
}
// @TODO: refactor this
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider = /*#__PURE__*/new WeakMap();
var _poller = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _blockNumber = /*#__PURE__*/new WeakMap();
var _poll = /*#__PURE__*/new WeakSet();
var PollingBlockSubscriber = /*#__PURE__*/function () {
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number

  function PollingBlockSubscriber(provider) {
    _classCallCheck(this, PollingBlockSubscriber);
    _classPrivateMethodInitSpec(this, _poll);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _poller, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _interval, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _blockNumber, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _provider, provider);
    _classPrivateFieldSet(this, _poller, null);
    _classPrivateFieldSet(this, _interval, 4000);
    _classPrivateFieldSet(this, _blockNumber, -2);
  }
  _createClass(PollingBlockSubscriber, [{
    key: "pollingInterval",
    get: function get() {
      return _classPrivateFieldGet(this, _interval);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _interval, value);
    }
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(this, _poller)) {
        return;
      }
      _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));
      _classPrivateMethodGet(this, _poll, _poll2).call(this);
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(this, _poller)) {
        return;
      }
      _classPrivateFieldGet(this, _provider)._clearTimeout(_classPrivateFieldGet(this, _poller));
      _classPrivateFieldSet(this, _poller, null);
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        _classPrivateFieldSet(this, _blockNumber, -2);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
  return PollingBlockSubscriber;
}();
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
function _poll2() {
  return _poll11.apply(this, arguments);
}
function _poll11() {
  _poll11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee228() {
    var blockNumber, _b3;
    return _regeneratorRuntime().wrap(function _callee228$(_context231) {
      while (1) switch (_context231.prev = _context231.next) {
        case 0:
          _context231.next = 2;
          return _classPrivateFieldGet(this, _provider).getBlockNumber();
        case 2:
          blockNumber = _context231.sent;
          if (!(_classPrivateFieldGet(this, _blockNumber) === -2)) {
            _context231.next = 6;
            break;
          }
          _classPrivateFieldSet(this, _blockNumber, blockNumber);
          return _context231.abrupt("return");
        case 6:
          if (!(blockNumber !== _classPrivateFieldGet(this, _blockNumber))) {
            _context231.next = 17;
            break;
          }
          _b3 = _classPrivateFieldGet(this, _blockNumber) + 1;
        case 8:
          if (!(_b3 <= blockNumber)) {
            _context231.next = 16;
            break;
          }
          if (!(_classPrivateFieldGet(this, _poller) == null)) {
            _context231.next = 11;
            break;
          }
          return _context231.abrupt("return");
        case 11:
          _context231.next = 13;
          return _classPrivateFieldGet(this, _provider).emit("block", _b3);
        case 13:
          _b3++;
          _context231.next = 8;
          break;
        case 16:
          _classPrivateFieldSet(this, _blockNumber, blockNumber);
        case 17:
          if (!(_classPrivateFieldGet(this, _poller) == null)) {
            _context231.next = 19;
            break;
          }
          return _context231.abrupt("return");
        case 19:
          _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));
        case 20:
        case "end":
          return _context231.stop();
      }
    }, _callee228, this);
  }));
  return _poll11.apply(this, arguments);
}
var _provider2 = /*#__PURE__*/new WeakMap();
var _poll3 = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var OnBlockSubscriber = /*#__PURE__*/function () {
  function OnBlockSubscriber(provider) {
    var _this52 = this;
    _classCallCheck(this, OnBlockSubscriber);
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _poll3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _running, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _provider2, provider);
    _classPrivateFieldSet(this, _running, false);
    _classPrivateFieldSet(this, _poll3, function (blockNumber) {
      _this52._poll(blockNumber, _classPrivateFieldGet(_this52, _provider2));
    });
  }
  _createClass(OnBlockSubscriber, [{
    key: "_poll",
    value: function () {
      var _poll4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72(blockNumber, provider) {
        return _regeneratorRuntime().wrap(function _callee72$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              throw new Error("sub-classes must override this");
            case 1:
            case "end":
              return _context72.stop();
          }
        }, _callee72);
      }));
      function _poll(_x120, _x121) {
        return _poll4.apply(this, arguments);
      }
      return _poll;
    }()
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(this, _running)) {
        return;
      }
      _classPrivateFieldSet(this, _running, true);
      _classPrivateFieldGet(this, _poll3).call(this, -2);
      _classPrivateFieldGet(this, _provider2).on("block", _classPrivateFieldGet(this, _poll3));
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(this, _running)) {
        return;
      }
      _classPrivateFieldSet(this, _running, false);
      _classPrivateFieldGet(this, _provider2).off("block", _classPrivateFieldGet(this, _poll3));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
  return OnBlockSubscriber;
}();
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _filter3 = /*#__PURE__*/new WeakMap();
var PollingOrphanSubscriber = /*#__PURE__*/function (_OnBlockSubscriber) {
  _inherits(PollingOrphanSubscriber, _OnBlockSubscriber);
  var _super43 = _createSuper(PollingOrphanSubscriber);
  function PollingOrphanSubscriber(provider, filter) {
    var _this53;
    _classCallCheck(this, PollingOrphanSubscriber);
    _this53 = _super43.call(this, provider);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this53), _filter3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this53), _filter3, copy$2(filter));
    return _this53;
  }
  _createClass(PollingOrphanSubscriber, [{
    key: "_poll",
    value: function () {
      var _poll5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(blockNumber, provider) {
        return _regeneratorRuntime().wrap(function _callee73$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              throw new Error("@TODO");
            case 2:
            case "end":
              return _context73.stop();
          }
        }, _callee73, this);
      }));
      function _poll(_x122, _x123) {
        return _poll5.apply(this, arguments);
      }
      return _poll;
    }()
  }]);
  return PollingOrphanSubscriber;
}(OnBlockSubscriber);
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _hash5 = /*#__PURE__*/new WeakMap();
var PollingTransactionSubscriber = /*#__PURE__*/function (_OnBlockSubscriber2) {
  _inherits(PollingTransactionSubscriber, _OnBlockSubscriber2);
  var _super44 = _createSuper(PollingTransactionSubscriber);
  function PollingTransactionSubscriber(provider, hash) {
    var _this54;
    _classCallCheck(this, PollingTransactionSubscriber);
    _this54 = _super44.call(this, provider);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this54), _hash5, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this54), _hash5, hash);
    return _this54;
  }
  _createClass(PollingTransactionSubscriber, [{
    key: "_poll",
    value: function () {
      var _poll6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee74(blockNumber, provider) {
        var tx;
        return _regeneratorRuntime().wrap(function _callee74$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              _context74.next = 2;
              return provider.getTransactionReceipt(_classPrivateFieldGet(this, _hash5));
            case 2:
              tx = _context74.sent;
              if (tx) {
                provider.emit(_classPrivateFieldGet(this, _hash5), tx);
              }
            case 4:
            case "end":
              return _context74.stop();
          }
        }, _callee74, this);
      }));
      function _poll(_x124, _x125) {
        return _poll6.apply(this, arguments);
      }
      return _poll;
    }()
  }]);
  return PollingTransactionSubscriber;
}(OnBlockSubscriber);
/**
 *  @TODO
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider3 = /*#__PURE__*/new WeakMap();
var _filter4 = /*#__PURE__*/new WeakMap();
var _poller2 = /*#__PURE__*/new WeakMap();
var _running2 = /*#__PURE__*/new WeakMap();
var _blockNumber2 = /*#__PURE__*/new WeakMap();
var _poll7 = /*#__PURE__*/new WeakSet();
var PollingEventSubscriber = /*#__PURE__*/function () {
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number

  function PollingEventSubscriber(provider, _filter5) {
    _classCallCheck(this, PollingEventSubscriber);
    _classPrivateMethodInitSpec(this, _poll7);
    _classPrivateFieldInitSpec(this, _provider3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _filter4, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _poller2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _running2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _blockNumber2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _provider3, provider);
    _classPrivateFieldSet(this, _filter4, copy$2(_filter5));
    _classPrivateFieldSet(this, _poller2, _classPrivateMethodGet(this, _poll7, _poll8).bind(this));
    _classPrivateFieldSet(this, _running2, false);
    _classPrivateFieldSet(this, _blockNumber2, -2);
  }
  _createClass(PollingEventSubscriber, [{
    key: "start",
    value: function start() {
      var _this55 = this;
      if (_classPrivateFieldGet(this, _running2)) {
        return;
      }
      _classPrivateFieldSet(this, _running2, true);
      if (_classPrivateFieldGet(this, _blockNumber2) === -2) {
        _classPrivateFieldGet(this, _provider3).getBlockNumber().then(function (blockNumber) {
          _classPrivateFieldSet(_this55, _blockNumber2, blockNumber);
        });
      }
      _classPrivateFieldGet(this, _provider3).on("block", _classPrivateFieldGet(this, _poller2));
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(this, _running2)) {
        return;
      }
      _classPrivateFieldSet(this, _running2, false);
      _classPrivateFieldGet(this, _provider3).off("block", _classPrivateFieldGet(this, _poller2));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        _classPrivateFieldSet(this, _blockNumber2, -2);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
  return PollingEventSubscriber;
}();
/**
 *  About Subclassing the Provider...
 *
 *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]
 */
// Constants
function _poll8(_x289) {
  return _poll12.apply(this, arguments);
}
function _poll12() {
  _poll12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee229(blockNumber) {
    var filter, logs, _iterator61, _step61, log;
    return _regeneratorRuntime().wrap(function _callee229$(_context232) {
      while (1) switch (_context232.prev = _context232.next) {
        case 0:
          if (!(_classPrivateFieldGet(this, _blockNumber2) === -2)) {
            _context232.next = 2;
            break;
          }
          return _context232.abrupt("return");
        case 2:
          filter = copy$2(_classPrivateFieldGet(this, _filter4));
          filter.fromBlock = _classPrivateFieldGet(this, _blockNumber2) + 1;
          filter.toBlock = blockNumber;
          _context232.next = 7;
          return _classPrivateFieldGet(this, _provider3).getLogs(filter);
        case 7:
          logs = _context232.sent;
          if (!(logs.length === 0)) {
            _context232.next = 11;
            break;
          }
          if (_classPrivateFieldGet(this, _blockNumber2) < blockNumber - 60) {
            _classPrivateFieldSet(this, _blockNumber2, blockNumber - 60);
          }
          return _context232.abrupt("return");
        case 11:
          _classPrivateFieldSet(this, _blockNumber2, blockNumber);
          _iterator61 = _createForOfIteratorHelper(logs);
          try {
            for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
              log = _step61.value;
              _classPrivateFieldGet(this, _provider3).emit(_classPrivateFieldGet(this, _filter4), log);
            }
          } catch (err) {
            _iterator61.e(err);
          } finally {
            _iterator61.f();
          }
        case 14:
        case "end":
          return _context232.stop();
      }
    }, _callee229, this);
  }));
  return _poll12.apply(this, arguments);
}
var BN_2$1 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;
function isPromise$1(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, function (k, v) {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return "bigint:".concat(v.toString());
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    // Sort object keys
    if (_typeof(v) === "object" && !Array.isArray(v)) {
      var keys = Object.keys(v);
      keys.sort();
      return keys.reduce(function (accum, key) {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
var UnmanagedSubscriber = /*#__PURE__*/function () {
  function UnmanagedSubscriber(name) {
    _classCallCheck(this, UnmanagedSubscriber);
    _defineProperty(this, "name", void 0);
    defineProperties(this, {
      name: name
    });
  }
  _createClass(UnmanagedSubscriber, [{
    key: "start",
    value: function start() {}
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {}
  }, {
    key: "resume",
    value: function resume() {}
  }]);
  return UnmanagedSubscriber;
}();
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
function getSubscription(_x126, _x127) {
  return _getSubscription.apply(this, arguments);
}
function _getSubscription() {
  _getSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee216(_event, provider) {
    var _hash6, event, _event3, _filter7, addresses, promises, addAddress;
    return _regeneratorRuntime().wrap(function _callee216$(_context218) {
      while (1) switch (_context218.prev = _context218.next) {
        case 0:
          if (!(_event == null)) {
            _context218.next = 2;
            break;
          }
          throw new Error("invalid event");
        case 2:
          // Normalize topic array info an EventFilter
          if (Array.isArray(_event)) {
            _event = {
              topics: _event
            };
          }
          if (!(typeof _event === "string")) {
            _context218.next = 8;
            break;
          }
          _context218.t0 = _event;
          _context218.next = _context218.t0 === "block" ? 7 : _context218.t0 === "pending" ? 7 : _context218.t0 === "debug" ? 7 : _context218.t0 === "network" ? 7 : 8;
          break;
        case 7:
          return _context218.abrupt("return", {
            type: _event,
            tag: _event
          });
        case 8:
          if (!isHexString(_event, 32)) {
            _context218.next = 11;
            break;
          }
          _hash6 = _event.toLowerCase();
          return _context218.abrupt("return", {
            type: "transaction",
            tag: getTag("tx", {
              hash: _hash6
            }),
            hash: _hash6
          });
        case 11:
          if (!_event.orphan) {
            _context218.next = 14;
            break;
          }
          event = _event; // @TODO: Should lowercase and whatnot things here instead of copy...
          return _context218.abrupt("return", {
            type: "orphan",
            tag: getTag("orphan", event),
            filter: copy$1(event)
          });
        case 14:
          if (!(_event.address || _event.topics)) {
            _context218.next = 27;
            break;
          }
          _event3 = _event;
          _filter7 = {
            topics: (_event3.topics || []).map(function (t) {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                return concisify(t.map(function (t) {
                  return t.toLowerCase();
                }));
              }
              return t.toLowerCase();
            })
          };
          if (!_event3.address) {
            _context218.next = 26;
            break;
          }
          addresses = [];
          promises = [];
          addAddress = function addAddress(addr) {
            if (isHexString(addr)) {
              addresses.push(addr);
            } else {
              promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee215() {
                return _regeneratorRuntime().wrap(function _callee215$(_context217) {
                  while (1) switch (_context217.prev = _context217.next) {
                    case 0:
                      _context217.t0 = addresses;
                      _context217.next = 3;
                      return resolveAddress(addr, provider);
                    case 3:
                      _context217.t1 = _context217.sent;
                      _context217.t0.push.call(_context217.t0, _context217.t1);
                    case 5:
                    case "end":
                      return _context217.stop();
                  }
                }, _callee215);
              }))());
            }
          };
          if (Array.isArray(_event3.address)) {
            _event3.address.forEach(addAddress);
          } else {
            addAddress(_event3.address);
          }
          if (!promises.length) {
            _context218.next = 25;
            break;
          }
          _context218.next = 25;
          return Promise.all(promises);
        case 25:
          _filter7.address = concisify(addresses.map(function (a) {
            return a.toLowerCase();
          }));
        case 26:
          return _context218.abrupt("return", {
            filter: _filter7,
            tag: getTag("event", _filter7),
            type: "event"
          });
        case 27:
          assertArgument(false, "unknown ProviderEvent", "event", _event);
        case 28:
        case "end":
          return _context218.stop();
      }
    }, _callee216);
  }));
  return _getSubscription.apply(this, arguments);
}
function getTime$1() {
  return new Date().getTime();
}
var _subs = /*#__PURE__*/new WeakMap();
var _plugins2 = /*#__PURE__*/new WeakMap();
var _pausedState = /*#__PURE__*/new WeakMap();
var _networkPromise = /*#__PURE__*/new WeakMap();
var _anyNetwork = /*#__PURE__*/new WeakMap();
var _performCache = /*#__PURE__*/new WeakMap();
var _lastBlockNumber = /*#__PURE__*/new WeakMap();
var _nextTimer = /*#__PURE__*/new WeakMap();
var _timers = /*#__PURE__*/new WeakMap();
var _disableCcipRead = /*#__PURE__*/new WeakMap();
var _perform = /*#__PURE__*/new WeakSet();
var _call = /*#__PURE__*/new WeakSet();
var _checkNetwork = /*#__PURE__*/new WeakSet();
var _getAccountValue = /*#__PURE__*/new WeakSet();
var _getBlock5 = /*#__PURE__*/new WeakSet();
var _hasSub2 = /*#__PURE__*/new WeakSet();
var _getSub2 = /*#__PURE__*/new WeakSet();
var AbstractProvider = /*#__PURE__*/function () {
  // null=unpaused, true=paused+dropWhilePaused, false=paused

  // The most recent block number if running an event or -1 if no "block" event

  // @TODO: This should be a () => Promise<Network> so network can be
  // done when needed; or rely entirely on _detectNetwork?
  function AbstractProvider(_network) {
    var _this56 = this;
    _classCallCheck(this, AbstractProvider);
    _classPrivateMethodInitSpec(this, _getSub2);
    _classPrivateMethodInitSpec(this, _hasSub2);
    _classPrivateMethodInitSpec(this, _getBlock5);
    // Account
    _classPrivateMethodInitSpec(this, _getAccountValue);
    _classPrivateMethodInitSpec(this, _checkNetwork);
    _classPrivateMethodInitSpec(this, _call);
    // Shares multiple identical requests made during the same 250ms
    _classPrivateMethodInitSpec(this, _perform);
    _classPrivateFieldInitSpec(this, _subs, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _plugins2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _pausedState, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _networkPromise, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _anyNetwork, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _performCache, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _lastBlockNumber, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _nextTimer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _timers, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _disableCcipRead, {
      writable: true,
      value: void 0
    });
    if (_network === "any") {
      _classPrivateFieldSet(this, _anyNetwork, true);
      _classPrivateFieldSet(this, _networkPromise, null);
    } else if (_network) {
      var network = Network.from(_network);
      _classPrivateFieldSet(this, _anyNetwork, false);
      _classPrivateFieldSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(function () {
        _this56.emit("network", network, null);
      }, 0);
    } else {
      _classPrivateFieldSet(this, _anyNetwork, false);
      _classPrivateFieldSet(this, _networkPromise, null);
    }
    _classPrivateFieldSet(this, _lastBlockNumber, -1);
    _classPrivateFieldSet(this, _performCache, new Map());
    _classPrivateFieldSet(this, _subs, new Map());
    _classPrivateFieldSet(this, _plugins2, new Map());
    _classPrivateFieldSet(this, _pausedState, null);
    _classPrivateFieldSet(this, _nextTimer, 1);
    _classPrivateFieldSet(this, _timers, new Map());
    _classPrivateFieldSet(this, _disableCcipRead, false);
  }
  _createClass(AbstractProvider, [{
    key: "provider",
    get: function get() {
      return this;
    }
  }, {
    key: "plugins",
    get: function get() {
      return Array.from(_classPrivateFieldGet(this, _plugins2).values());
    }
  }, {
    key: "attachPlugin",
    value: function attachPlugin(plugin) {
      if (_classPrivateFieldGet(this, _plugins2).get(plugin.name)) {
        throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
      }
      _classPrivateFieldGet(this, _plugins2).set(plugin.name, plugin.connect(this));
      return this;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return _classPrivateFieldGet(this, _plugins2).get(name) || null;
    }
  }, {
    key: "disableCcipRead",
    get: function get() {
      return _classPrivateFieldGet(this, _disableCcipRead);
    },
    set: function set(value) {
      _classPrivateFieldSet(this, _disableCcipRead, !!value);
    }
  }, {
    key: "ccipReadFetch",
    value: function () {
      var _ccipReadFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee75(tx, calldata, urls) {
        var sender, data, errorMessages, _i52, url, href, request, errorMessage, resp, result;
        return _regeneratorRuntime().wrap(function _callee75$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              if (!(this.disableCcipRead || urls.length === 0 || tx.to == null)) {
                _context75.next = 2;
                break;
              }
              return _context75.abrupt("return", null);
            case 2:
              sender = tx.to.toLowerCase();
              data = calldata.toLowerCase();
              errorMessages = [];
              _i52 = 0;
            case 6:
              if (!(_i52 < urls.length)) {
                _context75.next = 32;
                break;
              }
              url = urls[_i52]; // URL expansion
              href = url.replace("{sender}", sender).replace("{data}", data); // If no {data} is present, use POST; otherwise GET
              //const json: string | null = (url.indexOf("{data}") >= 0) ? null: JSON.stringify({ data, sender });
              //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
              //    value.status = response.statusCode;
              //    return value;
              //});
              request = new FetchRequest(href);
              if (url.indexOf("{data}") === -1) {
                request.body = {
                  data: data,
                  sender: sender
                };
              }
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: request,
                index: _i52,
                urls: urls
              });
              errorMessage = "unknown error";
              _context75.next = 15;
              return request.send();
            case 15:
              resp = _context75.sent;
              _context75.prev = 16;
              result = resp.bodyJson;
              if (!result.data) {
                _context75.next = 21;
                break;
              }
              this.emit("debug", {
                action: "receiveCcipReadFetchResult",
                request: request,
                result: result
              });
              return _context75.abrupt("return", result.data);
            case 21:
              if (result.message) {
                errorMessage = result.message;
              }
              this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: request,
                result: result
              });
              _context75.next = 27;
              break;
            case 25:
              _context75.prev = 25;
              _context75.t0 = _context75["catch"](16);
            case 27:
              // 4xx indicates the result is not present; stop
              assert$1(resp.statusCode < 400 || resp.statusCode >= 500, "response not found during CCIP fetch: ".concat(errorMessage), "OFFCHAIN_FAULT", {
                reason: "404_MISSING_RESOURCE",
                transaction: tx,
                info: {
                  url: url,
                  errorMessage: errorMessage
                }
              });
              // 5xx indicates server issue; try the next url
              errorMessages.push(errorMessage);
            case 29:
              _i52++;
              _context75.next = 6;
              break;
            case 32:
              assert$1(false, "error encountered during CCIP fetch: ".concat(errorMessages.map(function (m) {
                return JSON.stringify(m);
              }).join(", ")), "OFFCHAIN_FAULT", {
                reason: "500_SERVER_ERROR",
                transaction: tx,
                info: {
                  urls: urls,
                  errorMessages: errorMessages
                }
              });
            case 33:
            case "end":
              return _context75.stop();
          }
        }, _callee75, this, [[16, 25]]);
      }));
      function ccipReadFetch(_x128, _x129, _x130) {
        return _ccipReadFetch.apply(this, arguments);
      }
      return ccipReadFetch;
    }()
  }, {
    key: "_wrapBlock",
    value: function _wrapBlock(value, network) {
      return new Block(formatBlock(value), this);
    }
  }, {
    key: "_wrapLog",
    value: function _wrapLog(value, network) {
      return new Log(formatLog(value), this);
    }
  }, {
    key: "_wrapTransactionReceipt",
    value: function _wrapTransactionReceipt(value, network) {
      return new TransactionReceipt(formatTransactionReceipt(value), this);
    }
  }, {
    key: "_wrapTransactionResponse",
    value: function _wrapTransactionResponse(tx, network) {
      return new TransactionResponse(tx, this);
    }
  }, {
    key: "_detectNetwork",
    value: function _detectNetwork() {
      assert$1(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
        operation: "_detectNetwork"
      });
    }
    // Sub-classes should override this and handle PerformActionRequest requests, calling
    // the super for any unhandled actions.
  }, {
    key: "_perform",
    value: function () {
      var _perform3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee76(req) {
        return _regeneratorRuntime().wrap(function _callee76$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              assert$1(false, "unsupported method: ".concat(req.method), "UNSUPPORTED_OPERATION", {
                operation: req.method,
                info: req
              });
            case 1:
            case "end":
              return _context76.stop();
          }
        }, _callee76);
      }));
      function _perform(_x131) {
        return _perform3.apply(this, arguments);
      }
      return _perform;
    }() // State
  }, {
    key: "getBlockNumber",
    value: function () {
      var _getBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee77() {
        var blockNumber;
        return _regeneratorRuntime().wrap(function _callee77$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              _context77.t0 = getNumber;
              _context77.next = 3;
              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                method: "getBlockNumber"
              });
            case 3:
              _context77.t1 = _context77.sent;
              blockNumber = (0, _context77.t0)(_context77.t1, "%response");
              if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {
                _classPrivateFieldSet(this, _lastBlockNumber, blockNumber);
              }
              return _context77.abrupt("return", blockNumber);
            case 7:
            case "end":
              return _context77.stop();
          }
        }, _callee77, this);
      }));
      function getBlockNumber() {
        return _getBlockNumber.apply(this, arguments);
      }
      return getBlockNumber;
    }()
  }, {
    key: "_getAddress",
    value: function _getAddress(address) {
      return resolveAddress(address, this);
    }
  }, {
    key: "_getBlockTag",
    value: function _getBlockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      switch (blockTag) {
        case "earliest":
          return "0x0";
        case "latest":
        case "pending":
        case "safe":
        case "finalized":
          return blockTag;
      }
      if (isHexString(blockTag)) {
        if (isHexString(blockTag, 32)) {
          return blockTag;
        }
        return toQuantity(blockTag);
      }
      if (typeof blockTag === "number") {
        if (blockTag >= 0) {
          return toQuantity(blockTag);
        }
        if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {
          return toQuantity(_classPrivateFieldGet(this, _lastBlockNumber) + blockTag);
        }
        return this.getBlockNumber().then(function (b) {
          return toQuantity(b + blockTag);
        });
      }
      assertArgument(false, "invalid blockTag", "blockTag", blockTag);
    }
  }, {
    key: "_getFilter",
    value: function _getFilter(filter) {
      // Create a canonical representation of the topics
      var topics = (filter.topics || []).map(function (t) {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map(function (t) {
            return t.toLowerCase();
          }));
        }
        return t.toLowerCase();
      });
      var blockHash = "blockHash" in filter ? filter.blockHash : undefined;
      var resolve = function resolve(_address, fromBlock, toBlock) {
        var address = undefined;
        switch (_address.length) {
          case 0:
            break;
          case 1:
            address = _address[0];
            break;
          default:
            _address.sort();
            address = _address;
        }
        if (blockHash) {
          if (fromBlock != null || toBlock != null) {
            throw new Error("invalid filter");
          }
        }
        var filter = {};
        if (address) {
          filter.address = address;
        }
        if (topics.length) {
          filter.topics = topics;
        }
        if (fromBlock) {
          filter.fromBlock = fromBlock;
        }
        if (toBlock) {
          filter.toBlock = toBlock;
        }
        if (blockHash) {
          filter.blockHash = blockHash;
        }
        return filter;
      };
      // Addresses could be async (ENS names or Addressables)
      var address = [];
      if (filter.address) {
        if (Array.isArray(filter.address)) {
          var _iterator31 = _createForOfIteratorHelper(filter.address),
            _step31;
          try {
            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
              var addr = _step31.value;
              address.push(this._getAddress(addr));
            }
          } catch (err) {
            _iterator31.e(err);
          } finally {
            _iterator31.f();
          }
        } else {
          address.push(this._getAddress(filter.address));
        }
      }
      var fromBlock = undefined;
      if ("fromBlock" in filter) {
        fromBlock = this._getBlockTag(filter.fromBlock);
      }
      var toBlock = undefined;
      if ("toBlock" in filter) {
        toBlock = this._getBlockTag(filter.toBlock);
      }
      if (address.filter(function (a) {
        return typeof a !== "string";
      }).length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
        return Promise.all([Promise.all(address), fromBlock, toBlock]).then(function (result) {
          return resolve(result[0], result[1], result[2]);
        });
      }
      return resolve(address, fromBlock, toBlock);
    }
  }, {
    key: "_getTransactionRequest",
    value: function _getTransactionRequest(_request) {
      var request = copyRequest(_request);
      var promises = [];
      ["to", "from"].forEach(function (key) {
        if (request[key] == null) {
          return;
        }
        var addr = resolveAddress(request[key]);
        if (isPromise$1(addr)) {
          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee78() {
            return _regeneratorRuntime().wrap(function _callee78$(_context78) {
              while (1) switch (_context78.prev = _context78.next) {
                case 0:
                  _context78.next = 2;
                  return addr;
                case 2:
                  request[key] = _context78.sent;
                case 3:
                case "end":
                  return _context78.stop();
              }
            }, _callee78);
          }))());
        } else {
          request[key] = addr;
        }
      });
      if (request.blockTag != null) {
        var blockTag = this._getBlockTag(request.blockTag);
        if (isPromise$1(blockTag)) {
          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee79() {
            return _regeneratorRuntime().wrap(function _callee79$(_context79) {
              while (1) switch (_context79.prev = _context79.next) {
                case 0:
                  _context79.next = 2;
                  return blockTag;
                case 2:
                  request.blockTag = _context79.sent;
                case 3:
                case "end":
                  return _context79.stop();
              }
            }, _callee79);
          }))());
        } else {
          request.blockTag = blockTag;
        }
      }
      if (promises.length) {
        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee80() {
          return _regeneratorRuntime().wrap(function _callee80$(_context80) {
            while (1) switch (_context80.prev = _context80.next) {
              case 0:
                _context80.next = 2;
                return Promise.all(promises);
              case 2:
                return _context80.abrupt("return", request);
              case 3:
              case "end":
                return _context80.stop();
            }
          }, _callee80);
        }))();
      }
      return request;
    }
  }, {
    key: "getNetwork",
    value: function () {
      var _getNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee81() {
        var _this57 = this;
        var detectNetwork, networkPromise, _yield$Promise$all, _yield$Promise$all2, expected, actual;
        return _regeneratorRuntime().wrap(function _callee81$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              if (!(_classPrivateFieldGet(this, _networkPromise) == null)) {
                _context81.next = 6;
                break;
              }
              // Detect the current network (shared with all calls)
              detectNetwork = this._detectNetwork().then(function (network) {
                _this57.emit("network", network, null);
                return network;
              }, function (error) {
                // Reset the networkPromise on failure, so we will try again
                if (_classPrivateFieldGet(_this57, _networkPromise) === detectNetwork) {
                  _classPrivateFieldSet(_this57, _networkPromise, null);
                }
                throw error;
              });
              _classPrivateFieldSet(this, _networkPromise, detectNetwork);
              _context81.next = 5;
              return detectNetwork;
            case 5:
              return _context81.abrupt("return", _context81.sent.clone());
            case 6:
              networkPromise = _classPrivateFieldGet(this, _networkPromise);
              _context81.next = 9;
              return Promise.all([networkPromise, this._detectNetwork() // The actual connected network
              ]);
            case 9:
              _yield$Promise$all = _context81.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              expected = _yield$Promise$all2[0];
              actual = _yield$Promise$all2[1];
              if (expected.chainId !== actual.chainId) {
                if (_classPrivateFieldGet(this, _anyNetwork)) {
                  // The "any" network can change, so notify listeners
                  this.emit("network", actual, expected);
                  // Update the network if something else hasn't already changed it
                  if (_classPrivateFieldGet(this, _networkPromise) === networkPromise) {
                    _classPrivateFieldSet(this, _networkPromise, Promise.resolve(actual));
                  }
                } else {
                  // Otherwise, we do not allow changes to the underlying network
                  assert$1(false, "network changed: ".concat(expected.chainId, " => ").concat(actual.chainId, " "), "NETWORK_ERROR", {
                    event: "changed"
                  });
                }
              }
              return _context81.abrupt("return", expected.clone());
            case 15:
            case "end":
              return _context81.stop();
          }
        }, _callee81, this);
      }));
      function getNetwork() {
        return _getNetwork.apply(this, arguments);
      }
      return getNetwork;
    }()
  }, {
    key: "getFeeData",
    value: function () {
      var _getFeeData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee83() {
        var _this58 = this;
        var _yield$resolvePropert2, block, gasPrice, maxFeePerGas, maxPriorityFeePerGas;
        return _regeneratorRuntime().wrap(function _callee83$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return resolveProperties({
                block: this.getBlock("latest"),
                gasPrice: _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee82() {
                  var _gasPrice2;
                  return _regeneratorRuntime().wrap(function _callee82$(_context82) {
                    while (1) switch (_context82.prev = _context82.next) {
                      case 0:
                        _context82.prev = 0;
                        _context82.next = 3;
                        return _classPrivateMethodGet(_this58, _perform, _perform2).call(_this58, {
                          method: "getGasPrice"
                        });
                      case 3:
                        _gasPrice2 = _context82.sent;
                        return _context82.abrupt("return", getBigInt(_gasPrice2, "%response"));
                      case 7:
                        _context82.prev = 7;
                        _context82.t0 = _context82["catch"](0);
                      case 9:
                        return _context82.abrupt("return", null);
                      case 10:
                      case "end":
                        return _context82.stop();
                    }
                  }, _callee82, null, [[0, 7]]);
                }))()
              });
            case 2:
              _yield$resolvePropert2 = _context83.sent;
              block = _yield$resolvePropert2.block;
              gasPrice = _yield$resolvePropert2.gasPrice;
              maxFeePerGas = null, maxPriorityFeePerGas = null;
              if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                maxPriorityFeePerGas = BigInt("1000000000");
                // Allow a network to override their maximum priority fee per gas
                //const priorityFeePlugin = (await this.getNetwork()).getPlugin<MaxPriorityFeePlugin>("org.ethers.plugins.max-priority-fee");
                //if (priorityFeePlugin) {
                //    maxPriorityFeePerGas = await priorityFeePlugin.getPriorityFee(this);
                //}
                maxFeePerGas = block.baseFeePerGas * BN_2$1 + maxPriorityFeePerGas;
              }
              return _context83.abrupt("return", new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas));
            case 8:
            case "end":
              return _context83.stop();
          }
        }, _callee83, this);
      }));
      function getFeeData() {
        return _getFeeData2.apply(this, arguments);
      }
      return getFeeData;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee84(_tx) {
        var tx;
        return _regeneratorRuntime().wrap(function _callee84$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              tx = this._getTransactionRequest(_tx);
              if (!isPromise$1(tx)) {
                _context84.next = 5;
                break;
              }
              _context84.next = 4;
              return tx;
            case 4:
              tx = _context84.sent;
            case 5:
              _context84.t0 = getBigInt;
              _context84.next = 8;
              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                method: "estimateGas",
                transaction: tx
              });
            case 8:
              _context84.t1 = _context84.sent;
              return _context84.abrupt("return", (0, _context84.t0)(_context84.t1, "%response"));
            case 10:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this);
      }));
      function estimateGas(_x132) {
        return _estimateGas3.apply(this, arguments);
      }
      return estimateGas;
    }()
  }, {
    key: "call",
    value: function () {
      var _call3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee85(_tx) {
        var _yield$resolvePropert3, tx, blockTag;
        return _regeneratorRuntime().wrap(function _callee85$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              _context85.next = 2;
              return resolveProperties({
                tx: this._getTransactionRequest(_tx),
                blockTag: this._getBlockTag(_tx.blockTag)
              });
            case 2:
              _yield$resolvePropert3 = _context85.sent;
              tx = _yield$resolvePropert3.tx;
              blockTag = _yield$resolvePropert3.blockTag;
              _context85.next = 7;
              return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _call, _call2).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
            case 7:
              return _context85.abrupt("return", _context85.sent);
            case 8:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this);
      }));
      function call(_x133) {
        return _call3.apply(this, arguments);
      }
      return call;
    }()
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee86(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee86$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _context86.t0 = getBigInt;
              _context86.next = 3;
              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {
                method: "getBalance"
              }, address, blockTag);
            case 3:
              _context86.t1 = _context86.sent;
              return _context86.abrupt("return", (0, _context86.t0)(_context86.t1, "%response"));
            case 5:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
      function getBalance(_x134, _x135) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
  }, {
    key: "getTransactionCount",
    value: function () {
      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee87(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee87$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              _context87.t0 = getNumber;
              _context87.next = 3;
              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {
                method: "getTransactionCount"
              }, address, blockTag);
            case 3:
              _context87.t1 = _context87.sent;
              return _context87.abrupt("return", (0, _context87.t0)(_context87.t1, "%response"));
            case 5:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
      function getTransactionCount(_x136, _x137) {
        return _getTransactionCount.apply(this, arguments);
      }
      return getTransactionCount;
    }()
  }, {
    key: "getCode",
    value: function () {
      var _getCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee88(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee88$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              _context88.t0 = hexlify;
              _context88.next = 3;
              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {
                method: "getCode"
              }, address, blockTag);
            case 3:
              _context88.t1 = _context88.sent;
              return _context88.abrupt("return", (0, _context88.t0)(_context88.t1));
            case 5:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
      function getCode(_x138, _x139) {
        return _getCode.apply(this, arguments);
      }
      return getCode;
    }()
  }, {
    key: "getStorage",
    value: function () {
      var _getStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee89(address, _position, blockTag) {
        var position;
        return _regeneratorRuntime().wrap(function _callee89$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              position = getBigInt(_position, "position");
              _context89.t0 = hexlify;
              _context89.next = 4;
              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {
                method: "getStorage",
                position: position
              }, address, blockTag);
            case 4:
              _context89.t1 = _context89.sent;
              return _context89.abrupt("return", (0, _context89.t0)(_context89.t1));
            case 6:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
      function getStorage(_x140, _x141, _x142) {
        return _getStorage.apply(this, arguments);
      }
      return getStorage;
    }() // Write
  }, {
    key: "broadcastTransaction",
    value: function () {
      var _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee90(signedTx) {
        var _yield$resolvePropert4, blockNumber, hash, network, tx;
        return _regeneratorRuntime().wrap(function _callee90$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              _context90.next = 2;
              return resolveProperties({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: signedTx
                }),
                network: this.getNetwork()
              });
            case 2:
              _yield$resolvePropert4 = _context90.sent;
              blockNumber = _yield$resolvePropert4.blockNumber;
              hash = _yield$resolvePropert4.hash;
              network = _yield$resolvePropert4.network;
              tx = Transaction.from(signedTx);
              if (!(tx.hash !== hash)) {
                _context90.next = 9;
                break;
              }
              throw new Error("@TODO: the returned hash did not match");
            case 9:
              return _context90.abrupt("return", this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber));
            case 10:
            case "end":
              return _context90.stop();
          }
        }, _callee90, this);
      }));
      function broadcastTransaction(_x143) {
        return _broadcastTransaction.apply(this, arguments);
      }
      return broadcastTransaction;
    }()
  }, {
    key: "getBlock",
    value: // Queries
    function () {
      var _getBlock7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee91(block, prefetchTxs) {
        var _yield$resolvePropert5, network, params;
        return _regeneratorRuntime().wrap(function _callee91$(_context91) {
          while (1) switch (_context91.prev = _context91.next) {
            case 0:
              _context91.next = 2;
              return resolveProperties({
                network: this.getNetwork(),
                params: _classPrivateMethodGet(this, _getBlock5, _getBlock6).call(this, block, !!prefetchTxs)
              });
            case 2:
              _yield$resolvePropert5 = _context91.sent;
              network = _yield$resolvePropert5.network;
              params = _yield$resolvePropert5.params;
              if (!(params == null)) {
                _context91.next = 7;
                break;
              }
              return _context91.abrupt("return", null);
            case 7:
              return _context91.abrupt("return", this._wrapBlock(formatBlock(params), network));
            case 8:
            case "end":
              return _context91.stop();
          }
        }, _callee91, this);
      }));
      function getBlock(_x144, _x145) {
        return _getBlock7.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee92(hash) {
        var _yield$resolvePropert6, network, params;
        return _regeneratorRuntime().wrap(function _callee92$(_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              _context92.next = 2;
              return resolveProperties({
                network: this.getNetwork(),
                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                  method: "getTransaction",
                  hash: hash
                })
              });
            case 2:
              _yield$resolvePropert6 = _context92.sent;
              network = _yield$resolvePropert6.network;
              params = _yield$resolvePropert6.params;
              if (!(params == null)) {
                _context92.next = 7;
                break;
              }
              return _context92.abrupt("return", null);
            case 7:
              return _context92.abrupt("return", this._wrapTransactionResponse(formatTransactionResponse(params), network));
            case 8:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this);
      }));
      function getTransaction(_x146) {
        return _getTransaction6.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getTransactionReceipt",
    value: function () {
      var _getTransactionReceipt3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee93(hash) {
        var _yield$resolvePropert7, network, params, tx;
        return _regeneratorRuntime().wrap(function _callee93$(_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              _context93.next = 2;
              return resolveProperties({
                network: this.getNetwork(),
                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                  method: "getTransactionReceipt",
                  hash: hash
                })
              });
            case 2:
              _yield$resolvePropert7 = _context93.sent;
              network = _yield$resolvePropert7.network;
              params = _yield$resolvePropert7.params;
              if (!(params == null)) {
                _context93.next = 7;
                break;
              }
              return _context93.abrupt("return", null);
            case 7:
              if (!(params.gasPrice == null && params.effectiveGasPrice == null)) {
                _context93.next = 14;
                break;
              }
              _context93.next = 10;
              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                method: "getTransaction",
                hash: hash
              });
            case 10:
              tx = _context93.sent;
              if (!(tx == null)) {
                _context93.next = 13;
                break;
              }
              throw new Error("report this; could not find tx or effectiveGasPrice");
            case 13:
              params.effectiveGasPrice = tx.gasPrice;
            case 14:
              return _context93.abrupt("return", this._wrapTransactionReceipt(formatTransactionReceipt(params), network));
            case 15:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this);
      }));
      function getTransactionReceipt(_x147) {
        return _getTransactionReceipt3.apply(this, arguments);
      }
      return getTransactionReceipt;
    }()
  }, {
    key: "getTransactionResult",
    value: function () {
      var _getTransactionResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee94(hash) {
        var _yield$resolvePropert8, result;
        return _regeneratorRuntime().wrap(function _callee94$(_context94) {
          while (1) switch (_context94.prev = _context94.next) {
            case 0:
              _context94.next = 2;
              return resolveProperties({
                network: this.getNetwork(),
                result: _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                  method: "getTransactionResult",
                  hash: hash
                })
              });
            case 2:
              _yield$resolvePropert8 = _context94.sent;
              result = _yield$resolvePropert8.result;
              if (!(result == null)) {
                _context94.next = 6;
                break;
              }
              return _context94.abrupt("return", null);
            case 6:
              return _context94.abrupt("return", hexlify(result));
            case 7:
            case "end":
              return _context94.stop();
          }
        }, _callee94, this);
      }));
      function getTransactionResult(_x148) {
        return _getTransactionResult.apply(this, arguments);
      }
      return getTransactionResult;
    }() // Bloom-filter Queries
  }, {
    key: "getLogs",
    value: function () {
      var _getLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee95(_filter) {
        var _this59 = this;
        var filter, _yield$resolvePropert9, network, params;
        return _regeneratorRuntime().wrap(function _callee95$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              filter = this._getFilter(_filter);
              if (!isPromise$1(filter)) {
                _context95.next = 5;
                break;
              }
              _context95.next = 4;
              return filter;
            case 4:
              filter = _context95.sent;
            case 5:
              _context95.next = 7;
              return resolveProperties({
                network: this.getNetwork(),
                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {
                  method: "getLogs",
                  filter: filter
                })
              });
            case 7:
              _yield$resolvePropert9 = _context95.sent;
              network = _yield$resolvePropert9.network;
              params = _yield$resolvePropert9.params;
              return _context95.abrupt("return", params.map(function (p) {
                return _this59._wrapLog(formatLog(p), network);
              }));
            case 11:
            case "end":
              return _context95.stop();
          }
        }, _callee95, this);
      }));
      function getLogs(_x149) {
        return _getLogs.apply(this, arguments);
      }
      return getLogs;
    }() // ENS
  }, {
    key: "_getProvider",
    value: function _getProvider(chainId) {
      assert$1(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
        operation: "_getProvider()"
      });
    }
  }, {
    key: "getResolver",
    value: function () {
      var _getResolver3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee96(name) {
        return _regeneratorRuntime().wrap(function _callee96$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              _context96.next = 2;
              return EnsResolver.fromName(this, name);
            case 2:
              return _context96.abrupt("return", _context96.sent);
            case 3:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this);
      }));
      function getResolver(_x150) {
        return _getResolver3.apply(this, arguments);
      }
      return getResolver;
    }()
  }, {
    key: "getAvatar",
    value: function () {
      var _getAvatar4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee97(name) {
        var resolver;
        return _regeneratorRuntime().wrap(function _callee97$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.next = 2;
              return this.getResolver(name);
            case 2:
              resolver = _context97.sent;
              if (!resolver) {
                _context97.next = 7;
                break;
              }
              _context97.next = 6;
              return resolver.getAvatar();
            case 6:
              return _context97.abrupt("return", _context97.sent);
            case 7:
              return _context97.abrupt("return", null);
            case 8:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this);
      }));
      function getAvatar(_x151) {
        return _getAvatar4.apply(this, arguments);
      }
      return getAvatar;
    }()
  }, {
    key: "resolveName",
    value: function () {
      var _resolveName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee98(name) {
        var resolver;
        return _regeneratorRuntime().wrap(function _callee98$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this.getResolver(name);
            case 2:
              resolver = _context98.sent;
              if (!resolver) {
                _context98.next = 7;
                break;
              }
              _context98.next = 6;
              return resolver.getAddress();
            case 6:
              return _context98.abrupt("return", _context98.sent);
            case 7:
              return _context98.abrupt("return", null);
            case 8:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this);
      }));
      function resolveName(_x152) {
        return _resolveName.apply(this, arguments);
      }
      return resolveName;
    }()
  }, {
    key: "lookupAddress",
    value: function () {
      var _lookupAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee99(address) {
        var node, ensAddr, ensContract, resolver, resolverContract, name, check;
        return _regeneratorRuntime().wrap(function _callee99$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              address = getAddress(address);
              node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
              _context99.prev = 2;
              _context99.next = 5;
              return EnsResolver.getEnsAddress(this);
            case 5:
              ensAddr = _context99.sent;
              ensContract = new Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], this);
              _context99.next = 9;
              return ensContract.resolver(node);
            case 9:
              resolver = _context99.sent;
              if (!(resolver == null || resolver === ZeroHash)) {
                _context99.next = 12;
                break;
              }
              return _context99.abrupt("return", null);
            case 12:
              resolverContract = new Contract(resolver, ["function name(bytes32) view returns (string)"], this);
              _context99.next = 15;
              return resolverContract.name(node);
            case 15:
              name = _context99.sent;
              _context99.next = 18;
              return this.resolveName(name);
            case 18:
              check = _context99.sent;
              if (!(check !== address)) {
                _context99.next = 21;
                break;
              }
              return _context99.abrupt("return", null);
            case 21:
              return _context99.abrupt("return", name);
            case 24:
              _context99.prev = 24;
              _context99.t0 = _context99["catch"](2);
              if (!(isError(_context99.t0, "BAD_DATA") && _context99.t0.value === "0x")) {
                _context99.next = 28;
                break;
              }
              return _context99.abrupt("return", null);
            case 28:
              if (!isError(_context99.t0, "CALL_EXCEPTION")) {
                _context99.next = 30;
                break;
              }
              return _context99.abrupt("return", null);
            case 30:
              throw _context99.t0;
            case 31:
              return _context99.abrupt("return", null);
            case 32:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this, [[2, 24]]);
      }));
      function lookupAddress(_x153) {
        return _lookupAddress.apply(this, arguments);
      }
      return lookupAddress;
    }()
  }, {
    key: "waitForTransaction",
    value: function () {
      var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee102(hash, _confirms, timeout) {
        var _this60 = this;
        var confirms;
        return _regeneratorRuntime().wrap(function _callee102$(_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              confirms = _confirms != null ? _confirms : 1;
              if (!(confirms === 0)) {
                _context102.next = 3;
                break;
              }
              return _context102.abrupt("return", this.getTransactionReceipt(hash));
            case 3:
              return _context102.abrupt("return", new Promise( /*#__PURE__*/function () {
                var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee101(resolve, reject) {
                  var timer, listener;
                  return _regeneratorRuntime().wrap(function _callee101$(_context101) {
                    while (1) switch (_context101.prev = _context101.next) {
                      case 0:
                        timer = null;
                        listener = /*#__PURE__*/function () {
                          var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee100(blockNumber) {
                            var receipt;
                            return _regeneratorRuntime().wrap(function _callee100$(_context100) {
                              while (1) switch (_context100.prev = _context100.next) {
                                case 0:
                                  _context100.prev = 0;
                                  _context100.next = 3;
                                  return _this60.getTransactionReceipt(hash);
                                case 3:
                                  receipt = _context100.sent;
                                  if (!(receipt != null)) {
                                    _context100.next = 9;
                                    break;
                                  }
                                  if (!(blockNumber - receipt.blockNumber + 1 >= confirms)) {
                                    _context100.next = 9;
                                    break;
                                  }
                                  resolve(receipt);
                                  //this.off("block", listener);
                                  if (timer) {
                                    clearTimeout(timer);
                                    timer = null;
                                  }
                                  return _context100.abrupt("return");
                                case 9:
                                  _context100.next = 14;
                                  break;
                                case 11:
                                  _context100.prev = 11;
                                  _context100.t0 = _context100["catch"](0);
                                  console.log("EEE", _context100.t0);
                                case 14:
                                  _this60.once("block", listener);
                                case 15:
                                case "end":
                                  return _context100.stop();
                              }
                            }, _callee100, null, [[0, 11]]);
                          }));
                          return function listener(_x159) {
                            return _ref24.apply(this, arguments);
                          };
                        }();
                        if (timeout != null) {
                          timer = setTimeout(function () {
                            if (timer == null) {
                              return;
                            }
                            timer = null;
                            _this60.off("block", listener);
                            reject(makeError("timeout", "TIMEOUT", {
                              reason: "timeout"
                            }));
                          }, timeout);
                        }
                        _context101.t0 = listener;
                        _context101.next = 6;
                        return _this60.getBlockNumber();
                      case 6:
                        _context101.t1 = _context101.sent;
                        (0, _context101.t0)(_context101.t1);
                      case 8:
                      case "end":
                        return _context101.stop();
                    }
                  }, _callee101);
                }));
                return function (_x157, _x158) {
                  return _ref23.apply(this, arguments);
                };
              }()));
            case 4:
            case "end":
              return _context102.stop();
          }
        }, _callee102, this);
      }));
      function waitForTransaction(_x154, _x155, _x156) {
        return _waitForTransaction.apply(this, arguments);
      }
      return waitForTransaction;
    }()
  }, {
    key: "waitForBlock",
    value: function () {
      var _waitForBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee103(blockTag) {
        return _regeneratorRuntime().wrap(function _callee103$(_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              assert$1(false, "not implemented yet", "NOT_IMPLEMENTED", {
                operation: "waitForBlock"
              });
            case 1:
            case "end":
              return _context103.stop();
          }
        }, _callee103);
      }));
      function waitForBlock(_x160) {
        return _waitForBlock.apply(this, arguments);
      }
      return waitForBlock;
    }()
  }, {
    key: "_clearTimeout",
    value: function _clearTimeout(timerId) {
      var timer = _classPrivateFieldGet(this, _timers).get(timerId);
      if (!timer) {
        return;
      }
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      _classPrivateFieldGet(this, _timers)["delete"](timerId);
    }
  }, {
    key: "_setTimeout",
    value: function _setTimeout(_func, timeout) {
      var _this$nextTimer,
        _this$nextTimer2,
        _this61 = this;
      if (timeout == null) {
        timeout = 0;
      }
      var timerId = (_classPrivateFieldSet(this, _nextTimer, (_this$nextTimer = _classPrivateFieldGet(this, _nextTimer), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);
      var func = function func() {
        _classPrivateFieldGet(_this61, _timers)["delete"](timerId);
        _func();
      };
      if (this.paused) {
        _classPrivateFieldGet(this, _timers).set(timerId, {
          timer: null,
          func: func,
          time: timeout
        });
      } else {
        var timer = setTimeout(func, timeout);
        _classPrivateFieldGet(this, _timers).set(timerId, {
          timer: timer,
          func: func,
          time: getTime$1()
        });
      }
      return timerId;
    }
  }, {
    key: "_forEachSubscriber",
    value: function _forEachSubscriber(func) {
      var _iterator32 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),
        _step32;
      try {
        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
          var sub = _step32.value;
          func(sub.subscriber);
        }
      } catch (err) {
        _iterator32.e(err);
      } finally {
        _iterator32.f();
      }
    }
    // Event API; sub-classes should override this; any supported
    // event filter will have been munged into an EventFilter
  }, {
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      switch (sub.type) {
        case "debug":
        case "network":
          return new UnmanagedSubscriber(sub.type);
        case "block":
          return new PollingBlockSubscriber(this);
        case "event":
          return new PollingEventSubscriber(this, sub.filter);
        case "transaction":
          return new PollingTransactionSubscriber(this, sub.hash);
        case "orphan":
          return new PollingOrphanSubscriber(this, sub.filter);
      }
      throw new Error("unsupported event: ".concat(sub.type));
    }
  }, {
    key: "_recoverSubscriber",
    value: function _recoverSubscriber(oldSub, newSub) {
      var _iterator33 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),
        _step33;
      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
          var sub = _step33.value;
          if (sub.subscriber === oldSub) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            sub.subscriber = newSub;
            if (sub.started) {
              newSub.start();
            }
            if (_classPrivateFieldGet(this, _pausedState) != null) {
              newSub.pause(_classPrivateFieldGet(this, _pausedState));
            }
            break;
          }
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }
    }
  }, {
    key: "on",
    value: function () {
      var _on2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee104(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee104$(_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              _context104.next = 2;
              return _classPrivateMethodGet(this, _getSub2, _getSub3).call(this, event);
            case 2:
              sub = _context104.sent;
              sub.listeners.push({
                listener: listener,
                once: false
              });
              if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (_classPrivateFieldGet(this, _pausedState) != null) {
                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));
                }
              }
              return _context104.abrupt("return", this);
            case 6:
            case "end":
              return _context104.stop();
          }
        }, _callee104, this);
      }));
      function on(_x161, _x162) {
        return _on2.apply(this, arguments);
      }
      return on;
    }()
  }, {
    key: "once",
    value: function () {
      var _once2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee105(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee105$(_context105) {
          while (1) switch (_context105.prev = _context105.next) {
            case 0:
              _context105.next = 2;
              return _classPrivateMethodGet(this, _getSub2, _getSub3).call(this, event);
            case 2:
              sub = _context105.sent;
              sub.listeners.push({
                listener: listener,
                once: true
              });
              if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (_classPrivateFieldGet(this, _pausedState) != null) {
                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));
                }
              }
              return _context105.abrupt("return", this);
            case 6:
            case "end":
              return _context105.stop();
          }
        }, _callee105, this);
      }));
      function once(_x163, _x164) {
        return _once2.apply(this, arguments);
      }
      return once;
    }()
  }, {
    key: "emit",
    value: function () {
      var _emit6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee106(event) {
        var _this62 = this;
        var _len18,
          args,
          _key20,
          sub,
          count,
          _args103 = arguments;
        return _regeneratorRuntime().wrap(function _callee106$(_context106) {
          while (1) switch (_context106.prev = _context106.next) {
            case 0:
              for (_len18 = _args103.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key20 = 1; _key20 < _len18; _key20++) {
                args[_key20 - 1] = _args103[_key20];
              }
              _context106.next = 3;
              return _classPrivateMethodGet(this, _hasSub2, _hasSub3).call(this, event, args);
            case 3:
              sub = _context106.sent;
              if (!(!sub || sub.listeners.length === 0)) {
                _context106.next = 6;
                break;
              }
              return _context106.abrupt("return", false);
            case 6:
              ;
              count = sub.listeners.length;
              sub.listeners = sub.listeners.filter(function (_ref25) {
                var listener = _ref25.listener,
                  once = _ref25.once;
                var payload = new EventPayload(_this62, once ? null : listener, event);
                try {
                  listener.call.apply(listener, [_this62].concat(args, [payload]));
                } catch (error) {}
                return !once;
              });
              if (sub.listeners.length === 0) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                _classPrivateFieldGet(this, _subs)["delete"](sub.tag);
              }
              return _context106.abrupt("return", count > 0);
            case 11:
            case "end":
              return _context106.stop();
          }
        }, _callee106, this);
      }));
      function emit(_x165) {
        return _emit6.apply(this, arguments);
      }
      return emit;
    }()
  }, {
    key: "listenerCount",
    value: function () {
      var _listenerCount2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee107(event) {
        var sub, total, _iterator34, _step34, listeners;
        return _regeneratorRuntime().wrap(function _callee107$(_context107) {
          while (1) switch (_context107.prev = _context107.next) {
            case 0:
              if (!event) {
                _context107.next = 7;
                break;
              }
              _context107.next = 3;
              return _classPrivateMethodGet(this, _hasSub2, _hasSub3).call(this, event);
            case 3:
              sub = _context107.sent;
              if (sub) {
                _context107.next = 6;
                break;
              }
              return _context107.abrupt("return", 0);
            case 6:
              return _context107.abrupt("return", sub.listeners.length);
            case 7:
              total = 0;
              _iterator34 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());
              try {
                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                  listeners = _step34.value.listeners;
                  total += listeners.length;
                }
              } catch (err) {
                _iterator34.e(err);
              } finally {
                _iterator34.f();
              }
              return _context107.abrupt("return", total);
            case 11:
            case "end":
              return _context107.stop();
          }
        }, _callee107, this);
      }));
      function listenerCount(_x166) {
        return _listenerCount2.apply(this, arguments);
      }
      return listenerCount;
    }()
  }, {
    key: "listeners",
    value: function () {
      var _listeners4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee108(event) {
        var sub, result, _iterator35, _step35, _listeners5;
        return _regeneratorRuntime().wrap(function _callee108$(_context108) {
          while (1) switch (_context108.prev = _context108.next) {
            case 0:
              if (!event) {
                _context108.next = 7;
                break;
              }
              _context108.next = 3;
              return _classPrivateMethodGet(this, _hasSub2, _hasSub3).call(this, event);
            case 3:
              sub = _context108.sent;
              if (sub) {
                _context108.next = 6;
                break;
              }
              return _context108.abrupt("return", []);
            case 6:
              return _context108.abrupt("return", sub.listeners.map(function (_ref26) {
                var listener = _ref26.listener;
                return listener;
              }));
            case 7:
              result = [];
              _iterator35 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());
              try {
                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                  _listeners5 = _step35.value.listeners;
                  result = result.concat(_listeners5.map(function (_ref27) {
                    var listener = _ref27.listener;
                    return listener;
                  }));
                }
              } catch (err) {
                _iterator35.e(err);
              } finally {
                _iterator35.f();
              }
              return _context108.abrupt("return", result);
            case 11:
            case "end":
              return _context108.stop();
          }
        }, _callee108, this);
      }));
      function listeners(_x167) {
        return _listeners4.apply(this, arguments);
      }
      return listeners;
    }()
  }, {
    key: "off",
    value: function () {
      var _off2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee109(event, listener) {
        var sub, index;
        return _regeneratorRuntime().wrap(function _callee109$(_context109) {
          while (1) switch (_context109.prev = _context109.next) {
            case 0:
              _context109.next = 2;
              return _classPrivateMethodGet(this, _hasSub2, _hasSub3).call(this, event);
            case 2:
              sub = _context109.sent;
              if (sub) {
                _context109.next = 5;
                break;
              }
              return _context109.abrupt("return", this);
            case 5:
              if (listener) {
                index = sub.listeners.map(function (_ref28) {
                  var listener = _ref28.listener;
                  return listener;
                }).indexOf(listener);
                if (index >= 0) {
                  sub.listeners.splice(index, 1);
                }
              }
              if (!listener || sub.listeners.length === 0) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                _classPrivateFieldGet(this, _subs)["delete"](sub.tag);
              }
              return _context109.abrupt("return", this);
            case 8:
            case "end":
              return _context109.stop();
          }
        }, _callee109, this);
      }));
      function off(_x168, _x169) {
        return _off2.apply(this, arguments);
      }
      return off;
    }()
  }, {
    key: "removeAllListeners",
    value: function () {
      var _removeAllListeners2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee110(event) {
        var _yield$_classPrivateM, tag, started, subscriber, _iterator36, _step36, _step36$value, _tag, _step36$value$, _started, _subscriber;
        return _regeneratorRuntime().wrap(function _callee110$(_context110) {
          while (1) switch (_context110.prev = _context110.next) {
            case 0:
              if (!event) {
                _context110.next = 11;
                break;
              }
              _context110.next = 3;
              return _classPrivateMethodGet(this, _getSub2, _getSub3).call(this, event);
            case 3:
              _yield$_classPrivateM = _context110.sent;
              tag = _yield$_classPrivateM.tag;
              started = _yield$_classPrivateM.started;
              subscriber = _yield$_classPrivateM.subscriber;
              if (started) {
                subscriber.stop();
              }
              _classPrivateFieldGet(this, _subs)["delete"](tag);
              _context110.next = 13;
              break;
            case 11:
              _iterator36 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs));
              try {
                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                  _step36$value = _slicedToArray(_step36.value, 2), _tag = _step36$value[0], _step36$value$ = _step36$value[1], _started = _step36$value$.started, _subscriber = _step36$value$.subscriber;
                  if (_started) {
                    _subscriber.stop();
                  }
                  _classPrivateFieldGet(this, _subs)["delete"](_tag);
                }
              } catch (err) {
                _iterator36.e(err);
              } finally {
                _iterator36.f();
              }
            case 13:
              return _context110.abrupt("return", this);
            case 14:
            case "end":
              return _context110.stop();
          }
        }, _callee110, this);
      }));
      function removeAllListeners(_x170) {
        return _removeAllListeners2.apply(this, arguments);
      }
      return removeAllListeners;
    }() // Alias for "on"
  }, {
    key: "addListener",
    value: function () {
      var _addListener2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee111(event, listener) {
        return _regeneratorRuntime().wrap(function _callee111$(_context111) {
          while (1) switch (_context111.prev = _context111.next) {
            case 0:
              _context111.next = 2;
              return this.on(event, listener);
            case 2:
              return _context111.abrupt("return", _context111.sent);
            case 3:
            case "end":
              return _context111.stop();
          }
        }, _callee111, this);
      }));
      function addListener(_x171, _x172) {
        return _addListener2.apply(this, arguments);
      }
      return addListener;
    }() // Alias for "off"
  }, {
    key: "removeListener",
    value: function () {
      var _removeListener3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee112(event, listener) {
        return _regeneratorRuntime().wrap(function _callee112$(_context112) {
          while (1) switch (_context112.prev = _context112.next) {
            case 0:
              return _context112.abrupt("return", this.off(event, listener));
            case 1:
            case "end":
              return _context112.stop();
          }
        }, _callee112, this);
      }));
      function removeListener(_x173, _x174) {
        return _removeListener3.apply(this, arguments);
      }
      return removeListener;
    }() // Sub-classes should override this to shutdown any sockets, etc.
    // but MUST call this super.shutdown.
  }, {
    key: "destroy",
    value: function destroy() {
      // Stop all listeners
      this.removeAllListeners();
      // Shut down all tiemrs
      var _iterator37 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).keys()),
        _step37;
      try {
        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
          var timerId = _step37.value;
          this._clearTimeout(timerId);
        }
      } catch (err) {
        _iterator37.e(err);
      } finally {
        _iterator37.f();
      }
    }
  }, {
    key: "paused",
    get: function get() {
      return _classPrivateFieldGet(this, _pausedState) != null;
    },
    set: function set(pause) {
      if (!!pause === this.paused) {
        return;
      }
      if (this.paused) {
        this.resume();
      } else {
        this.pause(false);
      }
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      _classPrivateFieldSet(this, _lastBlockNumber, -1);
      if (_classPrivateFieldGet(this, _pausedState) != null) {
        if (_classPrivateFieldGet(this, _pausedState) == !!dropWhilePaused) {
          return;
        }
        assert$1(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
          operation: "pause"
        });
      }
      this._forEachSubscriber(function (s) {
        return s.pause(dropWhilePaused);
      });
      _classPrivateFieldSet(this, _pausedState, !!dropWhilePaused);
      var _iterator38 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),
        _step38;
      try {
        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
          var timer = _step38.value;
          // Clear the timer
          if (timer.timer) {
            clearTimeout(timer.timer);
          }
          // Remaining time needed for when we become unpaused
          timer.time = getTime$1() - timer.time;
        }
      } catch (err) {
        _iterator38.e(err);
      } finally {
        _iterator38.f();
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      if (_classPrivateFieldGet(this, _pausedState) == null) {
        return;
      }
      this._forEachSubscriber(function (s) {
        return s.resume();
      });
      _classPrivateFieldSet(this, _pausedState, null);
      var _iterator39 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),
        _step39;
      try {
        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
          var timer = _step39.value;
          // Remaining time when we were paused
          var timeout = timer.time;
          if (timeout < 0) {
            timeout = 0;
          }
          // Start time (in cause paused, so we con compute remaininf time)
          timer.time = getTime$1();
          // Start the timer
          setTimeout(timer.func, timeout);
        }
      } catch (err) {
        _iterator39.e(err);
      } finally {
        _iterator39.f();
      }
    }
  }]);
  return AbstractProvider;
}();
exports.AbstractProvider = AbstractProvider;
function _perform2(_x290) {
  return _perform8.apply(this, arguments);
}
function _perform8() {
  _perform8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee230(req) {
    var _this109 = this;
    var tag, perform;
    return _regeneratorRuntime().wrap(function _callee230$(_context233) {
      while (1) switch (_context233.prev = _context233.next) {
        case 0:
          // Create a tag
          tag = getTag(req.method, req);
          perform = _classPrivateFieldGet(this, _performCache).get(tag);
          if (!perform) {
            perform = this._perform(req);
            _classPrivateFieldGet(this, _performCache).set(tag, perform);
            setTimeout(function () {
              if (_classPrivateFieldGet(_this109, _performCache).get(tag) === perform) {
                _classPrivateFieldGet(_this109, _performCache)["delete"](tag);
              }
            }, 250);
          }
          _context233.next = 5;
          return perform;
        case 5:
          return _context233.abrupt("return", _context233.sent);
        case 6:
        case "end":
          return _context233.stop();
      }
    }, _callee230, this);
  }));
  return _perform8.apply(this, arguments);
}
function _call2(_x291, _x292, _x293) {
  return _call5.apply(this, arguments);
}
function _call5() {
  _call5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee231(tx, blockTag, attempt) {
    var transaction, data, txSender, ccipArgs, ccipResult, _tx2, result;
    return _regeneratorRuntime().wrap(function _callee231$(_context234) {
      while (1) switch (_context234.prev = _context234.next) {
        case 0:
          assert$1(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, tx, {
              blockTag: blockTag,
              enableCcipRead: true
            })
          });
          // This came in as a PerformActionTransaction, so to/from are safe; we can cast
          transaction = copyRequest(tx);
          _context234.prev = 2;
          _context234.t0 = hexlify;
          _context234.next = 6;
          return this._perform({
            method: "call",
            transaction: transaction,
            blockTag: blockTag
          });
        case 6:
          _context234.t1 = _context234.sent;
          return _context234.abrupt("return", (0, _context234.t0)(_context234.t1));
        case 10:
          _context234.prev = 10;
          _context234.t2 = _context234["catch"](2);
          if (!(!this.disableCcipRead && isCallException(_context234.t2) && _context234.t2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(_context234.t2.data, 0, 4) === "0x556f1830")) {
            _context234.next = 37;
            break;
          }
          data = _context234.t2.data;
          _context234.next = 16;
          return resolveAddress(transaction.to, this);
        case 16:
          txSender = _context234.sent;
          try {
            ccipArgs = parseOffchainLookup(dataSlice(_context234.t2.data, 4));
          } catch (error) {
            assert$1(false, error.message, "OFFCHAIN_FAULT", {
              reason: "BAD_DATA",
              transaction: transaction,
              info: {
                data: data
              }
            });
          }
          // Check the sender of the OffchainLookup matches the transaction
          assert$1(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
            action: "call",
            data: data,
            reason: "OffchainLookup",
            transaction: transaction,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: ccipArgs.errorArgs
            }
          });
          _context234.next = 21;
          return this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        case 21:
          ccipResult = _context234.sent;
          assert$1(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
            reason: "FETCH_FAILED",
            transaction: transaction,
            info: {
              data: _context234.t2.data,
              errorArgs: ccipArgs.errorArgs
            }
          });
          _tx2 = {
            to: txSender,
            data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
          };
          this.emit("debug", {
            action: "sendCcipReadCall",
            transaction: _tx2
          });
          _context234.prev = 25;
          _context234.next = 28;
          return _classPrivateMethodGet(this, _call, _call2).call(this, _tx2, blockTag, attempt + 1);
        case 28:
          result = _context234.sent;
          this.emit("debug", {
            action: "receiveCcipReadCallResult",
            transaction: Object.assign({}, _tx2),
            result: result
          });
          return _context234.abrupt("return", result);
        case 33:
          _context234.prev = 33;
          _context234.t3 = _context234["catch"](25);
          this.emit("debug", {
            action: "receiveCcipReadCallError",
            transaction: Object.assign({}, _tx2),
            error: _context234.t3
          });
          throw _context234.t3;
        case 37:
          throw _context234.t2;
        case 38:
        case "end":
          return _context234.stop();
      }
    }, _callee231, this, [[2, 10], [25, 33]]);
  }));
  return _call5.apply(this, arguments);
}
function _checkNetwork2(_x294) {
  return _checkNetwork3.apply(this, arguments);
}
function _checkNetwork3() {
  _checkNetwork3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee232(promise) {
    var _yield$resolvePropert13, value;
    return _regeneratorRuntime().wrap(function _callee232$(_context235) {
      while (1) switch (_context235.prev = _context235.next) {
        case 0:
          _context235.next = 2;
          return resolveProperties({
            network: this.getNetwork(),
            value: promise
          });
        case 2:
          _yield$resolvePropert13 = _context235.sent;
          value = _yield$resolvePropert13.value;
          return _context235.abrupt("return", value);
        case 5:
        case "end":
          return _context235.stop();
      }
    }, _callee232, this);
  }));
  return _checkNetwork3.apply(this, arguments);
}
function _getAccountValue2(_x295, _x296, _x297) {
  return _getAccountValue3.apply(this, arguments);
}
function _getAccountValue3() {
  _getAccountValue3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee233(request, _address, _blockTag) {
    var address, blockTag, _yield$Promise$all3, _yield$Promise$all4;
    return _regeneratorRuntime().wrap(function _callee233$(_context236) {
      while (1) switch (_context236.prev = _context236.next) {
        case 0:
          address = this._getAddress(_address);
          blockTag = this._getBlockTag(_blockTag);
          if (!(typeof address !== "string" || typeof blockTag !== "string")) {
            _context236.next = 9;
            break;
          }
          _context236.next = 5;
          return Promise.all([address, blockTag]);
        case 5:
          _yield$Promise$all3 = _context236.sent;
          _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
          address = _yield$Promise$all4[0];
          blockTag = _yield$Promise$all4[1];
        case 9:
          _context236.next = 11;
          return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _perform, _perform2).call(this, Object.assign(request, {
            address: address,
            blockTag: blockTag
          })));
        case 11:
          return _context236.abrupt("return", _context236.sent);
        case 12:
        case "end":
          return _context236.stop();
      }
    }, _callee233, this);
  }));
  return _getAccountValue3.apply(this, arguments);
}
function _getBlock6(_x298, _x299) {
  return _getBlock8.apply(this, arguments);
}
function _getBlock8() {
  _getBlock8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee234(block, includeTransactions) {
    var blockTag;
    return _regeneratorRuntime().wrap(function _callee234$(_context237) {
      while (1) switch (_context237.prev = _context237.next) {
        case 0:
          if (!isHexString(block, 32)) {
            _context237.next = 4;
            break;
          }
          _context237.next = 3;
          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {
            method: "getBlock",
            blockHash: block,
            includeTransactions: includeTransactions
          });
        case 3:
          return _context237.abrupt("return", _context237.sent);
        case 4:
          blockTag = this._getBlockTag(block);
          if (!(typeof blockTag !== "string")) {
            _context237.next = 9;
            break;
          }
          _context237.next = 8;
          return blockTag;
        case 8:
          blockTag = _context237.sent;
        case 9:
          _context237.next = 11;
          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {
            method: "getBlock",
            blockTag: blockTag,
            includeTransactions: includeTransactions
          });
        case 11:
          return _context237.abrupt("return", _context237.sent);
        case 12:
        case "end":
          return _context237.stop();
      }
    }, _callee234, this);
  }));
  return _getBlock8.apply(this, arguments);
}
function _hasSub3(_x300, _x301) {
  return _hasSub4.apply(this, arguments);
}
function _hasSub4() {
  _hasSub4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee235(event, emitArgs) {
    var sub;
    return _regeneratorRuntime().wrap(function _callee235$(_context238) {
      while (1) switch (_context238.prev = _context238.next) {
        case 0:
          _context238.next = 2;
          return getSubscription(event, this);
        case 2:
          sub = _context238.sent;
          if (!(sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true)) {
            _context238.next = 7;
            break;
          }
          _context238.next = 6;
          return getSubscription({
            orphan: "drop-log",
            log: emitArgs[0]
          }, this);
        case 6:
          sub = _context238.sent;
        case 7:
          return _context238.abrupt("return", _classPrivateFieldGet(this, _subs).get(sub.tag) || null);
        case 8:
        case "end":
          return _context238.stop();
      }
    }, _callee235, this);
  }));
  return _hasSub4.apply(this, arguments);
}
function _getSub3(_x302) {
  return _getSub4.apply(this, arguments);
}
function _getSub4() {
  _getSub4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee236(event) {
    var subscription, tag, sub, subscriber, addressableMap, nameMap;
    return _regeneratorRuntime().wrap(function _callee236$(_context239) {
      while (1) switch (_context239.prev = _context239.next) {
        case 0:
          _context239.next = 2;
          return getSubscription(event, this);
        case 2:
          subscription = _context239.sent;
          // Prevent tampering with our tag in any subclass' _getSubscriber
          tag = subscription.tag;
          sub = _classPrivateFieldGet(this, _subs).get(tag);
          if (!sub) {
            subscriber = this._getSubscriber(subscription);
            addressableMap = new WeakMap();
            nameMap = new Map();
            sub = {
              subscriber: subscriber,
              tag: tag,
              addressableMap: addressableMap,
              nameMap: nameMap,
              started: false,
              listeners: []
            };
            _classPrivateFieldGet(this, _subs).set(tag, sub);
          }
          return _context239.abrupt("return", sub);
        case 7:
        case "end":
          return _context239.stop();
      }
    }, _callee236, this);
  }));
  return _getSub4.apply(this, arguments);
}
function _parseString(result, start) {
  try {
    var _bytes6 = _parseBytes(result, start);
    if (_bytes6) {
      return toUtf8String(_bytes6);
    }
  } catch (error) {}
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    var offset = getNumber(dataSlice(result, start, start + 32));
    var length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {}
  return null;
}
function numPad(value) {
  var result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  var padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
var empty = new Uint8Array([]);
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
  var result = [];
  var byteCount = 0;
  // Add place-holders for pointers as we add items
  for (var _i53 = 0; _i53 < datas.length; _i53++) {
    result.push(empty);
    byteCount += 32;
  }
  for (var _i54 = 0; _i54 < datas.length; _i54++) {
    var data = getBytes(datas[_i54]);
    // Update the bytes offset
    result[_i54] = numPad(byteCount);
    // The length and padded value of data
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  var result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert$1(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  var sender = dataSlice(data, 0, 32);
  assert$1(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  // Read the URLs from the response
  try {
    var urls = [];
    var urlsOffset = getNumber(dataSlice(data, 32, 64));
    var urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    var urlsData = dataSlice(data, urlsOffset + 32);
    for (var u = 0; u < urlsLength; u++) {
      var url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert$1(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  // Get the CCIP calldata to forward
  try {
    var calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert$1(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  // Get the callbackSelector (bytes4)
  assert$1(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  // Get the extra data to send back to the contract as context
  try {
    var extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert$1(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(function (k) {
    return result[k];
  });
  return result;
}

/**
 *  About Abstract Signer and subclassing
 *
 *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]
 */
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert$1(false, "missing provider", "UNSUPPORTED_OPERATION", {
    operation: operation
  });
}
function populate(_x175, _x176) {
  return _populate.apply(this, arguments);
}
function _populate() {
  _populate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee217(signer, tx) {
    var pop, from;
    return _regeneratorRuntime().wrap(function _callee217$(_context219) {
      while (1) switch (_context219.prev = _context219.next) {
        case 0:
          pop = copyRequest(tx);
          if (pop.to != null) {
            pop.to = resolveAddress(pop.to, signer);
          }
          if (pop.from != null) {
            from = pop.from;
            pop.from = Promise.all([signer.getAddress(), resolveAddress(from, signer)]).then(function (_ref54) {
              var _ref55 = _slicedToArray(_ref54, 2),
                address = _ref55[0],
                from = _ref55[1];
              assertArgument(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
              return address;
            });
          } else {
            pop.from = signer.getAddress();
          }
          _context219.next = 5;
          return resolveProperties(pop);
        case 5:
          return _context219.abrupt("return", _context219.sent);
        case 6:
        case "end":
          return _context219.stop();
      }
    }, _callee217);
  }));
  return _populate.apply(this, arguments);
}
var AbstractSigner = /*#__PURE__*/function () {
  function AbstractSigner(provider) {
    _classCallCheck(this, AbstractSigner);
    _defineProperty(this, "provider", void 0);
    defineProperties(this, {
      provider: provider || null
    });
  }
  _createClass(AbstractSigner, [{
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee113(blockTag) {
        return _regeneratorRuntime().wrap(function _callee113$(_context113) {
          while (1) switch (_context113.prev = _context113.next) {
            case 0:
              _context113.t0 = checkProvider(this, "getTransactionCount");
              _context113.next = 3;
              return this.getAddress();
            case 3:
              _context113.t1 = _context113.sent;
              _context113.t2 = blockTag;
              return _context113.abrupt("return", _context113.t0.getTransactionCount.call(_context113.t0, _context113.t1, _context113.t2));
            case 6:
            case "end":
              return _context113.stop();
          }
        }, _callee113, this);
      }));
      function getNonce(_x177) {
        return _getNonce.apply(this, arguments);
      }
      return getNonce;
    }()
  }, {
    key: "populateCall",
    value: function () {
      var _populateCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee114(tx) {
        var pop;
        return _regeneratorRuntime().wrap(function _callee114$(_context114) {
          while (1) switch (_context114.prev = _context114.next) {
            case 0:
              _context114.next = 2;
              return populate(this, tx);
            case 2:
              pop = _context114.sent;
              return _context114.abrupt("return", pop);
            case 4:
            case "end":
              return _context114.stop();
          }
        }, _callee114, this);
      }));
      function populateCall(_x178) {
        return _populateCall.apply(this, arguments);
      }
      return populateCall;
    }()
  }, {
    key: "populateTransaction",
    value: function () {
      var _populateTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee115(tx) {
        var provider, pop, network, chainId, hasEip1559, feeData, _feeData, gasPrice;
        return _regeneratorRuntime().wrap(function _callee115$(_context115) {
          while (1) switch (_context115.prev = _context115.next) {
            case 0:
              provider = checkProvider(this, "populateTransaction");
              _context115.next = 3;
              return populate(this, tx);
            case 3:
              pop = _context115.sent;
              if (!(pop.nonce == null)) {
                _context115.next = 8;
                break;
              }
              _context115.next = 7;
              return this.getNonce("pending");
            case 7:
              pop.nonce = _context115.sent;
            case 8:
              if (!(pop.gasLimit == null)) {
                _context115.next = 12;
                break;
              }
              _context115.next = 11;
              return this.estimateGas(pop);
            case 11:
              pop.gasLimit = _context115.sent;
            case 12:
              _context115.next = 14;
              return this.provider.getNetwork();
            case 14:
              network = _context115.sent;
              if (pop.chainId != null) {
                chainId = getBigInt(pop.chainId);
                assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
              } else {
                pop.chainId = network.chainId;
              }
              // Do not allow mixing pre-eip-1559 and eip-1559 properties
              hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
              if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
                assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
              } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
                assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
              }
              if (!((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
                _context115.next = 22;
                break;
              }
              // Fully-formed EIP-1559 transaction (skip getFeeData)
              pop.type = 2;
              _context115.next = 34;
              break;
            case 22:
              if (!(pop.type === 0 || pop.type === 1)) {
                _context115.next = 30;
                break;
              }
              _context115.next = 25;
              return provider.getFeeData();
            case 25:
              feeData = _context115.sent;
              assert$1(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
              });
              // Populate missing gasPrice
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
              _context115.next = 34;
              break;
            case 30:
              _context115.next = 32;
              return provider.getFeeData();
            case 32:
              _feeData = _context115.sent;
              if (pop.type == null) {
                // We need to auto-detect the intended type of this transaction...
                if (_feeData.maxFeePerGas != null && _feeData.maxPriorityFeePerGas != null) {
                  // The network supports EIP-1559!
                  // Upgrade transaction from null to eip-1559
                  pop.type = 2;
                  if (pop.gasPrice != null) {
                    // Using legacy gasPrice property on an eip-1559 network,
                    // so use gasPrice as both fee properties
                    gasPrice = pop.gasPrice;
                    delete pop.gasPrice;
                    pop.maxFeePerGas = gasPrice;
                    pop.maxPriorityFeePerGas = gasPrice;
                  } else {
                    // Populate missing fee data
                    if (pop.maxFeePerGas == null) {
                      pop.maxFeePerGas = _feeData.maxFeePerGas;
                    }
                    if (pop.maxPriorityFeePerGas == null) {
                      pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                    }
                  }
                } else if (_feeData.gasPrice != null) {
                  // Network doesn't support EIP-1559...
                  // ...but they are trying to use EIP-1559 properties
                  assert$1(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                    operation: "populateTransaction"
                  });
                  // Populate missing fee data
                  if (pop.gasPrice == null) {
                    pop.gasPrice = _feeData.gasPrice;
                  }
                  // Explicitly set untyped transaction to legacy
                  // @TODO: Maybe this shold allow type 1?
                  pop.type = 0;
                } else {
                  // getFeeData has failed us.
                  assert$1(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                    operation: "signer.getFeeData"
                  });
                }
              } else if (pop.type === 2) {
                // Explicitly using EIP-1559
                // Populate missing fee data
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = _feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                }
              }
            case 34:
              _context115.next = 36;
              return resolveProperties(pop);
            case 36:
              return _context115.abrupt("return", _context115.sent);
            case 37:
            case "end":
              return _context115.stop();
          }
        }, _callee115, this);
      }));
      function populateTransaction(_x179) {
        return _populateTransaction3.apply(this, arguments);
      }
      return populateTransaction;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee116(tx) {
        return _regeneratorRuntime().wrap(function _callee116$(_context116) {
          while (1) switch (_context116.prev = _context116.next) {
            case 0:
              _context116.t0 = checkProvider(this, "estimateGas");
              _context116.next = 3;
              return this.populateCall(tx);
            case 3:
              _context116.t1 = _context116.sent;
              return _context116.abrupt("return", _context116.t0.estimateGas.call(_context116.t0, _context116.t1));
            case 5:
            case "end":
              return _context116.stop();
          }
        }, _callee116, this);
      }));
      function estimateGas(_x180) {
        return _estimateGas4.apply(this, arguments);
      }
      return estimateGas;
    }()
  }, {
    key: "call",
    value: function () {
      var _call4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee117(tx) {
        return _regeneratorRuntime().wrap(function _callee117$(_context117) {
          while (1) switch (_context117.prev = _context117.next) {
            case 0:
              _context117.t0 = checkProvider(this, "call");
              _context117.next = 3;
              return this.populateCall(tx);
            case 3:
              _context117.t1 = _context117.sent;
              return _context117.abrupt("return", _context117.t0.call.call(_context117.t0, _context117.t1));
            case 5:
            case "end":
              return _context117.stop();
          }
        }, _callee117, this);
      }));
      function call(_x181) {
        return _call4.apply(this, arguments);
      }
      return call;
    }()
  }, {
    key: "resolveName",
    value: function () {
      var _resolveName2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee118(name) {
        var provider;
        return _regeneratorRuntime().wrap(function _callee118$(_context118) {
          while (1) switch (_context118.prev = _context118.next) {
            case 0:
              provider = checkProvider(this, "resolveName");
              _context118.next = 3;
              return provider.resolveName(name);
            case 3:
              return _context118.abrupt("return", _context118.sent);
            case 4:
            case "end":
              return _context118.stop();
          }
        }, _callee118, this);
      }));
      function resolveName(_x182) {
        return _resolveName2.apply(this, arguments);
      }
      return resolveName;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee119(tx) {
        var provider, pop, txObj;
        return _regeneratorRuntime().wrap(function _callee119$(_context119) {
          while (1) switch (_context119.prev = _context119.next) {
            case 0:
              provider = checkProvider(this, "sendTransaction");
              _context119.next = 3;
              return this.populateTransaction(tx);
            case 3:
              pop = _context119.sent;
              delete pop.from;
              txObj = Transaction.from(pop);
              _context119.t0 = provider;
              _context119.next = 9;
              return this.signTransaction(txObj);
            case 9:
              _context119.t1 = _context119.sent;
              _context119.next = 12;
              return _context119.t0.broadcastTransaction.call(_context119.t0, _context119.t1);
            case 12:
              return _context119.abrupt("return", _context119.sent);
            case 13:
            case "end":
              return _context119.stop();
          }
        }, _callee119, this);
      }));
      function sendTransaction(_x183) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }]);
  return AbstractSigner;
}();
exports.AbstractSigner = AbstractSigner;
var _throwUnsupported = /*#__PURE__*/new WeakSet();
var VoidSigner = /*#__PURE__*/function (_AbstractSigner) {
  _inherits(VoidSigner, _AbstractSigner);
  var _super45 = _createSuper(VoidSigner);
  function VoidSigner(address, provider) {
    var _this63;
    _classCallCheck(this, VoidSigner);
    _this63 = _super45.call(this, provider);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this63), _throwUnsupported);
    _defineProperty(_assertThisInitialized(_this63), "address", void 0);
    defineProperties(_assertThisInitialized(_this63), {
      address: address
    });
    return _this63;
  }
  _createClass(VoidSigner, [{
    key: "getAddress",
    value: function () {
      var _getAddress3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee120() {
        return _regeneratorRuntime().wrap(function _callee120$(_context120) {
          while (1) switch (_context120.prev = _context120.next) {
            case 0:
              return _context120.abrupt("return", this.address);
            case 1:
            case "end":
              return _context120.stop();
          }
        }, _callee120, this);
      }));
      function getAddress() {
        return _getAddress3.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new VoidSigner(this.address, provider);
    }
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee121(tx) {
        return _regeneratorRuntime().wrap(function _callee121$(_context121) {
          while (1) switch (_context121.prev = _context121.next) {
            case 0:
              _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, "transactions", "signTransaction");
            case 1:
            case "end":
              return _context121.stop();
          }
        }, _callee121, this);
      }));
      function signTransaction(_x184) {
        return _signTransaction.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee122(message) {
        return _regeneratorRuntime().wrap(function _callee122$(_context122) {
          while (1) switch (_context122.prev = _context122.next) {
            case 0:
              _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, "messages", "signMessage");
            case 1:
            case "end":
              return _context122.stop();
          }
        }, _callee122, this);
      }));
      function signMessage(_x185) {
        return _signMessage.apply(this, arguments);
      }
      return signMessage;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee123(domain, types, value) {
        return _regeneratorRuntime().wrap(function _callee123$(_context123) {
          while (1) switch (_context123.prev = _context123.next) {
            case 0:
              _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, "typed-data", "signTypedData");
            case 1:
            case "end":
              return _context123.stop();
          }
        }, _callee123, this);
      }));
      function signTypedData(_x186, _x187, _x188) {
        return _signTypedData.apply(this, arguments);
      }
      return signTypedData;
    }()
  }]);
  return VoidSigner;
}(AbstractSigner);
/**
 *  There are many awesome community services that provide Ethereum
 *  nodes both for developers just starting out and for large-scale
 *  communities.
 *
 *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]
 */
// Show the throttle message only once per service
exports.VoidSigner = VoidSigner;
function _throwUnsupported2(suffix, operation) {
  assert$1(false, "VoidSigner cannot sign ".concat(suffix), "UNSUPPORTED_OPERATION", {
    operation: operation
  });
}
var shown = new Set();
/**
 *  Displays a warning in tht console when the community resource is
 *  being used too heavily by the app, recommending the developer
 *  acquire their own credentials instead of using the community
 *  credentials.
 *
 *  The notification will only occur once per service.
 */
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded for ".concat(service, " (this message will not be repeated)"));
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https:/\/docs.ethers.org/api-keys/");
  console.log("==========================");
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
/**
 *  Some backends support subscribing to events using a Filter ID.
 *
 *  When subscribing with this technique, the node issues a unique
 *  //Filter ID//. At this point the node dedicates resources to
 *  the filter, so that periodic calls to follow up on the //Filter ID//
 *  will receive any events since the last call.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider4 = /*#__PURE__*/new WeakMap();
var _filterIdPromise = /*#__PURE__*/new WeakMap();
var _poller3 = /*#__PURE__*/new WeakMap();
var _running3 = /*#__PURE__*/new WeakMap();
var _network2 = /*#__PURE__*/new WeakMap();
var _hault = /*#__PURE__*/new WeakMap();
var _poll9 = /*#__PURE__*/new WeakSet();
var _teardown = /*#__PURE__*/new WeakSet();
var FilterIdSubscriber = /*#__PURE__*/function () {
  function FilterIdSubscriber(provider) {
    _classCallCheck(this, FilterIdSubscriber);
    _classPrivateMethodInitSpec(this, _teardown);
    _classPrivateMethodInitSpec(this, _poll9);
    _classPrivateFieldInitSpec(this, _provider4, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _filterIdPromise, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _poller3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _running3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _network2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _hault, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _provider4, provider);
    _classPrivateFieldSet(this, _filterIdPromise, null);
    _classPrivateFieldSet(this, _poller3, _classPrivateMethodGet(this, _poll9, _poll10).bind(this));
    _classPrivateFieldSet(this, _running3, false);
    _classPrivateFieldSet(this, _network2, null);
    _classPrivateFieldSet(this, _hault, false);
  }
  _createClass(FilterIdSubscriber, [{
    key: "_subscribe",
    value: function _subscribe(provider) {
      throw new Error("subclasses must override this");
    }
  }, {
    key: "_emitResults",
    value: function _emitResults(provider, result) {
      throw new Error("subclasses must override this");
    }
  }, {
    key: "_recover",
    value: function _recover(provider) {
      throw new Error("subclasses must override this");
    }
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(this, _running3)) {
        return;
      }
      _classPrivateFieldSet(this, _running3, true);
      _classPrivateMethodGet(this, _poll9, _poll10).call(this, -2);
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(this, _running3)) {
        return;
      }
      _classPrivateFieldSet(this, _running3, false);
      _classPrivateFieldSet(this, _hault, true);
      _classPrivateMethodGet(this, _teardown, _teardown2).call(this);
      _classPrivateFieldGet(this, _provider4).off("block", _classPrivateFieldGet(this, _poller3));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      if (dropWhilePaused) {
        _classPrivateMethodGet(this, _teardown, _teardown2).call(this);
      }
      _classPrivateFieldGet(this, _provider4).off("block", _classPrivateFieldGet(this, _poller3));
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
  return FilterIdSubscriber;
}();
/**
 *  A **FilterIdSubscriber** for receiving contract events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
function _poll10(_x303) {
  return _poll13.apply(this, arguments);
}
function _poll13() {
  _poll13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee237(blockNumber) {
    var filterId, network, result;
    return _regeneratorRuntime().wrap(function _callee237$(_context240) {
      while (1) switch (_context240.prev = _context240.next) {
        case 0:
          _context240.prev = 0;
          // Subscribe if necessary
          if (_classPrivateFieldGet(this, _filterIdPromise) == null) {
            _classPrivateFieldSet(this, _filterIdPromise, this._subscribe(_classPrivateFieldGet(this, _provider4)));
          }
          // Get the Filter ID
          filterId = null;
          _context240.prev = 3;
          _context240.next = 6;
          return _classPrivateFieldGet(this, _filterIdPromise);
        case 6:
          filterId = _context240.sent;
          _context240.next = 13;
          break;
        case 9:
          _context240.prev = 9;
          _context240.t0 = _context240["catch"](3);
          if (!(!isError(_context240.t0, "UNSUPPORTED_OPERATION") || _context240.t0.operation !== "eth_newFilter")) {
            _context240.next = 13;
            break;
          }
          throw _context240.t0;
        case 13:
          if (!(filterId == null)) {
            _context240.next = 17;
            break;
          }
          _classPrivateFieldSet(this, _filterIdPromise, null);
          _classPrivateFieldGet(this, _provider4)._recoverSubscriber(this, this._recover(_classPrivateFieldGet(this, _provider4)));
          return _context240.abrupt("return");
        case 17:
          _context240.next = 19;
          return _classPrivateFieldGet(this, _provider4).getNetwork();
        case 19:
          network = _context240.sent;
          if (!_classPrivateFieldGet(this, _network2)) {
            _classPrivateFieldSet(this, _network2, network);
          }
          if (!(_classPrivateFieldGet(this, _network2).chainId !== network.chainId)) {
            _context240.next = 23;
            break;
          }
          throw new Error("chaid changed");
        case 23:
          if (!_classPrivateFieldGet(this, _hault)) {
            _context240.next = 25;
            break;
          }
          return _context240.abrupt("return");
        case 25:
          _context240.next = 27;
          return _classPrivateFieldGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
        case 27:
          result = _context240.sent;
          _context240.next = 30;
          return this._emitResults(_classPrivateFieldGet(this, _provider4), result);
        case 30:
          _context240.next = 35;
          break;
        case 32:
          _context240.prev = 32;
          _context240.t1 = _context240["catch"](0);
          console.log("@TODO", _context240.t1);
        case 35:
          _classPrivateFieldGet(this, _provider4).once("block", _classPrivateFieldGet(this, _poller3));
        case 36:
        case "end":
          return _context240.stop();
      }
    }, _callee237, this, [[0, 32], [3, 9]]);
  }));
  return _poll13.apply(this, arguments);
}
function _teardown2() {
  var _this106 = this;
  var filterIdPromise = _classPrivateFieldGet(this, _filterIdPromise);
  if (filterIdPromise) {
    _classPrivateFieldSet(this, _filterIdPromise, null);
    filterIdPromise.then(function (filterId) {
      _classPrivateFieldGet(_this106, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
}
var _event2 = /*#__PURE__*/new WeakMap();
var FilterIdEventSubscriber = /*#__PURE__*/function (_FilterIdSubscriber) {
  _inherits(FilterIdEventSubscriber, _FilterIdSubscriber);
  var _super46 = _createSuper(FilterIdEventSubscriber);
  function FilterIdEventSubscriber(provider, filter) {
    var _this64;
    _classCallCheck(this, FilterIdEventSubscriber);
    _this64 = _super46.call(this, provider);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this64), _event2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this64), _event2, copy(filter));
    return _this64;
  }
  _createClass(FilterIdEventSubscriber, [{
    key: "_recover",
    value: function _recover(provider) {
      return new PollingEventSubscriber(provider, _classPrivateFieldGet(this, _event2));
    }
  }, {
    key: "_subscribe",
    value: function () {
      var _subscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee124(provider) {
        var filterId;
        return _regeneratorRuntime().wrap(function _callee124$(_context124) {
          while (1) switch (_context124.prev = _context124.next) {
            case 0:
              _context124.next = 2;
              return provider.send("eth_newFilter", [_classPrivateFieldGet(this, _event2)]);
            case 2:
              filterId = _context124.sent;
              return _context124.abrupt("return", filterId);
            case 4:
            case "end":
              return _context124.stop();
          }
        }, _callee124, this);
      }));
      function _subscribe(_x189) {
        return _subscribe2.apply(this, arguments);
      }
      return _subscribe;
    }()
  }, {
    key: "_emitResults",
    value: function () {
      var _emitResults2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee125(provider, results) {
        var _iterator40, _step40, result;
        return _regeneratorRuntime().wrap(function _callee125$(_context125) {
          while (1) switch (_context125.prev = _context125.next) {
            case 0:
              _iterator40 = _createForOfIteratorHelper(results);
              try {
                for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                  result = _step40.value;
                  provider.emit(_classPrivateFieldGet(this, _event2), provider._wrapLog(result, provider._network));
                }
              } catch (err) {
                _iterator40.e(err);
              } finally {
                _iterator40.f();
              }
            case 2:
            case "end":
              return _context125.stop();
          }
        }, _callee125, this);
      }));
      function _emitResults(_x190, _x191) {
        return _emitResults2.apply(this, arguments);
      }
      return _emitResults;
    }()
  }]);
  return FilterIdEventSubscriber;
}(FilterIdSubscriber);
/**
 *  A **FilterIdSubscriber** for receiving pending transactions events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var FilterIdPendingSubscriber = /*#__PURE__*/function (_FilterIdSubscriber2) {
  _inherits(FilterIdPendingSubscriber, _FilterIdSubscriber2);
  var _super47 = _createSuper(FilterIdPendingSubscriber);
  function FilterIdPendingSubscriber() {
    _classCallCheck(this, FilterIdPendingSubscriber);
    return _super47.apply(this, arguments);
  }
  _createClass(FilterIdPendingSubscriber, [{
    key: "_subscribe",
    value: function () {
      var _subscribe3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee126(provider) {
        return _regeneratorRuntime().wrap(function _callee126$(_context126) {
          while (1) switch (_context126.prev = _context126.next) {
            case 0:
              _context126.next = 2;
              return provider.send("eth_newPendingTransactionFilter", []);
            case 2:
              return _context126.abrupt("return", _context126.sent);
            case 3:
            case "end":
              return _context126.stop();
          }
        }, _callee126);
      }));
      function _subscribe(_x192) {
        return _subscribe3.apply(this, arguments);
      }
      return _subscribe;
    }()
  }, {
    key: "_emitResults",
    value: function () {
      var _emitResults3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee127(provider, results) {
        var _iterator41, _step41, result;
        return _regeneratorRuntime().wrap(function _callee127$(_context127) {
          while (1) switch (_context127.prev = _context127.next) {
            case 0:
              _iterator41 = _createForOfIteratorHelper(results);
              try {
                for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                  result = _step41.value;
                  provider.emit("pending", result);
                }
              } catch (err) {
                _iterator41.e(err);
              } finally {
                _iterator41.f();
              }
            case 2:
            case "end":
              return _context127.stop();
          }
        }, _callee127);
      }));
      function _emitResults(_x193, _x194) {
        return _emitResults3.apply(this, arguments);
      }
      return _emitResults;
    }()
  }]);
  return FilterIdPendingSubscriber;
}(FilterIdSubscriber);
/**
 *  About JSON-RPC...
 *
 * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]
 */
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
//const Methods = "getAddress,then".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(_typeof(value)) >= 0) {
    return value;
  }
  // Keep any Addressable
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (_typeof(value) === "object") {
    return Object.keys(value).reduce(function (accum, key) {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error("should not happen: ".concat(value, " (").concat(_typeof(value), ")"));
}
function stall$3(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100 // 100 requests
};
// @TODO: Unchecked Signers
var JsonRpcSigner = /*#__PURE__*/function (_AbstractSigner2) {
  _inherits(JsonRpcSigner, _AbstractSigner2);
  var _super48 = _createSuper(JsonRpcSigner);
  function JsonRpcSigner(provider, address) {
    var _this65;
    _classCallCheck(this, JsonRpcSigner);
    _this65 = _super48.call(this, provider);
    _defineProperty(_assertThisInitialized(_this65), "address", void 0);
    defineProperties(_assertThisInitialized(_this65), {
      address: address
    });
    return _this65;
  }
  _createClass(JsonRpcSigner, [{
    key: "connect",
    value: function connect(provider) {
      assert$1(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
        operation: "signer.connect"
      });
    }
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee128() {
        return _regeneratorRuntime().wrap(function _callee128$(_context128) {
          while (1) switch (_context128.prev = _context128.next) {
            case 0:
              return _context128.abrupt("return", this.address);
            case 1:
            case "end":
              return _context128.stop();
          }
        }, _callee128, this);
      }));
      function getAddress() {
        return _getAddress4.apply(this, arguments);
      }
      return getAddress;
    }() // JSON-RPC will automatially fill in nonce, etc. so we just check from
  }, {
    key: "populateTransaction",
    value: function () {
      var _populateTransaction4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee129(tx) {
        return _regeneratorRuntime().wrap(function _callee129$(_context129) {
          while (1) switch (_context129.prev = _context129.next) {
            case 0:
              _context129.next = 2;
              return this.populateCall(tx);
            case 2:
              return _context129.abrupt("return", _context129.sent);
            case 3:
            case "end":
              return _context129.stop();
          }
        }, _callee129, this);
      }));
      function populateTransaction(_x195) {
        return _populateTransaction4.apply(this, arguments);
      }
      return populateTransaction;
    }() // Returns just the hash of the transaction after sent, which is what
    // the bare JSON-RPC API does;
  }, {
    key: "sendUncheckedTransaction",
    value: function () {
      var _sendUncheckedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee133(_tx) {
        var _this66 = this;
        var tx, promises, _from, _to, hexTx;
        return _regeneratorRuntime().wrap(function _callee133$(_context133) {
          while (1) switch (_context133.prev = _context133.next) {
            case 0:
              tx = deepCopy(_tx);
              promises = []; // Make sure the from matches the sender
              if (tx.from) {
                _from = tx.from;
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee130() {
                  var from;
                  return _regeneratorRuntime().wrap(function _callee130$(_context130) {
                    while (1) switch (_context130.prev = _context130.next) {
                      case 0:
                        _context130.next = 2;
                        return resolveAddress(_from, _this66.provider);
                      case 2:
                        from = _context130.sent;
                        assertArgument(from != null && from.toLowerCase() === _this66.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                        tx.from = from;
                      case 5:
                      case "end":
                        return _context130.stop();
                    }
                  }, _callee130);
                }))());
              } else {
                tx.from = this.address;
              }
              // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
              // wishes to use this, it is easy to specify explicitly, otherwise
              // we look it up for them.
              if (tx.gasLimit == null) {
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee131() {
                  return _regeneratorRuntime().wrap(function _callee131$(_context131) {
                    while (1) switch (_context131.prev = _context131.next) {
                      case 0:
                        _context131.next = 2;
                        return _this66.provider.estimateGas(_objectSpread(_objectSpread({}, tx), {}, {
                          from: _this66.address
                        }));
                      case 2:
                        tx.gasLimit = _context131.sent;
                      case 3:
                      case "end":
                        return _context131.stop();
                    }
                  }, _callee131);
                }))());
              }
              // The address may be an ENS name or Addressable
              if (tx.to != null) {
                _to = tx.to;
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee132() {
                  return _regeneratorRuntime().wrap(function _callee132$(_context132) {
                    while (1) switch (_context132.prev = _context132.next) {
                      case 0:
                        _context132.next = 2;
                        return resolveAddress(_to, _this66.provider);
                      case 2:
                        tx.to = _context132.sent;
                      case 3:
                      case "end":
                        return _context132.stop();
                    }
                  }, _callee132);
                }))());
              }
              // Wait until all of our properties are filled in
              if (!promises.length) {
                _context133.next = 8;
                break;
              }
              _context133.next = 8;
              return Promise.all(promises);
            case 8:
              hexTx = this.provider.getRpcTransaction(tx);
              return _context133.abrupt("return", this.provider.send("eth_sendTransaction", [hexTx]));
            case 10:
            case "end":
              return _context133.stop();
          }
        }, _callee133, this);
      }));
      function sendUncheckedTransaction(_x196) {
        return _sendUncheckedTransaction.apply(this, arguments);
      }
      return sendUncheckedTransaction;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee135(tx) {
        var _this67 = this;
        var blockNumber, hash;
        return _regeneratorRuntime().wrap(function _callee135$(_context135) {
          while (1) switch (_context135.prev = _context135.next) {
            case 0:
              _context135.next = 2;
              return this.provider.getBlockNumber();
            case 2:
              blockNumber = _context135.sent;
              _context135.next = 5;
              return this.sendUncheckedTransaction(tx);
            case 5:
              hash = _context135.sent;
              _context135.next = 8;
              return new Promise(function (resolve, reject) {
                var timeouts = [1000, 100];
                var checkTx = /*#__PURE__*/function () {
                  var _ref32 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee134() {
                    var tx;
                    return _regeneratorRuntime().wrap(function _callee134$(_context134) {
                      while (1) switch (_context134.prev = _context134.next) {
                        case 0:
                          _context134.next = 2;
                          return _this67.provider.getTransaction(hash);
                        case 2:
                          tx = _context134.sent;
                          if (!(tx != null)) {
                            _context134.next = 6;
                            break;
                          }
                          resolve(tx.replaceableTransaction(blockNumber));
                          return _context134.abrupt("return");
                        case 6:
                          // Wait another 4 seconds
                          _this67.provider._setTimeout(function () {
                            checkTx();
                          }, timeouts.pop() || 4000);
                        case 7:
                        case "end":
                          return _context134.stop();
                      }
                    }, _callee134);
                  }));
                  return function checkTx() {
                    return _ref32.apply(this, arguments);
                  };
                }();
                checkTx();
              });
            case 8:
              return _context135.abrupt("return", _context135.sent);
            case 9:
            case "end":
              return _context135.stop();
          }
        }, _callee135, this);
      }));
      function sendTransaction(_x197) {
        return _sendTransaction2.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee136(_tx) {
        var tx, from, hexTx;
        return _regeneratorRuntime().wrap(function _callee136$(_context136) {
          while (1) switch (_context136.prev = _context136.next) {
            case 0:
              tx = deepCopy(_tx); // Make sure the from matches the sender
              if (!tx.from) {
                _context136.next = 9;
                break;
              }
              _context136.next = 4;
              return resolveAddress(tx.from, this.provider);
            case 4:
              from = _context136.sent;
              assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
              tx.from = from;
              _context136.next = 10;
              break;
            case 9:
              tx.from = this.address;
            case 10:
              hexTx = this.provider.getRpcTransaction(tx);
              _context136.next = 13;
              return this.provider.send("eth_signTransaction", [hexTx]);
            case 13:
              return _context136.abrupt("return", _context136.sent);
            case 14:
            case "end":
              return _context136.stop();
          }
        }, _callee136, this);
      }));
      function signTransaction(_x198) {
        return _signTransaction2.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee137(_message) {
        var message;
        return _regeneratorRuntime().wrap(function _callee137$(_context137) {
          while (1) switch (_context137.prev = _context137.next) {
            case 0:
              message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
              _context137.next = 3;
              return this.provider.send("personal_sign", [hexlify(message), this.address.toLowerCase()]);
            case 3:
              return _context137.abrupt("return", _context137.sent);
            case 4:
            case "end":
              return _context137.stop();
          }
        }, _callee137, this);
      }));
      function signMessage(_x199) {
        return _signMessage2.apply(this, arguments);
      }
      return signMessage;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee139(domain, types, _value) {
        var value, populated;
        return _regeneratorRuntime().wrap(function _callee139$(_context139) {
          while (1) switch (_context139.prev = _context139.next) {
            case 0:
              value = deepCopy(_value); // Populate any ENS names (in-place)
              _context139.next = 3;
              return TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                var _ref33 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee138(value) {
                  var address;
                  return _regeneratorRuntime().wrap(function _callee138$(_context138) {
                    while (1) switch (_context138.prev = _context138.next) {
                      case 0:
                        _context138.next = 2;
                        return resolveAddress(value);
                      case 2:
                        address = _context138.sent;
                        assertArgument(address != null, "TypedData does not support null address", "value", value);
                        return _context138.abrupt("return", address);
                      case 5:
                      case "end":
                        return _context138.stop();
                    }
                  }, _callee138);
                }));
                return function (_x203) {
                  return _ref33.apply(this, arguments);
                };
              }());
            case 3:
              populated = _context139.sent;
              _context139.next = 6;
              return this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
            case 6:
              return _context139.abrupt("return", _context139.sent);
            case 7:
            case "end":
              return _context139.stop();
          }
        }, _callee139, this);
      }));
      function signTypedData(_x200, _x201, _x202) {
        return _signTypedData2.apply(this, arguments);
      }
      return signTypedData;
    }()
  }, {
    key: "unlock",
    value: function () {
      var _unlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee140(password) {
        return _regeneratorRuntime().wrap(function _callee140$(_context140) {
          while (1) switch (_context140.prev = _context140.next) {
            case 0:
              return _context140.abrupt("return", this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), password, null]));
            case 1:
            case "end":
              return _context140.stop();
          }
        }, _callee140, this);
      }));
      function unlock(_x204) {
        return _unlock.apply(this, arguments);
      }
      return unlock;
    }() // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  }, {
    key: "_legacySignMessage",
    value: function () {
      var _legacySignMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee141(_message) {
        var message;
        return _regeneratorRuntime().wrap(function _callee141$(_context141) {
          while (1) switch (_context141.prev = _context141.next) {
            case 0:
              message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
              _context141.next = 3;
              return this.provider.send("eth_sign", [this.address.toLowerCase(), hexlify(message)]);
            case 3:
              return _context141.abrupt("return", _context141.sent);
            case 4:
            case "end":
              return _context141.stop();
          }
        }, _callee141, this);
      }));
      function _legacySignMessage(_x205) {
        return _legacySignMessage2.apply(this, arguments);
      }
      return _legacySignMessage;
    }()
  }]);
  return JsonRpcSigner;
}(AbstractSigner);
/**
 *  The JsonRpcApiProvider is an abstract class and **MUST** be
 *  sub-classed.
 *
 *  It provides the base for all JSON-RPC-based Provider interaction.
 *
 *  Sub-classing Notes:
 *  - a sub-class MUST override _send
 *  - a sub-class MUST call the `_start()` method once connected
 */
exports.JsonRpcSigner = JsonRpcSigner;
var _options2 = /*#__PURE__*/new WeakMap();
var _nextId = /*#__PURE__*/new WeakMap();
var _payloads = /*#__PURE__*/new WeakMap();
var _drainTimer = /*#__PURE__*/new WeakMap();
var _notReady = /*#__PURE__*/new WeakMap();
var _network3 = /*#__PURE__*/new WeakMap();
var _scheduleDrain = /*#__PURE__*/new WeakSet();
var JsonRpcApiProvider = /*#__PURE__*/function (_AbstractProvider) {
  _inherits(JsonRpcApiProvider, _AbstractProvider);
  var _super49 = _createSuper(JsonRpcApiProvider);
  // The next ID to use for the JSON-RPC ID field

  // Payloads are queued and triggered in batches using the drainTimer

  function JsonRpcApiProvider(network, options) {
    var _this68;
    _classCallCheck(this, JsonRpcApiProvider);
    _this68 = _super49.call(this, network);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this68), _scheduleDrain);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _options2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _nextId, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _payloads, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _drainTimer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _notReady, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this68), _network3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this68), _nextId, 1);
    _classPrivateFieldSet(_assertThisInitialized(_this68), _options2, Object.assign({}, defaultOptions, options || {}));
    _classPrivateFieldSet(_assertThisInitialized(_this68), _payloads, []);
    _classPrivateFieldSet(_assertThisInitialized(_this68), _drainTimer, null);
    _classPrivateFieldSet(_assertThisInitialized(_this68), _network3, null);
    {
      var resolve = null;
      var promise = new Promise(function (_resolve) {
        resolve = _resolve;
      });
      _classPrivateFieldSet(_assertThisInitialized(_this68), _notReady, {
        promise: promise,
        resolve: resolve
      });
    }
    // This could be relaxed in the future to just check equivalent networks
    var staticNetwork = _this68._getOption("staticNetwork");
    if (staticNetwork) {
      assertArgument(staticNetwork === network, "staticNetwork MUST match network object", "options", options);
      _classPrivateFieldSet(_assertThisInitialized(_this68), _network3, staticNetwork);
    }
    return _this68;
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _createClass(JsonRpcApiProvider, [{
    key: "_getOption",
    value: function _getOption(key) {
      return _classPrivateFieldGet(this, _options2)[key];
    }
    /**
     *  Gets the [[Network]] this provider has committed to. On each call, the network
     *  is detected, and if it has changed, the call will reject.
     */
  }, {
    key: "_network",
    get: function get() {
      assert$1(_classPrivateFieldGet(this, _network3), "network is not available yet", "NETWORK_ERROR");
      return _classPrivateFieldGet(this, _network3);
    }
    /*
     {
        assert(false, "sub-classes must override _send", "UNSUPPORTED_OPERATION", {
            operation: "jsonRpcApiProvider._send"
        });
    }
    */
    /**
     *  Resolves to the non-normalized value by performing %%req%%.
     *
     *  Sub-classes may override this to modify behavior of actions,
     *  and should generally call ``super._perform`` as a fallback.
     */
  }, {
    key: "_perform",
    value: function () {
      var _perform4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee142(req) {
        var tx, feeData, request;
        return _regeneratorRuntime().wrap(function _callee142$(_context142) {
          while (1) switch (_context142.prev = _context142.next) {
            case 0:
              if (!(req.method === "call" || req.method === "estimateGas")) {
                _context142.next = 8;
                break;
              }
              tx = req.transaction;
              if (!(tx && tx.type != null && getBigInt(tx.type))) {
                _context142.next = 8;
                break;
              }
              if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {
                _context142.next = 8;
                break;
              }
              _context142.next = 6;
              return this.getFeeData();
            case 6:
              feeData = _context142.sent;
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                // Network doesn't know about EIP-1559 (and hence type)
                req = Object.assign({}, req, {
                  transaction: Object.assign({}, tx, {
                    type: undefined
                  })
                });
              }
            case 8:
              request = this.getRpcRequest(req);
              if (!(request != null)) {
                _context142.next = 13;
                break;
              }
              _context142.next = 12;
              return this.send(request.method, request.args);
            case 12:
              return _context142.abrupt("return", _context142.sent);
            case 13:
              return _context142.abrupt("return", _get(_getPrototypeOf(JsonRpcApiProvider.prototype), "_perform", this).call(this, req));
            case 14:
            case "end":
              return _context142.stop();
          }
        }, _callee142, this);
      }));
      function _perform(_x206) {
        return _perform4.apply(this, arguments);
      }
      return _perform;
    }()
    /**
     *  Sub-classes may override this; it detects the *actual* network that
     *  we are **currently** connected to.
     *
     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
     *  _send primitive must be used instead.
     */
  }, {
    key: "_detectNetwork",
    value: function () {
      var _detectNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee143() {
        var _this$nextId, _this$nextId2;
        var network, payload, result;
        return _regeneratorRuntime().wrap(function _callee143$(_context143) {
          while (1) switch (_context143.prev = _context143.next) {
            case 0:
              network = this._getOption("staticNetwork");
              if (!network) {
                _context143.next = 3;
                break;
              }
              return _context143.abrupt("return", network);
            case 3:
              if (!this.ready) {
                _context143.next = 11;
                break;
              }
              _context143.t0 = Network;
              _context143.t1 = getBigInt;
              _context143.next = 8;
              return this.send("eth_chainId", []);
            case 8:
              _context143.t2 = _context143.sent;
              _context143.t3 = (0, _context143.t1)(_context143.t2);
              return _context143.abrupt("return", _context143.t0.from.call(_context143.t0, _context143.t3));
            case 11:
              // We are not ready yet; use the primitive _send
              payload = {
                id: (_classPrivateFieldSet(this, _nextId, (_this$nextId = _classPrivateFieldGet(this, _nextId), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),
                method: "eth_chainId",
                params: [],
                jsonrpc: "2.0"
              };
              this.emit("debug", {
                action: "sendRpcPayload",
                payload: payload
              });
              _context143.prev = 13;
              _context143.next = 16;
              return this._send(payload);
            case 16:
              result = _context143.sent[0];
              _context143.next = 23;
              break;
            case 19:
              _context143.prev = 19;
              _context143.t4 = _context143["catch"](13);
              this.emit("debug", {
                action: "receiveRpcError",
                error: _context143.t4
              });
              throw _context143.t4;
            case 23:
              this.emit("debug", {
                action: "receiveRpcResult",
                result: result
              });
              if (!("result" in result)) {
                _context143.next = 26;
                break;
              }
              return _context143.abrupt("return", Network.from(getBigInt(result.result)));
            case 26:
              throw this.getRpcError(payload, result);
            case 27:
            case "end":
              return _context143.stop();
          }
        }, _callee143, this, [[13, 19]]);
      }));
      function _detectNetwork() {
        return _detectNetwork2.apply(this, arguments);
      }
      return _detectNetwork;
    }()
    /**
     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
     *  will be passed to [[_send]] from [[send]]. If it is overridden, then
     *  ``super._start()`` **MUST** be called.
     *
     *  Calling it multiple times is safe and has no effect.
     */
  }, {
    key: "_start",
    value: function _start() {
      var _this69 = this;
      if (_classPrivateFieldGet(this, _notReady) == null || _classPrivateFieldGet(this, _notReady).resolve == null) {
        return;
      }
      _classPrivateFieldGet(this, _notReady).resolve();
      _classPrivateFieldSet(this, _notReady, null);
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee144() {
        return _regeneratorRuntime().wrap(function _callee144$(_context144) {
          while (1) switch (_context144.prev = _context144.next) {
            case 0:
              if (!(_classPrivateFieldGet(_this69, _network3) == null)) {
                _context144.next = 18;
                break;
              }
              _context144.prev = 1;
              _context144.t0 = _classPrivateFieldSet;
              _context144.t1 = _this69;
              _context144.t2 = _network3;
              _context144.next = 7;
              return _this69._detectNetwork();
            case 7:
              _context144.t3 = _context144.sent;
              (0, _context144.t0)(_context144.t1, _context144.t2, _context144.t3);
              _context144.next = 16;
              break;
            case 11:
              _context144.prev = 11;
              _context144.t4 = _context144["catch"](1);
              console.log("JsonRpcProvider failed to startup; retry in 1s");
              _context144.next = 16;
              return stall$3(1000);
            case 16:
              _context144.next = 0;
              break;
            case 18:
              // Start dispatching requests
              _classPrivateMethodGet(_this69, _scheduleDrain, _scheduleDrain2).call(_this69);
            case 19:
            case "end":
              return _context144.stop();
          }
        }, _callee144, null, [[1, 11]]);
      }))();
    }
    /**
     *  Resolves once the [[_start]] has been called. This can be used in
     *  sub-classes to defer sending data until the connection has been
     *  established.
     */
  }, {
    key: "_waitUntilReady",
    value: function () {
      var _waitUntilReady2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee145() {
        return _regeneratorRuntime().wrap(function _callee145$(_context145) {
          while (1) switch (_context145.prev = _context145.next) {
            case 0:
              if (!(_classPrivateFieldGet(this, _notReady) == null)) {
                _context145.next = 2;
                break;
              }
              return _context145.abrupt("return");
            case 2:
              _context145.next = 4;
              return _classPrivateFieldGet(this, _notReady).promise;
            case 4:
              return _context145.abrupt("return", _context145.sent);
            case 5:
            case "end":
              return _context145.stop();
          }
        }, _callee145, this);
      }));
      function _waitUntilReady() {
        return _waitUntilReady2.apply(this, arguments);
      }
      return _waitUntilReady;
    }()
    /**
     *  Return a Subscriber that will manage the %%sub%%.
     *
     *  Sub-classes may override this to modify the behavior of
     *  subscription management.
     */
  }, {
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      // Pending Filters aren't availble via polling
      if (sub.type === "pending") {
        return new FilterIdPendingSubscriber(this);
      }
      if (sub.type === "event") {
        if (this._getOption("polling")) {
          return new PollingEventSubscriber(this, sub.filter);
        }
        return new FilterIdEventSubscriber(this, sub.filter);
      }
      // Orphaned Logs are handled automatically, by the filter, since
      // logs with removed are emitted by it
      if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
        return new UnmanagedSubscriber("orphan");
      }
      return _get(_getPrototypeOf(JsonRpcApiProvider.prototype), "_getSubscriber", this).call(this, sub);
    }
    /**
     *  Returns true only if the [[_start]] has been called.
     */
  }, {
    key: "ready",
    get: function get() {
      return _classPrivateFieldGet(this, _notReady) == null;
    }
    /**
     *  Returns %%tx%% as a normalized JSON-RPC transaction request,
     *  which has all values hexlified and any numeric values converted
     *  to Quantity values.
     */
  }, {
    key: "getRpcTransaction",
    value: function getRpcTransaction(tx) {
      var result = {};
      // JSON-RPC now requires numeric values to be "quantity" values
      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
        if (tx[key] == null) {
          return;
        }
        var dstKey = key;
        if (key === "gasLimit") {
          dstKey = "gas";
        }
        result[dstKey] = toQuantity(getBigInt(tx[key], "tx.".concat(key)));
      });
      // Make sure addresses and data are lowercase
      ["from", "to", "data"].forEach(function (key) {
        if (tx[key] == null) {
          return;
        }
        result[key] = hexlify(tx[key]);
      });
      // Normalize the access list object
      if (tx.accessList) {
        result["accessList"] = accessListify(tx.accessList);
      }
      return result;
    }
    /**
     *  Returns the request method and arguments required to perform
     *  %%req%%.
     */
  }, {
    key: "getRpcRequest",
    value: function getRpcRequest(req) {
      switch (req.method) {
        case "chainId":
          return {
            method: "eth_chainId",
            args: []
          };
        case "getBlockNumber":
          return {
            method: "eth_blockNumber",
            args: []
          };
        case "getGasPrice":
          return {
            method: "eth_gasPrice",
            args: []
          };
        case "getBalance":
          return {
            method: "eth_getBalance",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getTransactionCount":
          return {
            method: "eth_getTransactionCount",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getCode":
          return {
            method: "eth_getCode",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getStorage":
          return {
            method: "eth_getStorageAt",
            args: [getLowerCase(req.address), "0x" + req.position.toString(16), req.blockTag]
          };
        case "broadcastTransaction":
          return {
            method: "eth_sendRawTransaction",
            args: [req.signedTransaction]
          };
        case "getBlock":
          if ("blockTag" in req) {
            return {
              method: "eth_getBlockByNumber",
              args: [req.blockTag, !!req.includeTransactions]
            };
          } else if ("blockHash" in req) {
            return {
              method: "eth_getBlockByHash",
              args: [req.blockHash, !!req.includeTransactions]
            };
          }
          break;
        case "getTransaction":
          return {
            method: "eth_getTransactionByHash",
            args: [req.hash]
          };
        case "getTransactionReceipt":
          return {
            method: "eth_getTransactionReceipt",
            args: [req.hash]
          };
        case "call":
          return {
            method: "eth_call",
            args: [this.getRpcTransaction(req.transaction), req.blockTag]
          };
        case "estimateGas":
          {
            return {
              method: "eth_estimateGas",
              args: [this.getRpcTransaction(req.transaction)]
            };
          }
        case "getLogs":
          if (req.filter && req.filter.address != null) {
            if (Array.isArray(req.filter.address)) {
              req.filter.address = req.filter.address.map(getLowerCase);
            } else {
              req.filter.address = getLowerCase(req.filter.address);
            }
          }
          return {
            method: "eth_getLogs",
            args: [req.filter]
          };
      }
      return null;
    }
    /**
     *  Returns an ethers-style Error for the given JSON-RPC error
     *  %%payload%%, coalescing the various strings and error shapes
     *  that different nodes return, coercing them into a machine-readable
     *  standardized error.
     */
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, _error) {
      var method = payload.method;
      var error = _error.error;
      if (method === "eth_estimateGas" && error.message) {
        var msg = error.message;
        if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
          return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: payload.params[0]
          });
        }
      }
      if (method === "eth_call" || method === "eth_estimateGas") {
        var result = spelunkData(error);
        var e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
        e.info = {
          error: error,
          payload: payload
        };
        return e;
      }
      // Only estimateGas and call can return arbitrary contract-defined text, so now we
      // we can process text safely.
      var message = JSON.stringify(spelunkMessage(error));
      if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
        var actionMap = {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        };
        return makeError("user rejected action", "ACTION_REJECTED", {
          action: actionMap[method] || "unknown",
          reason: "rejected",
          info: {
            payload: payload,
            error: error
          }
        });
      }
      if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
        var transaction = payload.params[0];
        if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
          return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction,
            info: {
              error: error
            }
          });
        }
        if (message.match(/nonce/i) && message.match(/too low/i)) {
          return makeError("nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction
          });
        }
        // "replacement transaction underpriced"
        if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
          return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction
          });
        }
        if (message.match(/only replay-protected/i)) {
          return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
            operation: method,
            info: {
              transaction: transaction
            }
          });
        }
      }
      if (message.match(/the method .* does not exist/i)) {
        return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
          operation: payload.method,
          info: {
            error: error
          }
        });
      }
      return makeError("could not coalesce error", "UNKNOWN_ERROR", {
        error: error
      });
    }
    /**
     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
     *  over the underlying channel. This can be used to call methods
     *  on the backend that do not have a high-level API within the Provider
     *  API.
     *
     *  This method queues requests according to the batch constraints
     *  in the options, assigns the request a unique ID.
     *
     *  **Do NOT override** this method in sub-classes; instead
     *  override [[_send]] or force the options values in the
     *  call to the constructor to modify this method's behavior.
     */
  }, {
    key: "send",
    value: function send(method, params) {
      var _this$nextId3,
        _this$nextId4,
        _this70 = this;
      // @TODO: cache chainId?? purge on switch_networks
      var id = (_classPrivateFieldSet(this, _nextId, (_this$nextId3 = _classPrivateFieldGet(this, _nextId), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);
      var promise = new Promise(function (resolve, reject) {
        _classPrivateFieldGet(_this70, _payloads).push({
          resolve: resolve,
          reject: reject,
          payload: {
            method: method,
            params: params,
            id: id,
            jsonrpc: "2.0"
          }
        });
      });
      // If there is not a pending drainTimer, set one
      _classPrivateMethodGet(this, _scheduleDrain, _scheduleDrain2).call(this);
      return promise;
    }
    /**
     *  Resolves to the [[Signer]] account for  %%address%% managed by
     *  the client.
     *
     *  If the %%address%% is a number, it is used as an index in the
     *  the accounts from [[listAccounts]].
     *
     *  This can only be used on clients which manage accounts (such as
     *  Geth with imported account or MetaMask).
     *
     *  Throws if the account doesn't exist.
     */
  }, {
    key: "getSigner",
    value: function () {
      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee146(address) {
        var accountsPromise, _accounts, _yield$resolvePropert10, accounts, _iterator42, _step42, account;
        return _regeneratorRuntime().wrap(function _callee146$(_context146) {
          while (1) switch (_context146.prev = _context146.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              accountsPromise = this.send("eth_accounts", []); // Account index
              if (!(typeof address === "number")) {
                _context146.next = 9;
                break;
              }
              _context146.next = 5;
              return accountsPromise;
            case 5:
              _accounts = _context146.sent;
              if (!(address >= _accounts.length)) {
                _context146.next = 8;
                break;
              }
              throw new Error("no such account");
            case 8:
              return _context146.abrupt("return", new JsonRpcSigner(this, _accounts[address]));
            case 9:
              _context146.next = 11;
              return resolveProperties({
                network: this.getNetwork(),
                accounts: accountsPromise
              });
            case 11:
              _yield$resolvePropert10 = _context146.sent;
              accounts = _yield$resolvePropert10.accounts;
              // Account address
              address = getAddress(address);
              _iterator42 = _createForOfIteratorHelper(accounts);
              _context146.prev = 15;
              _iterator42.s();
            case 17:
              if ((_step42 = _iterator42.n()).done) {
                _context146.next = 23;
                break;
              }
              account = _step42.value;
              if (!(getAddress(account) === account)) {
                _context146.next = 21;
                break;
              }
              return _context146.abrupt("return", new JsonRpcSigner(this, account));
            case 21:
              _context146.next = 17;
              break;
            case 23:
              _context146.next = 28;
              break;
            case 25:
              _context146.prev = 25;
              _context146.t0 = _context146["catch"](15);
              _iterator42.e(_context146.t0);
            case 28:
              _context146.prev = 28;
              _iterator42.f();
              return _context146.finish(28);
            case 31:
              throw new Error("invalid account");
            case 32:
            case "end":
              return _context146.stop();
          }
        }, _callee146, this, [[15, 25, 28, 31]]);
      }));
      function getSigner(_x207) {
        return _getSigner.apply(this, arguments);
      }
      return getSigner;
    }()
  }]);
  return JsonRpcApiProvider;
}(AbstractProvider);
exports.JsonRpcApiProvider = JsonRpcApiProvider;
function _scheduleDrain2() {
  var _this107 = this;
  if (_classPrivateFieldGet(this, _drainTimer)) {
    return;
  }
  // If we aren't using batching, no hard in sending it immeidately
  var stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  _classPrivateFieldSet(this, _drainTimer, setTimeout(function () {
    _classPrivateFieldSet(_this107, _drainTimer, null);
    var payloads = _classPrivateFieldGet(_this107, _payloads);
    _classPrivateFieldSet(_this107, _payloads, []);
    var _loop10 = function _loop10() {
      // Create payload batches that satisfy our batch constraints
      var batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === _classPrivateFieldGet(_this107, _options2).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        var _bytes7 = JSON.stringify(batch.map(function (p) {
          return p.payload;
        }));
        if (_bytes7.length > _classPrivateFieldGet(_this107, _options2).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      // Process the result to each payload
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee218() {
        var payload, result, _loop11, _i97, _batch, _ret4, _i98, _batch2, reject;
        return _regeneratorRuntime().wrap(function _callee218$(_context221) {
          while (1) switch (_context221.prev = _context221.next) {
            case 0:
              payload = batch.length === 1 ? batch[0].payload : batch.map(function (p) {
                return p.payload;
              });
              _this107.emit("debug", {
                action: "sendRpcPayload",
                payload: payload
              });
              _context221.prev = 2;
              _context221.next = 5;
              return _this107._send(payload);
            case 5:
              result = _context221.sent;
              _this107.emit("debug", {
                action: "receiveRpcResult",
                result: result
              });
              // Process results in batch order
              _loop11 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop11() {
                var _batch$_i, resolve, reject, payload, resp;
                return _regeneratorRuntime().wrap(function _loop11$(_context220) {
                  while (1) switch (_context220.prev = _context220.next) {
                    case 0:
                      _batch$_i = _batch[_i97], resolve = _batch$_i.resolve, reject = _batch$_i.reject, payload = _batch$_i.payload;
                      // Find the matching result
                      resp = result.filter(function (r) {
                        return r.id === payload.id;
                      })[0]; // No result; the node failed us in unexpected ways
                      if (!(resp == null)) {
                        _context220.next = 4;
                        break;
                      }
                      return _context220.abrupt("return", {
                        v: reject(new Error("@TODO: no result"))
                      });
                    case 4:
                      if (!("error" in resp)) {
                        _context220.next = 6;
                        break;
                      }
                      return _context220.abrupt("return", {
                        v: reject(_this107.getRpcError(payload, resp))
                      });
                    case 6:
                      // All good; send the result
                      resolve(resp.result);
                    case 7:
                    case "end":
                      return _context220.stop();
                  }
                }, _loop11);
              });
              _i97 = 0, _batch = batch;
            case 9:
              if (!(_i97 < _batch.length)) {
                _context221.next = 17;
                break;
              }
              return _context221.delegateYield(_loop11(), "t0", 11);
            case 11:
              _ret4 = _context221.t0;
              if (!(_typeof(_ret4) === "object")) {
                _context221.next = 14;
                break;
              }
              return _context221.abrupt("return", _ret4.v);
            case 14:
              _i97++;
              _context221.next = 9;
              break;
            case 17:
              _context221.next = 23;
              break;
            case 19:
              _context221.prev = 19;
              _context221.t1 = _context221["catch"](2);
              _this107.emit("debug", {
                action: "receiveRpcError",
                error: _context221.t1
              });
              for (_i98 = 0, _batch2 = batch; _i98 < _batch2.length; _i98++) {
                reject = _batch2[_i98].reject;
                // @TODO: augment the error with the payload
                reject(_context221.t1);
              }
            case 23:
            case "end":
              return _context221.stop();
          }
        }, _callee218, null, [[2, 19]]);
      }))();
    };
    while (payloads.length) {
      _loop10();
    }
  }, stallTime));
}
var _pollingInterval = /*#__PURE__*/new WeakMap();
var JsonRpcApiPollingProvider = /*#__PURE__*/function (_JsonRpcApiProvider) {
  _inherits(JsonRpcApiPollingProvider, _JsonRpcApiProvider);
  var _super50 = _createSuper(JsonRpcApiPollingProvider);
  function JsonRpcApiPollingProvider(network, options) {
    var _this71;
    _classCallCheck(this, JsonRpcApiPollingProvider);
    _this71 = _super50.call(this, network, options);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this71), _pollingInterval, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this71), _pollingInterval, 4000);
    return _this71;
  }
  _createClass(JsonRpcApiPollingProvider, [{
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      var subscriber = _get(_getPrototypeOf(JsonRpcApiPollingProvider.prototype), "_getSubscriber", this).call(this, sub);
      if (isPollable(subscriber)) {
        subscriber.pollingInterval = _classPrivateFieldGet(this, _pollingInterval);
      }
      return subscriber;
    }
    /**
     *  The polling interval (default: 4000 ms)
     */
  }, {
    key: "pollingInterval",
    get: function get() {
      return _classPrivateFieldGet(this, _pollingInterval);
    },
    set: function set(value) {
      var _this72 = this;
      if (!Number.isInteger(value) || value < 0) {
        throw new Error("invalid interval");
      }
      _classPrivateFieldSet(this, _pollingInterval, value);
      this._forEachSubscriber(function (sub) {
        if (isPollable(sub)) {
          sub.pollingInterval = _classPrivateFieldGet(_this72, _pollingInterval);
        }
      });
    }
  }]);
  return JsonRpcApiPollingProvider;
}(JsonRpcApiProvider);
/**
 *  The JsonRpcProvider is one of the most common Providers,
 *  which performs all operations over HTTP (or HTTPS) requests.
 *
 *  Events are processed by polling the backend for the current block
 *  number; when it advances, all block-base events are then checked
 *  for updates.
 */
var _connect = /*#__PURE__*/new WeakMap();
var JsonRpcProvider = /*#__PURE__*/function (_JsonRpcApiPollingPro) {
  _inherits(JsonRpcProvider, _JsonRpcApiPollingPro);
  var _super51 = _createSuper(JsonRpcProvider);
  function JsonRpcProvider(url, network, options) {
    var _this73;
    _classCallCheck(this, JsonRpcProvider);
    if (url == null) {
      url = "http:/\/localhost:8545";
    }
    _this73 = _super51.call(this, network, options);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this73), _connect, {
      writable: true,
      value: void 0
    });
    if (typeof url === "string") {
      _classPrivateFieldSet(_assertThisInitialized(_this73), _connect, new FetchRequest(url));
    } else {
      _classPrivateFieldSet(_assertThisInitialized(_this73), _connect, url.clone());
    }
    return _this73;
  }
  _createClass(JsonRpcProvider, [{
    key: "_getConnection",
    value: function _getConnection() {
      return _classPrivateFieldGet(this, _connect).clone();
    }
  }, {
    key: "send",
    value: function () {
      var _send5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee147(method, params) {
        return _regeneratorRuntime().wrap(function _callee147$(_context147) {
          while (1) switch (_context147.prev = _context147.next) {
            case 0:
              _context147.next = 2;
              return this._start();
            case 2:
              _context147.next = 4;
              return _get(_getPrototypeOf(JsonRpcProvider.prototype), "send", this).call(this, method, params);
            case 4:
              return _context147.abrupt("return", _context147.sent);
            case 5:
            case "end":
              return _context147.stop();
          }
        }, _callee147, this);
      }));
      function send(_x208, _x209) {
        return _send5.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee148(payload) {
        var request, response, resp;
        return _regeneratorRuntime().wrap(function _callee148$(_context148) {
          while (1) switch (_context148.prev = _context148.next) {
            case 0:
              // Configure a POST connection for the requested method
              request = this._getConnection();
              request.body = JSON.stringify(payload);
              request.setHeader("content-type", "application/json");
              _context148.next = 5;
              return request.send();
            case 5:
              response = _context148.sent;
              response.assertOk();
              resp = response.bodyJson;
              if (!Array.isArray(resp)) {
                resp = [resp];
              }
              return _context148.abrupt("return", resp);
            case 10:
            case "end":
              return _context148.stop();
          }
        }, _callee148, this);
      }));
      function _send(_x210) {
        return _send6.apply(this, arguments);
      }
      return _send;
    }()
  }]);
  return JsonRpcProvider;
}(JsonRpcApiPollingProvider);
exports.JsonRpcProvider = JsonRpcProvider;
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  // These *are* the droids we're looking for.
  if (typeof value.message === "string" && value.message.match("reverted") && isHexString(value.data)) {
    return {
      message: value.message,
      data: value.data
    };
  }
  // Spelunk further...
  if (_typeof(value) === "object") {
    for (var key in value) {
      var result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  // Might be a JSON string we can further descend...
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {}
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  // These *are* the droids we're looking for.
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  // Spelunk further...
  if (_typeof(value) === "object") {
    for (var key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  // Might be a JSON string we can further descend...
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {}
  }
}
function spelunkMessage(value) {
  var result = [];
  _spelunkMessage(value, result);
  return result;
}

/**
 *  [[link-ankr]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Polygon (``matic``)
 *  - Arbitrum (``arbitrum``)
 *
 *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]
 */
var defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost$4(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
  }
  assertArgument(false, "unsupported network", "network", name);
}
/**
 *  The **AnkrProvider** connects to the [[link-ankr]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-ankr-signup).
 */
var AnkrProvider = /*#__PURE__*/function (_JsonRpcProvider) {
  _inherits(AnkrProvider, _JsonRpcProvider);
  var _super52 = _createSuper(AnkrProvider);
  /**
   *  The API key for the Ankr connection.
   */

  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  function AnkrProvider(_network, apiKey) {
    var _this74;
    _classCallCheck(this, AnkrProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    // Ankr does not support filterId, so we force polling
    var options = {
      polling: true,
      staticNetwork: network
    };
    var request = AnkrProvider.getRequest(network, apiKey);
    _this74 = _super52.call(this, request, network, options);
    _defineProperty(_assertThisInitialized(_this74), "apiKey", void 0);
    defineProperties(_assertThisInitialized(_this74), {
      apiKey: apiKey
    });
    return _this74;
  }
  _createClass(AnkrProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new AnkrProvider(chainId, this.apiKey);
      } catch (error) {}
      return _get(_getPrototypeOf(AnkrProvider.prototype), "_getProvider", this).call(this, chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%apiKey%%.
     */
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, error) {
      if (payload.method === "eth_sendRawTransaction") {
        if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
          error.error.message = "replacement transaction underpriced";
        }
      }
      return _get(_getPrototypeOf(AnkrProvider.prototype), "getRpcError", this).call(this, payload, error);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === defaultApiKey$1;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey$1;
      }
      var request = new FetchRequest("https://".concat(getHost$4(network.name), "/").concat(apiKey));
      request.allowGzip = true;
      if (apiKey === defaultApiKey$1) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref35 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee149(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee149$(_context149) {
              while (1) switch (_context149.prev = _context149.next) {
                case 0:
                  showThrottleMessage("AnkrProvider");
                  return _context149.abrupt("return", true);
                case 2:
                case "end":
                  return _context149.stop();
              }
            }, _callee149);
          }));
          return function (_x211, _x212, _x213) {
            return _ref35.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
  return AnkrProvider;
}(JsonRpcProvider);
/**
 *  About Alchemy
 *
 *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]
 */
exports.AnkrProvider = AnkrProvider;
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost$3(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "maticmum":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
/**
 *  The **AlchemyProvider** connects to the [[link-alchemy]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-alchemy-signup).
 *
 *  @_docloc: api/providers/thirdparty
 */
var AlchemyProvider = /*#__PURE__*/function (_JsonRpcProvider2) {
  _inherits(AlchemyProvider, _JsonRpcProvider2);
  var _super53 = _createSuper(AlchemyProvider);
  function AlchemyProvider(_network, apiKey) {
    var _this75;
    _classCallCheck(this, AlchemyProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    var request = AlchemyProvider.getRequest(network, apiKey);
    _this75 = _super53.call(this, request, network, {
      staticNetwork: network
    });
    _defineProperty(_assertThisInitialized(_this75), "apiKey", void 0);
    defineProperties(_assertThisInitialized(_this75), {
      apiKey: apiKey
    });
    return _this75;
  }
  _createClass(AlchemyProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new AlchemyProvider(chainId, this.apiKey);
      } catch (error) {}
      return _get(_getPrototypeOf(AlchemyProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "_perform",
    value: function () {
      var _perform5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee150(req) {
        var _yield$resolvePropert11, trace, tx, data, error;
        return _regeneratorRuntime().wrap(function _callee150$(_context150) {
          while (1) switch (_context150.prev = _context150.next) {
            case 0:
              if (!(req.method === "getTransactionResult")) {
                _context150.next = 14;
                break;
              }
              _context150.next = 3;
              return resolveProperties({
                trace: this.send("trace_transaction", [req.hash]),
                tx: this.getTransaction(req.hash)
              });
            case 3:
              _yield$resolvePropert11 = _context150.sent;
              trace = _yield$resolvePropert11.trace;
              tx = _yield$resolvePropert11.tx;
              if (!(trace == null || tx == null)) {
                _context150.next = 8;
                break;
              }
              return _context150.abrupt("return", null);
            case 8:
              error = false;
              try {
                data = trace[0].result.output;
                error = trace[0].error === "Reverted";
              } catch (error) {}
              if (!data) {
                _context150.next = 13;
                break;
              }
              assert$1(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                action: "getTransactionResult",
                data: data,
                reason: null,
                transaction: tx,
                invocation: null,
                revert: null // @TODO
              });
              return _context150.abrupt("return", data);
            case 13:
              assert$1(false, "could not parse trace result", "BAD_DATA", {
                value: trace
              });
            case 14:
              _context150.next = 16;
              return _get(_getPrototypeOf(AlchemyProvider.prototype), "_perform", this).call(this, req);
            case 16:
              return _context150.abrupt("return", _context150.sent);
            case 17:
            case "end":
              return _context150.stop();
          }
        }, _callee150, this);
      }));
      function _perform(_x214) {
        return _perform5.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey;
      }
      var request = new FetchRequest("https://".concat(getHost$3(network.name), "/v2/").concat(apiKey));
      request.allowGzip = true;
      if (apiKey === defaultApiKey) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref36 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee151(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee151$(_context151) {
              while (1) switch (_context151.prev = _context151.next) {
                case 0:
                  showThrottleMessage("alchemy");
                  return _context151.abrupt("return", true);
                case 2:
                case "end":
                  return _context151.stop();
              }
            }, _callee151);
          }));
          return function (_x215, _x216, _x217) {
            return _ref36.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
  return AlchemyProvider;
}(JsonRpcProvider);
/**
 *  About Cloudflare
 *
 *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]
 */
/**
 *  About Cloudflare...
 */
exports.AlchemyProvider = AlchemyProvider;
var CloudflareProvider = /*#__PURE__*/function (_JsonRpcProvider3) {
  _inherits(CloudflareProvider, _JsonRpcProvider3);
  var _super54 = _createSuper(CloudflareProvider);
  function CloudflareProvider(_network) {
    _classCallCheck(this, CloudflareProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    assertArgument(network.name === "mainnet", "unsupported network", "network", _network);
    return _super54.call(this, "https:/\/cloudflare-eth.com/", network, {
      staticNetwork: network
    });
  }
  return _createClass(CloudflareProvider);
}(JsonRpcProvider);
/**
 *  [[link-etherscan]] provides a third-party service for connecting to
 *  various blockchains over a combination of JSON-RPC and custom API
 *  endpoints.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``maticmum``)
 *
 *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]
 */
exports.CloudflareProvider = CloudflareProvider;
var THROTTLE = 2000;
function isPromise(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
/**
 *  A Network can include an **EtherscanPlugin** to provide
 *  a custom base URL.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
var EtherscanPlugin = /*#__PURE__*/function (_NetworkPlugin4) {
  _inherits(EtherscanPlugin, _NetworkPlugin4);
  var _super55 = _createSuper(EtherscanPlugin);
  /**
   *  The Etherscan API base URL.
   */

  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  function EtherscanPlugin(baseUrl) {
    var _this76;
    _classCallCheck(this, EtherscanPlugin);
    _this76 = _super55.call(this, EtherscanPluginId);
    _defineProperty(_assertThisInitialized(_this76), "baseUrl", void 0);
    defineProperties(_assertThisInitialized(_this76), {
      baseUrl: baseUrl
    });
    return _this76;
  }
  _createClass(EtherscanPlugin, [{
    key: "clone",
    value: function clone() {
      return new EtherscanPlugin(this.baseUrl);
    }
  }]);
  return EtherscanPlugin;
}(NetworkPlugin);
var nextId = 1;
/**
 *  The **EtherscanBaseProvider** is the super-class of
 *  [[EtherscanProvider]], which should generally be used instead.
 *
 *  Since the **EtherscanProvider** includes additional code for
 *  [[Contract]] access, in //rare cases// that contracts are not
 *  used, this class can reduce code size.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
var _plugin = /*#__PURE__*/new WeakMap();
var EtherscanProvider = /*#__PURE__*/function (_AbstractProvider2) {
  _inherits(EtherscanProvider, _AbstractProvider2);
  var _super56 = _createSuper(EtherscanProvider);
  /**
   *  The connected network.
   */

  /**
   *  The API key or null if using the community provided bandwidth.
   */

  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  function EtherscanProvider(_network, _apiKey) {
    var _this77;
    _classCallCheck(this, EtherscanProvider);
    var apiKey = _apiKey != null ? _apiKey : null;
    _this77 = _super56.call(this);
    _defineProperty(_assertThisInitialized(_this77), "network", void 0);
    _defineProperty(_assertThisInitialized(_this77), "apiKey", void 0);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this77), _plugin, {
      writable: true,
      value: void 0
    });
    var network = Network.from(_network);
    _classPrivateFieldSet(_assertThisInitialized(_this77), _plugin, network.getPlugin(EtherscanPluginId));
    defineProperties(_assertThisInitialized(_this77), {
      apiKey: apiKey,
      network: network
    });
    // Test that the network is supported by Etherscan
    _this77.getBaseUrl();
    return _this77;
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  _createClass(EtherscanProvider, [{
    key: "getBaseUrl",
    value: function getBaseUrl() {
      if (_classPrivateFieldGet(this, _plugin)) {
        return _classPrivateFieldGet(this, _plugin).baseUrl;
      }
      switch (this.network.name) {
        case "mainnet":
          return "https:/\/api.etherscan.io";
        case "goerli":
          return "https:/\/api-goerli.etherscan.io";
        case "sepolia":
          return "https:/\/api-sepolia.etherscan.io";
        case "arbitrum":
          return "https:/\/api.arbiscan.io";
        case "arbitrum-goerli":
          return "https:/\/api-goerli.arbiscan.io";
        case "matic":
          return "https:/\/api.polygonscan.com";
        case "maticmum":
          return "https:/\/api-testnet.polygonscan.com";
        case "optimism":
          return "https:/\/api-optimistic.etherscan.io";
        case "optimism-goerli":
          return "https:/\/api-goerli-optimistic.etherscan.io";
        default:
      }
      assertArgument(false, "unsupported network", "network", this.network);
    }
    /**
     *  Returns the URL for the %%module%% and %%params%%.
     */
  }, {
    key: "getUrl",
    value: function getUrl(module, params) {
      var query = Object.keys(params).reduce(function (accum, key) {
        var value = params[key];
        if (value != null) {
          accum += "&".concat(key, "=").concat(value);
        }
        return accum;
      }, "");
      var apiKey = this.apiKey ? "&apikey=".concat(this.apiKey) : "";
      return "".concat(this.getBaseUrl(), "/api?module=").concat(module).concat(query).concat(apiKey);
    }
    /**
     *  Returns the URL for using POST requests.
     */
  }, {
    key: "getPostUrl",
    value: function getPostUrl() {
      return "".concat(this.getBaseUrl(), "/api");
    }
    /**
     *  Returns the parameters for using POST requests.
     */
  }, {
    key: "getPostData",
    value: function getPostData(module, params) {
      params.module = module;
      params.apikey = this.apiKey;
      return params;
    }
  }, {
    key: "detectNetwork",
    value: function () {
      var _detectNetwork3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee152() {
        return _regeneratorRuntime().wrap(function _callee152$(_context152) {
          while (1) switch (_context152.prev = _context152.next) {
            case 0:
              return _context152.abrupt("return", this.network);
            case 1:
            case "end":
              return _context152.stop();
          }
        }, _callee152, this);
      }));
      function detectNetwork() {
        return _detectNetwork3.apply(this, arguments);
      }
      return detectNetwork;
    }()
    /**
     *  Resolves to the result of calling %%module%% with %%params%%.
     *
     *  If %%post%%, the request is made as a POST request.
     */
  }, {
    key: "fetch",
    value: function () {
      var _fetch3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee154(module, params, post) {
        var _this78 = this;
        var id, url, payload, request, response, result;
        return _regeneratorRuntime().wrap(function _callee154$(_context154) {
          while (1) switch (_context154.prev = _context154.next) {
            case 0:
              id = nextId++;
              url = post ? this.getPostUrl() : this.getUrl(module, params);
              payload = post ? this.getPostData(module, params) : null;
              this.emit("debug", {
                action: "sendRequest",
                id: id,
                url: url,
                payload: payload
              });
              request = new FetchRequest(url);
              request.setThrottleParams({
                slotInterval: 1000
              });
              request.retryFunc = function (req, resp, attempt) {
                if (_this78.isCommunityResource()) {
                  showThrottleMessage("Etherscan");
                }
                return Promise.resolve(true);
              };
              request.processFunc = /*#__PURE__*/function () {
                var _ref37 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee153(request, response) {
                  var result, throttle;
                  return _regeneratorRuntime().wrap(function _callee153$(_context153) {
                    while (1) switch (_context153.prev = _context153.next) {
                      case 0:
                        result = response.hasBody() ? JSON.parse(toUtf8String(response.body)) : {};
                        throttle = (typeof result.result === "string" ? result.result : "").toLowerCase().indexOf("rate limit") >= 0;
                        if (module === "proxy") {
                          // This JSON response indicates we are being throttled
                          if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                            _this78.emit("debug", {
                              action: "receiveError",
                              id: id,
                              reason: "proxy-NOTOK",
                              error: result
                            });
                            response.throwThrottleError(result.result, THROTTLE);
                          }
                        } else {
                          if (throttle) {
                            _this78.emit("debug", {
                              action: "receiveError",
                              id: id,
                              reason: "null result",
                              error: result.result
                            });
                            response.throwThrottleError(result.result, THROTTLE);
                          }
                        }
                        return _context153.abrupt("return", response);
                      case 4:
                      case "end":
                        return _context153.stop();
                    }
                  }, _callee153);
                }));
                return function (_x221, _x222) {
                  return _ref37.apply(this, arguments);
                };
              }();
              if (payload) {
                request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                request.body = Object.keys(payload).map(function (k) {
                  return "".concat(k, "=").concat(payload[k]);
                }).join("&");
              }
              _context154.next = 11;
              return request.send();
            case 11:
              response = _context154.sent;
              try {
                response.assertOk();
              } catch (error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  error: error,
                  reason: "assertOk"
                });
                assert$1(false, "response error", "SERVER_ERROR", {
                  request: request,
                  response: response
                });
              }
              if (!response.hasBody()) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  error: "missing body",
                  reason: "null body"
                });
                assert$1(false, "missing response", "SERVER_ERROR", {
                  request: request,
                  response: response
                });
              }
              result = JSON.parse(toUtf8String(response.body));
              if (!(module === "proxy")) {
                _context154.next = 22;
                break;
              }
              if (result.jsonrpc != "2.0") {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "invalid JSON-RPC"
                });
                assert$1(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              if (result.error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "JSON-RPC error"
                });
                assert$1(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context154.abrupt("return", result.result);
            case 22:
              if (!(result.status == 0 && (result.message === "No records found" || result.message === "No transactions found"))) {
                _context154.next = 25;
                break;
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context154.abrupt("return", result.result);
            case 25:
              if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result
                });
                assert$1(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context154.abrupt("return", result.result);
            case 28:
            case "end":
              return _context154.stop();
          }
        }, _callee154, this);
      }));
      function fetch(_x218, _x219, _x220) {
        return _fetch3.apply(this, arguments);
      }
      return fetch;
    }()
    /**
     *  Returns %%transaction%% normalized for the Etherscan API.
     */
  }, {
    key: "_getTransactionPostData",
    value: function _getTransactionPostData(transaction) {
      var result = {};
      for (var key in transaction) {
        if (transaction[key] == null) {
          continue;
        }
        var value = transaction[key];
        if (key === "type" && value === 0) {
          continue;
        }
        // Quantity-types require no leading zero, unless 0
        if ({
          type: true,
          gasLimit: true,
          gasPrice: true,
          maxFeePerGs: true,
          maxPriorityFeePerGas: true,
          nonce: true,
          value: true
        }[key]) {
          value = toQuantity(value);
        } else if (key === "accessList") {
          value = "[" + accessListify(value).map(function (set) {
            return "{address:\"".concat(set.address, "\",storageKeys:[\"").concat(set.storageKeys.join('","'), "\"]}");
          }).join(",") + "]";
        } else {
          value = hexlify(value);
        }
        result[key] = value;
      }
      return result;
    }
    /**
     *  Throws the normalized Etherscan error.
     */
  }, {
    key: "_checkError",
    value: function _checkError(req, error, transaction) {
      // Pull any message out if, possible
      var message = "";
      if (isError(error, "SERVER_ERROR")) {
        // Check for an error emitted by a proxy call
        try {
          message = error.info.result.error.message;
        } catch (e) {}
        if (!message) {
          try {
            message = error.info.message;
          } catch (e) {}
        }
      }
      if (req.method === "estimateGas") {
        if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
          assert$1(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: req.transaction
          });
        }
      }
      if (req.method === "call" || req.method === "estimateGas") {
        if (message.match(/execution reverted/i)) {
          var data = "";
          try {
            data = error.info.result.error.data;
          } catch (error) {}
          var e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
          e.info = {
            request: req,
            error: error
          };
          throw e;
        }
      }
      if (message) {
        if (req.method === "broadcastTransaction") {
          var _transaction = Transaction.from(req.signedTransaction);
          if (message.match(/replacement/i) && message.match(/underpriced/i)) {
            assert$1(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
              transaction: _transaction
            });
          }
          if (message.match(/insufficient funds/)) {
            assert$1(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction: _transaction
            });
          }
          if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
            assert$1(false, "nonce has already been used", "NONCE_EXPIRED", {
              transaction: _transaction
            });
          }
        }
      }
      // Something we could not process
      throw error;
    }
  }, {
    key: "_detectNetwork",
    value: function () {
      var _detectNetwork4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee155() {
        return _regeneratorRuntime().wrap(function _callee155$(_context155) {
          while (1) switch (_context155.prev = _context155.next) {
            case 0:
              return _context155.abrupt("return", this.network);
            case 1:
            case "end":
              return _context155.stop();
          }
        }, _callee155, this);
      }));
      function _detectNetwork() {
        return _detectNetwork4.apply(this, arguments);
      }
      return _detectNetwork;
    }()
  }, {
    key: "_perform",
    value: function () {
      var _perform6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee156(req) {
        var _this79 = this;
        var postData, _postData;
        return _regeneratorRuntime().wrap(function _callee156$(_context156) {
          while (1) switch (_context156.prev = _context156.next) {
            case 0:
              _context156.t0 = req.method;
              _context156.next = _context156.t0 === "chainId" ? 3 : _context156.t0 === "getBlockNumber" ? 4 : _context156.t0 === "getGasPrice" ? 5 : _context156.t0 === "getBalance" ? 6 : _context156.t0 === "getTransactionCount" ? 7 : _context156.t0 === "getCode" ? 8 : _context156.t0 === "getStorage" ? 9 : _context156.t0 === "broadcastTransaction" ? 10 : _context156.t0 === "getBlock" ? 11 : _context156.t0 === "getTransaction" ? 14 : _context156.t0 === "getTransactionReceipt" ? 15 : _context156.t0 === "call" ? 16 : _context156.t0 === "estimateGas" ? 30 : 42;
              break;
            case 3:
              return _context156.abrupt("return", this.network.chainId);
            case 4:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_blockNumber"
              }));
            case 5:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_gasPrice"
              }));
            case 6:
              return _context156.abrupt("return", this.fetch("account", {
                action: "balance",
                address: req.address,
                tag: req.blockTag
              }));
            case 7:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: req.address,
                tag: req.blockTag
              }));
            case 8:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getCode",
                address: req.address,
                tag: req.blockTag
              }));
            case 9:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: req.address,
                position: req.position,
                tag: req.blockTag
              }));
            case 10:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: req.signedTransaction
              }, true)["catch"](function (error) {
                return _this79._checkError(req, error, req.signedTransaction);
              }));
            case 11:
              if (!("blockTag" in req)) {
                _context156.next = 13;
                break;
              }
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: req.blockTag,
                "boolean": req.includeTransactions ? "true" : "false"
              }));
            case 13:
              assert$1(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                operation: "getBlock(blockHash)"
              });
            case 14:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: req.hash
              }));
            case 15:
              return _context156.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: req.hash
              }));
            case 16:
              if (!(req.blockTag !== "latest")) {
                _context156.next = 18;
                break;
              }
              throw new Error("EtherscanProvider does not support blockTag for call");
            case 18:
              postData = this._getTransactionPostData(req.transaction);
              postData.module = "proxy";
              postData.action = "eth_call";
              _context156.prev = 21;
              _context156.next = 24;
              return this.fetch("proxy", postData, true);
            case 24:
              return _context156.abrupt("return", _context156.sent);
            case 27:
              _context156.prev = 27;
              _context156.t1 = _context156["catch"](21);
              return _context156.abrupt("return", this._checkError(req, _context156.t1, req.transaction));
            case 30:
              _postData = this._getTransactionPostData(req.transaction);
              _postData.module = "proxy";
              _postData.action = "eth_estimateGas";
              _context156.prev = 33;
              _context156.next = 36;
              return this.fetch("proxy", _postData, true);
            case 36:
              return _context156.abrupt("return", _context156.sent);
            case 39:
              _context156.prev = 39;
              _context156.t2 = _context156["catch"](33);
              return _context156.abrupt("return", this._checkError(req, _context156.t2, req.transaction));
            case 42:
              return _context156.abrupt("break", 43);
            case 43:
              return _context156.abrupt("return", _get(_getPrototypeOf(EtherscanProvider.prototype), "_perform", this).call(this, req));
            case 44:
            case "end":
              return _context156.stop();
          }
        }, _callee156, this, [[21, 27], [33, 39]]);
      }));
      function _perform(_x223) {
        return _perform6.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "getNetwork",
    value: function () {
      var _getNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee157() {
        return _regeneratorRuntime().wrap(function _callee157$(_context157) {
          while (1) switch (_context157.prev = _context157.next) {
            case 0:
              return _context157.abrupt("return", this.network);
            case 1:
            case "end":
              return _context157.stop();
          }
        }, _callee157, this);
      }));
      function getNetwork() {
        return _getNetwork2.apply(this, arguments);
      }
      return getNetwork;
    }()
    /**
     *  Resolves to the current price of ether.
     *
     *  This returns ``0`` on any network other than ``mainnet``.
     */
  }, {
    key: "getEtherPrice",
    value: function () {
      var _getEtherPrice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee158() {
        return _regeneratorRuntime().wrap(function _callee158$(_context158) {
          while (1) switch (_context158.prev = _context158.next) {
            case 0:
              if (!(this.network.name !== "mainnet")) {
                _context158.next = 2;
                break;
              }
              return _context158.abrupt("return", 0.0);
            case 2:
              _context158.t0 = parseFloat;
              _context158.next = 5;
              return this.fetch("stats", {
                action: "ethprice"
              });
            case 5:
              _context158.t1 = _context158.sent.ethusd;
              return _context158.abrupt("return", (0, _context158.t0)(_context158.t1));
            case 7:
            case "end":
              return _context158.stop();
          }
        }, _callee158, this);
      }));
      function getEtherPrice() {
        return _getEtherPrice.apply(this, arguments);
      }
      return getEtherPrice;
    }()
    /**
     *  Resolves to a [Contract]] for %%address%%, using the
     *  Etherscan API to retreive the Contract ABI.
     */
  }, {
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee159(_address) {
        var address, resp, abi;
        return _regeneratorRuntime().wrap(function _callee159$(_context159) {
          while (1) switch (_context159.prev = _context159.next) {
            case 0:
              address = this._getAddress(_address);
              if (!isPromise(address)) {
                _context159.next = 5;
                break;
              }
              _context159.next = 4;
              return address;
            case 4:
              address = _context159.sent;
            case 5:
              _context159.prev = 5;
              _context159.next = 8;
              return this.fetch("contract", {
                action: "getabi",
                address: address
              });
            case 8:
              resp = _context159.sent;
              abi = JSON.parse(resp);
              return _context159.abrupt("return", new Contract(address, abi, this));
            case 13:
              _context159.prev = 13;
              _context159.t0 = _context159["catch"](5);
              return _context159.abrupt("return", null);
            case 16:
            case "end":
              return _context159.stop();
          }
        }, _callee159, this, [[5, 13]]);
      }));
      function getContract(_x224) {
        return _getContract.apply(this, arguments);
      }
      return getContract;
    }()
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey == null;
    }
  }]);
  return EtherscanProvider;
}(AbstractProvider);
exports.EtherscanProvider = EtherscanProvider;
function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}
;
var _WebSocket = getGlobal().WebSocket;

/**
 *  Generic long-lived socket provider.
 *
 *  Sub-classing notes
 *  - a sub-class MUST call the `_start()` method once connected
 *  - a sub-class MUST override the `_write(string)` method
 *  - a sub-class MUST call `_processMessage(string)` for each message
 *
 *  @_subsection: api/providers/abstract-provider
 */
var _provider5 = /*#__PURE__*/new WeakMap();
var _filter6 = /*#__PURE__*/new WeakMap();
var _filterId = /*#__PURE__*/new WeakMap();
var _paused = /*#__PURE__*/new WeakMap();
var _emitPromise = /*#__PURE__*/new WeakMap();
var SocketSubscriber = /*#__PURE__*/function () {
  function SocketSubscriber(provider, filter) {
    _classCallCheck(this, SocketSubscriber);
    _classPrivateFieldInitSpec(this, _provider5, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _filter6, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _filterId, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _paused, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _emitPromise, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _provider5, provider);
    _classPrivateFieldSet(this, _filter6, JSON.stringify(filter));
    _classPrivateFieldSet(this, _filterId, null);
    _classPrivateFieldSet(this, _paused, null);
    _classPrivateFieldSet(this, _emitPromise, null);
  }
  _createClass(SocketSubscriber, [{
    key: "filter",
    get: function get() {
      return JSON.parse(_classPrivateFieldGet(this, _filter6));
    }
  }, {
    key: "start",
    value: function start() {
      var _this80 = this;
      _classPrivateFieldSet(this, _filterId, _classPrivateFieldGet(this, _provider5).send("eth_subscribe", this.filter).then(function (filterId) {
        ;
        _classPrivateFieldGet(_this80, _provider5)._register(filterId, _this80);
        return filterId;
      }));
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this81 = this;
      _classPrivateFieldGet(this, _filterId).then(function (filterId) {
        _classPrivateFieldGet(_this81, _provider5).send("eth_unsubscribe", [filterId]);
      });
      _classPrivateFieldSet(this, _filterId, null);
    }
    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
    //        and resume
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      assert$1(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
        operation: "pause(false)"
      });
      _classPrivateFieldSet(this, _paused, !!dropWhilePaused);
    }
  }, {
    key: "resume",
    value: function resume() {
      _classPrivateFieldSet(this, _paused, null);
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(message) {
      var _this82 = this;
      if (_classPrivateFieldGet(this, _filterId) == null) {
        return;
      }
      if (_classPrivateFieldGet(this, _paused) === null) {
        var emitPromise = _classPrivateFieldGet(this, _emitPromise);
        if (emitPromise == null) {
          emitPromise = this._emit(_classPrivateFieldGet(this, _provider5), message);
        } else {
          emitPromise = emitPromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee160() {
            return _regeneratorRuntime().wrap(function _callee160$(_context160) {
              while (1) switch (_context160.prev = _context160.next) {
                case 0:
                  _context160.next = 2;
                  return _this82._emit(_classPrivateFieldGet(_this82, _provider5), message);
                case 2:
                case "end":
                  return _context160.stop();
              }
            }, _callee160);
          })));
        }
        _classPrivateFieldSet(this, _emitPromise, emitPromise.then(function () {
          if (_classPrivateFieldGet(_this82, _emitPromise) === emitPromise) {
            _classPrivateFieldSet(_this82, _emitPromise, null);
          }
        }));
      }
    }
  }, {
    key: "_emit",
    value: function () {
      var _emit7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee161(provider, message) {
        return _regeneratorRuntime().wrap(function _callee161$(_context161) {
          while (1) switch (_context161.prev = _context161.next) {
            case 0:
              throw new Error("sub-classes must implemente this; _emit");
            case 1:
            case "end":
              return _context161.stop();
          }
        }, _callee161);
      }));
      function _emit(_x225, _x226) {
        return _emit7.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
  return SocketSubscriber;
}();
var SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber) {
  _inherits(SocketBlockSubscriber, _SocketSubscriber);
  var _super57 = _createSuper(SocketBlockSubscriber);
  function SocketBlockSubscriber(provider) {
    _classCallCheck(this, SocketBlockSubscriber);
    return _super57.call(this, provider, ["newHeads"]);
  }
  _createClass(SocketBlockSubscriber, [{
    key: "_emit",
    value: function () {
      var _emit8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee162(provider, message) {
        return _regeneratorRuntime().wrap(function _callee162$(_context162) {
          while (1) switch (_context162.prev = _context162.next) {
            case 0:
              provider.emit("block", parseInt(message.number));
            case 1:
            case "end":
              return _context162.stop();
          }
        }, _callee162);
      }));
      function _emit(_x227, _x228) {
        return _emit8.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
  return SocketBlockSubscriber;
}(SocketSubscriber);
var SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {
  _inherits(SocketPendingSubscriber, _SocketSubscriber2);
  var _super58 = _createSuper(SocketPendingSubscriber);
  function SocketPendingSubscriber(provider) {
    _classCallCheck(this, SocketPendingSubscriber);
    return _super58.call(this, provider, ["newPendingTransactions"]);
  }
  _createClass(SocketPendingSubscriber, [{
    key: "_emit",
    value: function () {
      var _emit9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee163(provider, message) {
        return _regeneratorRuntime().wrap(function _callee163$(_context163) {
          while (1) switch (_context163.prev = _context163.next) {
            case 0:
              provider.emit("pending", message);
            case 1:
            case "end":
              return _context163.stop();
          }
        }, _callee163);
      }));
      function _emit(_x229, _x230) {
        return _emit9.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
  return SocketPendingSubscriber;
}(SocketSubscriber);
var _logFilter = /*#__PURE__*/new WeakMap();
var SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {
  _inherits(SocketEventSubscriber, _SocketSubscriber3);
  var _super59 = _createSuper(SocketEventSubscriber);
  function SocketEventSubscriber(provider, filter) {
    var _this83;
    _classCallCheck(this, SocketEventSubscriber);
    _this83 = _super59.call(this, provider, ["logs", filter]);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this83), _logFilter, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this83), _logFilter, JSON.stringify(filter));
    return _this83;
  }
  _createClass(SocketEventSubscriber, [{
    key: "logFilter",
    get: function get() {
      return JSON.parse(_classPrivateFieldGet(this, _logFilter));
    }
  }, {
    key: "_emit",
    value: function () {
      var _emit10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee164(provider, message) {
        return _regeneratorRuntime().wrap(function _callee164$(_context164) {
          while (1) switch (_context164.prev = _context164.next) {
            case 0:
              provider.emit(_classPrivateFieldGet(this, _logFilter), provider._wrapLog(message, provider._network));
            case 1:
            case "end":
              return _context164.stop();
          }
        }, _callee164, this);
      }));
      function _emit(_x231, _x232) {
        return _emit10.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
  return SocketEventSubscriber;
}(SocketSubscriber);
/**
 *  SocketProvider...
 *
 */
var _callbacks = /*#__PURE__*/new WeakMap();
var _subs2 = /*#__PURE__*/new WeakMap();
var _pending = /*#__PURE__*/new WeakMap();
var SocketProvider = /*#__PURE__*/function (_JsonRpcApiProvider2) {
  _inherits(SocketProvider, _JsonRpcApiProvider2);
  var _super60 = _createSuper(SocketProvider);
  // Maps each filterId to its subscriber

  // If any events come in before a subscriber has finished
  // registering, queue them

  function SocketProvider(network) {
    var _this84;
    _classCallCheck(this, SocketProvider);
    _this84 = _super60.call(this, network, {
      batchMaxCount: 1
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this84), _callbacks, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this84), _subs2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this84), _pending, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this84), _callbacks, new Map());
    _classPrivateFieldSet(_assertThisInitialized(_this84), _subs2, new Map());
    _classPrivateFieldSet(_assertThisInitialized(_this84), _pending, new Map());
    return _this84;
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _createClass(SocketProvider, [{
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      switch (sub.type) {
        case "close":
          return new UnmanagedSubscriber("close");
        case "block":
          return new SocketBlockSubscriber(this);
        case "pending":
          return new SocketPendingSubscriber(this);
        case "event":
          return new SocketEventSubscriber(this, sub.filter);
        case "orphan":
          // Handled auto-matically within AbstractProvider
          // when the log.removed = true
          if (sub.filter.orphan === "drop-log") {
            return new UnmanagedSubscriber("drop-log");
          }
      }
      return _get(_getPrototypeOf(SocketProvider.prototype), "_getSubscriber", this).call(this, sub);
    }
  }, {
    key: "_register",
    value: function _register(filterId, subscriber) {
      _classPrivateFieldGet(this, _subs2).set(filterId, subscriber);
      var pending = _classPrivateFieldGet(this, _pending).get(filterId);
      if (pending) {
        var _iterator43 = _createForOfIteratorHelper(pending),
          _step43;
        try {
          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
            var message = _step43.value;
            subscriber._handleMessage(message);
          }
        } catch (err) {
          _iterator43.e(err);
        } finally {
          _iterator43.f();
        }
        _classPrivateFieldGet(this, _pending)["delete"](filterId);
      }
    }
  }, {
    key: "_send",
    value: function () {
      var _send7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee165(payload) {
        var _this85 = this;
        var promise;
        return _regeneratorRuntime().wrap(function _callee165$(_context165) {
          while (1) switch (_context165.prev = _context165.next) {
            case 0:
              // WebSocket provider doesn't accept batches
              assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
              // @TODO: stringify payloads here and store to prevent mutations
              // Prepare a promise to respond to
              promise = new Promise(function (resolve, reject) {
                _classPrivateFieldGet(_this85, _callbacks).set(payload.id, {
                  payload: payload,
                  resolve: resolve,
                  reject: reject
                });
              }); // Wait until the socket is connected before writing to it
              _context165.next = 4;
              return this._waitUntilReady();
            case 4:
              _context165.next = 6;
              return this._write(JSON.stringify(payload));
            case 6:
              _context165.next = 8;
              return promise;
            case 8:
              _context165.t0 = _context165.sent;
              return _context165.abrupt("return", [_context165.t0]);
            case 10:
            case "end":
              return _context165.stop();
          }
        }, _callee165, this);
      }));
      function _send(_x233) {
        return _send7.apply(this, arguments);
      }
      return _send;
    }() // Sub-classes must call this once they are connected
    /*
    async _start(): Promise<void> {
        if (this.#ready) { return; }
         for (const { payload } of this.#callbacks.values()) {
            await this._write(JSON.stringify(payload));
        }
         this.#ready = (async function() {
            await super._start();
        })();
    }
    */
    // Sub-classes must call this for each message
  }, {
    key: "_processMessage",
    value: function () {
      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee166(message) {
        var result, callback, filterId, subscriber, pending;
        return _regeneratorRuntime().wrap(function _callee166$(_context166) {
          while (1) switch (_context166.prev = _context166.next) {
            case 0:
              result = JSON.parse(message);
              if (!("id" in result)) {
                _context166.next = 10;
                break;
              }
              callback = _classPrivateFieldGet(this, _callbacks).get(result.id);
              if (!(callback == null)) {
                _context166.next = 6;
                break;
              }
              console.log("Weird... Response for not a thing we sent");
              return _context166.abrupt("return");
            case 6:
              _classPrivateFieldGet(this, _callbacks)["delete"](result.id);
              callback.resolve(result);
              /*
                          if ("error" in result) {
                              const { message, code, data } = result.error;
                              const error = makeError(message || "unkonwn error", "SERVER_ERROR", {
                                  request: `ws:${ JSON.stringify(callback.payload) }`,
                                  info: { code, data }
                              });
                              callback.reject(error);
                          } else {
                              callback.resolve(result.result);
                          }
              */
              _context166.next = 11;
              break;
            case 10:
              if (result.method === "eth_subscription") {
                filterId = result.params.subscription;
                subscriber = _classPrivateFieldGet(this, _subs2).get(filterId);
                if (subscriber) {
                  subscriber._handleMessage(result.params.result);
                } else {
                  pending = _classPrivateFieldGet(this, _pending).get(filterId);
                  if (pending == null) {
                    pending = [];
                    _classPrivateFieldGet(this, _pending).set(filterId, pending);
                  }
                  pending.push(result.params.result);
                }
              }
            case 11:
            case "end":
              return _context166.stop();
          }
        }, _callee166, this);
      }));
      function _processMessage(_x234) {
        return _processMessage2.apply(this, arguments);
      }
      return _processMessage;
    }()
  }, {
    key: "_write",
    value: function () {
      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee167(message) {
        return _regeneratorRuntime().wrap(function _callee167$(_context167) {
          while (1) switch (_context167.prev = _context167.next) {
            case 0:
              throw new Error("sub-classes must override this");
            case 1:
            case "end":
              return _context167.stop();
          }
        }, _callee167);
      }));
      function _write(_x235) {
        return _write2.apply(this, arguments);
      }
      return _write;
    }()
  }]);
  return SocketProvider;
}(JsonRpcApiProvider);
exports.SocketProvider = SocketProvider;
var _connect2 = /*#__PURE__*/new WeakMap();
var _websocket = /*#__PURE__*/new WeakMap();
var WebSocketProvider = /*#__PURE__*/function (_SocketProvider) {
  _inherits(WebSocketProvider, _SocketProvider);
  var _super61 = _createSuper(WebSocketProvider);
  function WebSocketProvider(url, network) {
    var _this86;
    _classCallCheck(this, WebSocketProvider);
    _this86 = _super61.call(this, network);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this86), _connect2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this86), _websocket, {
      writable: true,
      value: void 0
    });
    if (typeof url === "string") {
      _classPrivateFieldSet(_assertThisInitialized(_this86), _connect2, function () {
        return new _WebSocket(url);
      });
      _classPrivateFieldSet(_assertThisInitialized(_this86), _websocket, _classPrivateFieldGet(_assertThisInitialized(_this86), _connect2).call(_assertThisInitialized(_this86)));
    } else if (typeof url === "function") {
      _classPrivateFieldSet(_assertThisInitialized(_this86), _connect2, url);
      _classPrivateFieldSet(_assertThisInitialized(_this86), _websocket, url());
    } else {
      _classPrivateFieldSet(_assertThisInitialized(_this86), _connect2, null);
      _classPrivateFieldSet(_assertThisInitialized(_this86), _websocket, url);
    }
    _this86.websocket.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee168() {
      return _regeneratorRuntime().wrap(function _callee168$(_context168) {
        while (1) switch (_context168.prev = _context168.next) {
          case 0:
            _context168.prev = 0;
            _context168.next = 3;
            return _this86._start();
          case 3:
            _this86.resume();
            _context168.next = 9;
            break;
          case 6:
            _context168.prev = 6;
            _context168.t0 = _context168["catch"](0);
            console.log("failed to start WebsocketProvider", _context168.t0);
            // @TODO: now what? Attempt reconnect?
          case 9:
          case "end":
            return _context168.stop();
        }
      }, _callee168, null, [[0, 6]]);
    }));
    _this86.websocket.onmessage = function (message) {
      _this86._processMessage(message.data);
    };
    /*
            this.websocket.onclose = (event) => {
                // @TODO: What event.code should we reconnect on?
                const reconnect = false;
                if (reconnect) {
                    this.pause(true);
                    if (this.#connect) {
                        this.#websocket = this.#connect();
                        this.#websocket.onopen = ...
                        // @TODO: this requires the super class to rebroadcast; move it there
                    }
                    this._reconnect();
                }
            };
    */
    return _this86;
  }
  _createClass(WebSocketProvider, [{
    key: "websocket",
    get: function get() {
      if (_classPrivateFieldGet(this, _websocket) == null) {
        throw new Error("websocket closed");
      }
      return _classPrivateFieldGet(this, _websocket);
    }
  }, {
    key: "_write",
    value: function () {
      var _write3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee169(message) {
        return _regeneratorRuntime().wrap(function _callee169$(_context169) {
          while (1) switch (_context169.prev = _context169.next) {
            case 0:
              this.websocket.send(message);
            case 1:
            case "end":
              return _context169.stop();
          }
        }, _callee169, this);
      }));
      function _write(_x236) {
        return _write3.apply(this, arguments);
      }
      return _write;
    }()
  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee170() {
        return _regeneratorRuntime().wrap(function _callee170$(_context170) {
          while (1) switch (_context170.prev = _context170.next) {
            case 0:
              if (_classPrivateFieldGet(this, _websocket) != null) {
                _classPrivateFieldGet(this, _websocket).close();
                _classPrivateFieldSet(this, _websocket, null);
              }
              _get(_getPrototypeOf(WebSocketProvider.prototype), "destroy", this).call(this);
            case 2:
            case "end":
              return _context170.stop();
          }
        }, _callee170, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }]);
  return WebSocketProvider;
}(SocketProvider);
/**
 *  [[link-infura]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``maticmum``)
 *
 *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]
 */
exports.WebSocketProvider = WebSocketProvider;
var defaultProjectId = "84842078b09946638c03157f83405213";
function getHost$2(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "maticmum":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}
/**
 *  The **InfuraWebSocketProvider** connects to the [[link-infura]]
 *  WebSocket end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
var InfuraWebSocketProvider = /*#__PURE__*/function (_WebSocketProvider) {
  _inherits(InfuraWebSocketProvider, _WebSocketProvider);
  var _super62 = _createSuper(InfuraWebSocketProvider);
  /**
   *  The Project ID for the INFURA connection.
   */

  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */

  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  function InfuraWebSocketProvider(network, projectId) {
    var _this87;
    _classCallCheck(this, InfuraWebSocketProvider);
    var provider = new InfuraProvider(network, projectId);
    var req = provider._getConnection();
    assert$1(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
      operation: "InfuraProvider.getWebSocketProvider()"
    });
    var url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    _this87 = _super62.call(this, url, network);
    _defineProperty(_assertThisInitialized(_this87), "projectId", void 0);
    _defineProperty(_assertThisInitialized(_this87), "projectSecret", void 0);
    defineProperties(_assertThisInitialized(_this87), {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
    return _this87;
  }
  _createClass(InfuraWebSocketProvider, [{
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  }]);
  return InfuraWebSocketProvider;
}(WebSocketProvider);
/**
 *  The **InfuraProvider** connects to the [[link-infura]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
var InfuraProvider = /*#__PURE__*/function (_JsonRpcProvider4) {
  _inherits(InfuraProvider, _JsonRpcProvider4);
  var _super63 = _createSuper(InfuraProvider);
  /**
   *  The Project ID for the INFURA connection.
   */

  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */

  /**
   *  Creates a new **InfuraProvider**.
   */
  function InfuraProvider(_network, projectId, projectSecret) {
    var _this88;
    _classCallCheck(this, InfuraProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    var request = InfuraProvider.getRequest(network, projectId, projectSecret);
    _this88 = _super63.call(this, request, network, {
      staticNetwork: network
    });
    _defineProperty(_assertThisInitialized(_this88), "projectId", void 0);
    _defineProperty(_assertThisInitialized(_this88), "projectSecret", void 0);
    defineProperties(_assertThisInitialized(_this88), {
      projectId: projectId,
      projectSecret: projectSecret
    });
    return _this88;
  }
  _createClass(InfuraProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new InfuraProvider(chainId, this.projectId, this.projectSecret);
      } catch (error) {}
      return _get(_getPrototypeOf(InfuraProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
  }], [{
    key: "getWebSocketProvider",
    value: function getWebSocketProvider(network, projectId) {
      return new InfuraWebSocketProvider(network, projectId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%projectId%% and %%projectSecret%%.
     */
  }, {
    key: "getRequest",
    value: function getRequest(network, projectId, projectSecret) {
      if (projectId == null) {
        projectId = defaultProjectId;
      }
      if (projectSecret == null) {
        projectSecret = null;
      }
      var request = new FetchRequest("https://".concat(getHost$2(network.name), "/v3/").concat(projectId));
      request.allowGzip = true;
      if (projectSecret) {
        request.setCredentials("", projectSecret);
      }
      if (projectId === defaultProjectId) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref40 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee171(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee171$(_context171) {
              while (1) switch (_context171.prev = _context171.next) {
                case 0:
                  showThrottleMessage("InfuraProvider");
                  return _context171.abrupt("return", true);
                case 2:
                case "end":
                  return _context171.stop();
              }
            }, _callee171);
          }));
          return function (_x237, _x238, _x239) {
            return _ref40.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
  return InfuraProvider;
}(JsonRpcProvider);
/**
 *  [[link-quicknode]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``maticmum``)
 *
 *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]
 */
exports.InfuraProvider = InfuraProvider;
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost$1(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    //case "sepolia":
    //    return "sepolia.infura.io";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "maticmum":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
}
/**
 *  The **QuickNodeProvider** connects to the [[link-quicknode]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API token is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-quicknode).
 */
var QuickNodeProvider = /*#__PURE__*/function (_JsonRpcProvider5) {
  _inherits(QuickNodeProvider, _JsonRpcProvider5);
  var _super64 = _createSuper(QuickNodeProvider);
  /**
   *  The API token.
   */

  /**
   *  Creates a new **QuickNodeProvider**.
   */
  function QuickNodeProvider(_network, token) {
    var _this89;
    _classCallCheck(this, QuickNodeProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    var request = QuickNodeProvider.getRequest(network, token);
    _this89 = _super64.call(this, request, network, {
      staticNetwork: network
    });
    _defineProperty(_assertThisInitialized(_this89), "token", void 0);
    defineProperties(_assertThisInitialized(_this89), {
      token: token
    });
    return _this89;
  }
  _createClass(QuickNodeProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new QuickNodeProvider(chainId, this.token);
      } catch (error) {}
      return _get(_getPrototypeOf(QuickNodeProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.token === defaultToken;
    }
    /**
     *  Returns a new request prepared for %%network%% and the
     *  %%token%%.
     */
  }], [{
    key: "getRequest",
    value: function getRequest(network, token) {
      if (token == null) {
        token = defaultToken;
      }
      var request = new FetchRequest("https://".concat(getHost$1(network.name), "/").concat(token));
      request.allowGzip = true;
      //if (projectSecret) { request.setCredentials("", projectSecret); }
      if (token === defaultToken) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref41 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee172(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee172$(_context172) {
              while (1) switch (_context172.prev = _context172.next) {
                case 0:
                  showThrottleMessage("QuickNodeProvider");
                  return _context172.abrupt("return", true);
                case 2:
                case "end":
                  return _context172.stop();
              }
            }, _callee172);
          }));
          return function (_x240, _x241, _x242) {
            return _ref41.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
  return QuickNodeProvider;
}(JsonRpcProvider);
/**
 *  Explain all the nitty-gritty about the **FallbackProvider**.
 *
 *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]
 */
exports.QuickNodeProvider = QuickNodeProvider;
var BN_1 = BigInt("1");
var BN_2 = BigInt("2");
function shuffle(array) {
  for (var _i55 = array.length - 1; _i55 > 0; _i55--) {
    var _j6 = Math.floor(Math.random() * (_i55 + 1));
    var tmp = array[_i55];
    array[_i55] = array[_j6];
    array[_j6] = tmp;
  }
}
function stall$2(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}
function getTime() {
  return new Date().getTime();
}
function stringify(value) {
  return JSON.stringify(value, function (key, value) {
    if (typeof value === "bigint") {
      return {
        type: "bigint",
        value: value.toString()
      };
    }
    return value;
  });
}
;
var defaultConfig = {
  stallTimeout: 400,
  priority: 1,
  weight: 1
};
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0
};
function waitForSync(_x243, _x244) {
  return _waitForSync.apply(this, arguments);
}
function _waitForSync() {
  _waitForSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee220(config, blockNumber) {
    return _regeneratorRuntime().wrap(function _callee220$(_context223) {
      while (1) switch (_context223.prev = _context223.next) {
        case 0:
          if (!(config.blockNumber < 0 || config.blockNumber < blockNumber)) {
            _context223.next = 7;
            break;
          }
          if (!config._updateNumber) {
            config._updateNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee219() {
              var blockNumber;
              return _regeneratorRuntime().wrap(function _callee219$(_context222) {
                while (1) switch (_context222.prev = _context222.next) {
                  case 0:
                    _context222.next = 2;
                    return config.provider.getBlockNumber();
                  case 2:
                    blockNumber = _context222.sent;
                    if (blockNumber > config.blockNumber) {
                      config.blockNumber = blockNumber;
                    }
                    config._updateNumber = null;
                  case 5:
                  case "end":
                    return _context222.stop();
                }
              }, _callee219);
            }))();
          }
          _context223.next = 4;
          return config._updateNumber;
        case 4:
          config.outOfSync++;
          _context223.next = 0;
          break;
        case 7:
        case "end":
          return _context223.stop();
      }
    }, _callee220);
  }));
  return _waitForSync.apply(this, arguments);
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (_typeof(value) === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (_typeof(value)) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object":
      {
        var keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map(function (k) {
          return "".concat(JSON.stringify(k), ":").concat(_normalize(value[k]));
        }).join(",") + "}";
      }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    var error = value.error;
    return {
      tag: _normalize(error),
      value: error
    };
  }
  var result = value.result;
  return {
    tag: _normalize(result),
    value: result
  };
}
// This strategy picks the highest weight result, as long as the weight is
// equal to or greater than quorum
function checkQuorum(quorum, results) {
  var tally = new Map();
  var _iterator44 = _createForOfIteratorHelper(results),
    _step44;
  try {
    for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
      var _step44$value = _step44.value,
        value = _step44$value.value,
        tag = _step44$value.tag,
        weight = _step44$value.weight;
      var _t2 = tally.get(tag) || {
        value: value,
        weight: 0
      };
      _t2.weight += weight;
      tally.set(tag, _t2);
    }
  } catch (err) {
    _iterator44.e(err);
  } finally {
    _iterator44.f();
  }
  var best = null;
  var _iterator45 = _createForOfIteratorHelper(tally.values()),
    _step45;
  try {
    for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
      var _r7 = _step45.value;
      if (_r7.weight >= quorum && (!best || _r7.weight > best.weight)) {
        best = _r7;
      }
    }
  } catch (err) {
    _iterator45.e(err);
  } finally {
    _iterator45.f();
  }
  if (best) {
    return best.value;
  }
  return undefined;
}
function getMedian(quorum, results) {
  var resultWeight = 0;
  var errorMap = new Map();
  var bestError = null;
  var values = [];
  var _iterator46 = _createForOfIteratorHelper(results),
    _step46;
  try {
    for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
      var _step46$value = _step46.value,
        value = _step46$value.value,
        tag = _step46$value.tag,
        weight = _step46$value.weight;
      if (value instanceof Error) {
        var e = errorMap.get(tag) || {
          value: value,
          weight: 0
        };
        e.weight += weight;
        errorMap.set(tag, e);
        if (bestError == null || e.weight > bestError.weight) {
          bestError = e;
        }
      } else {
        values.push(BigInt(value));
        resultWeight += weight;
      }
    }
  } catch (err) {
    _iterator46.e(err);
  } finally {
    _iterator46.f();
  }
  if (resultWeight < quorum) {
    // We have quorum for an error
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    // We do not have quorum for a result
    return undefined;
  }
  // Get the sorted values
  values.sort(function (a, b) {
    return a < b ? -1 : b > a ? 1 : 0;
  });
  var mid = Math.floor(values.length / 2);
  // Odd-length; take the middle value
  if (values.length % 2) {
    return values[mid];
  }
  // Even length; take the ceiling of the mean of the center two values
  return (values[mid - 1] + values[mid] + BN_1) / BN_2;
}
function getAnyResult(quorum, results) {
  // If any value or error meets quorum, that is our preferred result
  var result = checkQuorum(quorum, results);
  if (result !== undefined) {
    return result;
  }
  // Otherwise, do we have any result?
  var _iterator47 = _createForOfIteratorHelper(results),
    _step47;
  try {
    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
      var _r8 = _step47.value;
      if (_r8.value) {
        return _r8.value;
      }
    }
    // Nope!
  } catch (err) {
    _iterator47.e(err);
  } finally {
    _iterator47.f();
  }
  return undefined;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  var tally = new Map();
  var add = function add(result, weight) {
    var t = tally.get(result) || {
      result: result,
      weight: 0
    };
    t.weight += weight;
    tally.set(result, t);
  };
  var _iterator48 = _createForOfIteratorHelper(results),
    _step48;
  try {
    for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
      var _step48$value = _step48.value,
        weight = _step48$value.weight,
        value = _step48$value.value;
      var _r9 = getNumber(value);
      add(_r9 - 1, weight);
      add(_r9, weight);
      add(_r9 + 1, weight);
    }
  } catch (err) {
    _iterator48.e(err);
  } finally {
    _iterator48.f();
  }
  var bestWeight = 0;
  var bestResult = undefined;
  var _iterator49 = _createForOfIteratorHelper(tally.values()),
    _step49;
  try {
    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
      var _step49$value = _step49.value,
        _weight = _step49$value.weight,
        result = _step49$value.result;
      // Use this result, if this result meets quorum and has either:
      // - a better weight
      // - or equal weight, but the result is larger
      if (_weight >= quorum && (_weight > bestWeight || bestResult != null && _weight === bestWeight && result > bestResult)) {
        bestWeight = _weight;
        bestResult = result;
      }
    }
  } catch (err) {
    _iterator49.e(err);
  } finally {
    _iterator49.f();
  }
  return bestResult;
}
/**
 *  A Fallback Provider.
 *
 */
var _configs = /*#__PURE__*/new WeakMap();
var _height = /*#__PURE__*/new WeakMap();
var _initialSyncPromise = /*#__PURE__*/new WeakMap();
var _getNextConfig = /*#__PURE__*/new WeakSet();
var _addRunner = /*#__PURE__*/new WeakSet();
var _initialSync = /*#__PURE__*/new WeakSet();
var _checkQuorum = /*#__PURE__*/new WeakSet();
var _waitForQuorum = /*#__PURE__*/new WeakSet();
var FallbackProvider = /*#__PURE__*/function (_AbstractProvider3) {
  _inherits(FallbackProvider, _AbstractProvider3);
  var _super65 = _createSuper(FallbackProvider);
  function FallbackProvider(providers, _network4) {
    var _this90;
    _classCallCheck(this, FallbackProvider);
    _this90 = _super65.call(this, _network4);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this90), _waitForQuorum);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this90), _checkQuorum);
    // Initializes the blockNumber and network for each runner and
    // blocks until initialized
    _classPrivateMethodInitSpec(_assertThisInitialized(_this90), _initialSync);
    // Adds a new runner (if available) to running.
    _classPrivateMethodInitSpec(_assertThisInitialized(_this90), _addRunner);
    // Grab the next (random) config that is not already part of
    // the running set
    _classPrivateMethodInitSpec(_assertThisInitialized(_this90), _getNextConfig);
    _defineProperty(_assertThisInitialized(_this90), "quorum", void 0);
    _defineProperty(_assertThisInitialized(_this90), "eventQuorum", void 0);
    _defineProperty(_assertThisInitialized(_this90), "eventWorkers", void 0);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this90), _configs, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this90), _height, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this90), _initialSyncPromise, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this90), _configs, providers.map(function (p) {
      if (p instanceof AbstractProvider) {
        return Object.assign({
          provider: p
        }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    }));
    _classPrivateFieldSet(_assertThisInitialized(_this90), _height, -2);
    _classPrivateFieldSet(_assertThisInitialized(_this90), _initialSyncPromise, null);
    _this90.quorum = 2; //Math.ceil(providers.length /  2);
    _this90.eventQuorum = 1;
    _this90.eventWorkers = 1;
    assertArgument(_this90.quorum <= _classPrivateFieldGet(_assertThisInitialized(_this90), _configs).reduce(function (a, c) {
      return a + c.weight;
    }, 0), "quorum exceed provider wieght", "quorum", _this90.quorum);
    return _this90;
  }
  _createClass(FallbackProvider, [{
    key: "providerConfigs",
    get: function get() {
      return _classPrivateFieldGet(this, _configs).map(function (c) {
        var result = Object.assign({}, c);
        for (var key in result) {
          if (key[0] === "_") {
            delete result[key];
          }
        }
        return result;
      });
    }
  }, {
    key: "_detectNetwork",
    value: function () {
      var _detectNetwork5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee173() {
        return _regeneratorRuntime().wrap(function _callee173$(_context173) {
          while (1) switch (_context173.prev = _context173.next) {
            case 0:
              _context173.t0 = Network;
              _context173.t1 = getBigInt;
              _context173.next = 4;
              return this._perform({
                method: "chainId"
              });
            case 4:
              _context173.t2 = _context173.sent;
              _context173.t3 = (0, _context173.t1)(_context173.t2);
              return _context173.abrupt("return", _context173.t0.from.call(_context173.t0, _context173.t3));
            case 7:
            case "end":
              return _context173.stop();
          }
        }, _callee173, this);
      }));
      function _detectNetwork() {
        return _detectNetwork5.apply(this, arguments);
      }
      return _detectNetwork;
    }() // @TODO: Add support to select providers to be the event subscriber
    //_getSubscriber(sub: Subscription): Subscriber {
    //    throw new Error("@TODO");
    //}
  }, {
    key: "_translatePerform",
    value: function () {
      var _translatePerform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee174(provider, req) {
        var block;
        return _regeneratorRuntime().wrap(function _callee174$(_context174) {
          while (1) switch (_context174.prev = _context174.next) {
            case 0:
              _context174.t0 = req.method;
              _context174.next = _context174.t0 === "broadcastTransaction" ? 3 : _context174.t0 === "call" ? 6 : _context174.t0 === "chainId" ? 9 : _context174.t0 === "estimateGas" ? 12 : _context174.t0 === "getBalance" ? 15 : _context174.t0 === "getBlock" ? 18 : _context174.t0 === "getBlockNumber" ? 22 : _context174.t0 === "getCode" ? 25 : _context174.t0 === "getGasPrice" ? 28 : _context174.t0 === "getLogs" ? 31 : _context174.t0 === "getStorage" ? 34 : _context174.t0 === "getTransaction" ? 37 : _context174.t0 === "getTransactionCount" ? 40 : _context174.t0 === "getTransactionReceipt" ? 43 : _context174.t0 === "getTransactionResult" ? 46 : 49;
              break;
            case 3:
              _context174.next = 5;
              return provider.broadcastTransaction(req.signedTransaction);
            case 5:
              return _context174.abrupt("return", _context174.sent);
            case 6:
              _context174.next = 8;
              return provider.call(Object.assign({}, req.transaction, {
                blockTag: req.blockTag
              }));
            case 8:
              return _context174.abrupt("return", _context174.sent);
            case 9:
              _context174.next = 11;
              return provider.getNetwork();
            case 11:
              return _context174.abrupt("return", _context174.sent.chainId);
            case 12:
              _context174.next = 14;
              return provider.estimateGas(req.transaction);
            case 14:
              return _context174.abrupt("return", _context174.sent);
            case 15:
              _context174.next = 17;
              return provider.getBalance(req.address, req.blockTag);
            case 17:
              return _context174.abrupt("return", _context174.sent);
            case 18:
              block = "blockHash" in req ? req.blockHash : req.blockTag;
              _context174.next = 21;
              return provider.getBlock(block, req.includeTransactions);
            case 21:
              return _context174.abrupt("return", _context174.sent);
            case 22:
              _context174.next = 24;
              return provider.getBlockNumber();
            case 24:
              return _context174.abrupt("return", _context174.sent);
            case 25:
              _context174.next = 27;
              return provider.getCode(req.address, req.blockTag);
            case 27:
              return _context174.abrupt("return", _context174.sent);
            case 28:
              _context174.next = 30;
              return provider.getFeeData();
            case 30:
              return _context174.abrupt("return", _context174.sent.gasPrice);
            case 31:
              _context174.next = 33;
              return provider.getLogs(req.filter);
            case 33:
              return _context174.abrupt("return", _context174.sent);
            case 34:
              _context174.next = 36;
              return provider.getStorage(req.address, req.position, req.blockTag);
            case 36:
              return _context174.abrupt("return", _context174.sent);
            case 37:
              _context174.next = 39;
              return provider.getTransaction(req.hash);
            case 39:
              return _context174.abrupt("return", _context174.sent);
            case 40:
              _context174.next = 42;
              return provider.getTransactionCount(req.address, req.blockTag);
            case 42:
              return _context174.abrupt("return", _context174.sent);
            case 43:
              _context174.next = 45;
              return provider.getTransactionReceipt(req.hash);
            case 45:
              return _context174.abrupt("return", _context174.sent);
            case 46:
              _context174.next = 48;
              return provider.getTransactionResult(req.hash);
            case 48:
              return _context174.abrupt("return", _context174.sent);
            case 49:
            case "end":
              return _context174.stop();
          }
        }, _callee174);
      }));
      function _translatePerform(_x245, _x246) {
        return _translatePerform2.apply(this, arguments);
      }
      return _translatePerform;
    }()
  }, {
    key: "_perform",
    value: function () {
      var _perform7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee176(req) {
        var results, _result5, running, _i56, result, _iterator50, _step50, runner;
        return _regeneratorRuntime().wrap(function _callee176$(_context176) {
          while (1) switch (_context176.prev = _context176.next) {
            case 0:
              if (!(req.method === "broadcastTransaction")) {
                _context176.next = 9;
                break;
              }
              _context176.next = 3;
              return Promise.all(_classPrivateFieldGet(this, _configs).map( /*#__PURE__*/function () {
                var _ref43 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee175(_ref42) {
                  var provider, weight, _result4;
                  return _regeneratorRuntime().wrap(function _callee175$(_context175) {
                    while (1) switch (_context175.prev = _context175.next) {
                      case 0:
                        provider = _ref42.provider, weight = _ref42.weight;
                        _context175.prev = 1;
                        _context175.next = 4;
                        return provider._perform(req);
                      case 4:
                        _result4 = _context175.sent;
                        return _context175.abrupt("return", Object.assign(normalizeResult({
                          result: _result4
                        }), {
                          weight: weight
                        }));
                      case 8:
                        _context175.prev = 8;
                        _context175.t0 = _context175["catch"](1);
                        return _context175.abrupt("return", Object.assign(normalizeResult({
                          error: _context175.t0
                        }), {
                          weight: weight
                        }));
                      case 11:
                      case "end":
                        return _context175.stop();
                    }
                  }, _callee175, null, [[1, 8]]);
                }));
                return function (_x248) {
                  return _ref43.apply(this, arguments);
                };
              }()));
            case 3:
              results = _context176.sent;
              _result5 = getAnyResult(this.quorum, results);
              assert$1(_result5 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
                request: "%sub-requests",
                info: {
                  request: req,
                  results: results.map(stringify)
                }
              });
              if (!(_result5 instanceof Error)) {
                _context176.next = 8;
                break;
              }
              throw _result5;
            case 8:
              return _context176.abrupt("return", _result5);
            case 9:
              _context176.next = 11;
              return _classPrivateMethodGet(this, _initialSync, _initialSync2).call(this);
            case 11:
              // Bootstrap enough runners to meet quorum
              running = new Set();
              for (_i56 = 0; _i56 < this.quorum; _i56++) {
                _classPrivateMethodGet(this, _addRunner, _addRunner2).call(this, running, req);
              }
              _context176.next = 15;
              return _classPrivateMethodGet(this, _waitForQuorum, _waitForQuorum2).call(this, running, req);
            case 15:
              result = _context176.sent;
              // Track requests sent to a provider that are still
              // outstanding after quorum has been otherwise found
              _iterator50 = _createForOfIteratorHelper(running);
              try {
                for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                  runner = _step50.value;
                  if (runner.perform && runner.result == null) {
                    runner.config.lateResponses++;
                  }
                }
              } catch (err) {
                _iterator50.e(err);
              } finally {
                _iterator50.f();
              }
              return _context176.abrupt("return", result);
            case 19:
            case "end":
              return _context176.stop();
          }
        }, _callee176, this);
      }));
      function _perform(_x247) {
        return _perform7.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "destroy",
    value: function () {
      var _destroy2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee177() {
        var _iterator51, _step51, provider;
        return _regeneratorRuntime().wrap(function _callee177$(_context177) {
          while (1) switch (_context177.prev = _context177.next) {
            case 0:
              _iterator51 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _configs));
              try {
                for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
                  provider = _step51.value.provider;
                  provider.destroy();
                }
              } catch (err) {
                _iterator51.e(err);
              } finally {
                _iterator51.f();
              }
              _get(_getPrototypeOf(FallbackProvider.prototype), "destroy", this).call(this);
            case 3:
            case "end":
              return _context177.stop();
          }
        }, _callee177, this);
      }));
      function destroy() {
        return _destroy2.apply(this, arguments);
      }
      return destroy;
    }()
  }]);
  return FallbackProvider;
}(AbstractProvider);
exports.FallbackProvider = FallbackProvider;
function _getNextConfig2(running) {
  // @TODO: Maybe do a check here to favour (heavily) providers that
  //        do not require waitForSync and disfavour providers that
  //        seem down-ish or are behaving slowly
  var configs = Array.from(running).map(function (r) {
    return r.config;
  });
  // Shuffle the states, sorted by priority
  var allConfigs = _classPrivateFieldGet(this, _configs).slice();
  shuffle(allConfigs);
  allConfigs.sort(function (a, b) {
    return b.priority - a.priority;
  });
  var _iterator60 = _createForOfIteratorHelper(allConfigs),
    _step60;
  try {
    for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
      var config = _step60.value;
      if (configs.indexOf(config) === -1) {
        return config;
      }
    }
  } catch (err) {
    _iterator60.e(err);
  } finally {
    _iterator60.f();
  }
  return null;
}
function _addRunner2(running, req) {
  var _this108 = this;
  var config = _classPrivateMethodGet(this, _getNextConfig, _getNextConfig2).call(this, running);
  // No runners available
  if (config == null) {
    return null;
  }
  // Create a new runner
  var runner = {
    config: config,
    result: null,
    didBump: false,
    perform: null,
    staller: null
  };
  var now = getTime();
  // Start performing this operation
  runner.perform = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee221() {
    var result, dt;
    return _regeneratorRuntime().wrap(function _callee221$(_context224) {
      while (1) switch (_context224.prev = _context224.next) {
        case 0:
          _context224.prev = 0;
          config.requests++;
          _context224.next = 4;
          return _this108._translatePerform(config.provider, req);
        case 4:
          result = _context224.sent;
          runner.result = {
            result: result
          };
          _context224.next = 12;
          break;
        case 8:
          _context224.prev = 8;
          _context224.t0 = _context224["catch"](0);
          config.errorResponses++;
          runner.result = {
            error: _context224.t0
          };
        case 12:
          dt = getTime() - now;
          config._totalTime += dt;
          config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
          runner.perform = null;
        case 16:
        case "end":
          return _context224.stop();
      }
    }, _callee221, null, [[0, 8]]);
  }))();
  // Start a staller; when this times out, it's time to force
  // kicking off another runner because we are taking too long
  runner.staller = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee222() {
    return _regeneratorRuntime().wrap(function _callee222$(_context225) {
      while (1) switch (_context225.prev = _context225.next) {
        case 0:
          _context225.next = 2;
          return stall$2(config.stallTimeout);
        case 2:
          runner.staller = null;
        case 3:
        case "end":
          return _context225.stop();
      }
    }, _callee222);
  }))();
  running.add(runner);
  return runner;
}
function _initialSync2() {
  return _initialSync3.apply(this, arguments);
}
function _initialSync3() {
  _initialSync3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee240() {
    var _this110 = this;
    var initialSync, _promises;
    return _regeneratorRuntime().wrap(function _callee240$(_context243) {
      while (1) switch (_context243.prev = _context243.next) {
        case 0:
          initialSync = _classPrivateFieldGet(this, _initialSyncPromise);
          if (!initialSync) {
            _promises = [];
            _classPrivateFieldGet(this, _configs).forEach(function (config) {
              _promises.push(waitForSync(config, 0));
              _promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee238() {
                return _regeneratorRuntime().wrap(function _callee238$(_context241) {
                  while (1) switch (_context241.prev = _context241.next) {
                    case 0:
                      _context241.next = 2;
                      return config.provider.getNetwork();
                    case 2:
                      config._network = _context241.sent;
                    case 3:
                    case "end":
                      return _context241.stop();
                  }
                }, _callee238);
              }))());
            });
            _classPrivateFieldSet(this, _initialSyncPromise, initialSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee239() {
              var chainId, _iterator62, _step62, config, network;
              return _regeneratorRuntime().wrap(function _callee239$(_context242) {
                while (1) switch (_context242.prev = _context242.next) {
                  case 0:
                    _context242.next = 2;
                    return Promise.all(_promises);
                  case 2:
                    // Check all the networks match
                    chainId = null;
                    _iterator62 = _createForOfIteratorHelper(_classPrivateFieldGet(_this110, _configs));
                    try {
                      for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
                        config = _step62.value;
                        network = config._network;
                        if (chainId == null) {
                          chainId = network.chainId;
                        } else if (network.chainId !== chainId) {
                          assert$1(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                            operation: "new FallbackProvider"
                          });
                        }
                      }
                    } catch (err) {
                      _iterator62.e(err);
                    } finally {
                      _iterator62.f();
                    }
                  case 5:
                  case "end":
                    return _context242.stop();
                }
              }, _callee239);
            }))());
          }
          _context243.next = 4;
          return initialSync;
        case 4:
        case "end":
          return _context243.stop();
      }
    }, _callee240, this);
  }));
  return _initialSync3.apply(this, arguments);
}
function _checkQuorum2(_x304, _x305) {
  return _checkQuorum3.apply(this, arguments);
}
function _checkQuorum3() {
  _checkQuorum3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee241(running, req) {
    var results, _iterator63, _step63, runner, _normalizeResult, tag, value, mode;
    return _regeneratorRuntime().wrap(function _callee241$(_context244) {
      while (1) switch (_context244.prev = _context244.next) {
        case 0:
          // Get all the result objects
          results = [];
          _iterator63 = _createForOfIteratorHelper(running);
          try {
            for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
              runner = _step63.value;
              if (runner.result != null) {
                _normalizeResult = normalizeResult(runner.result), tag = _normalizeResult.tag, value = _normalizeResult.value;
                results.push({
                  tag: tag,
                  value: value,
                  weight: runner.config.weight
                });
              }
            }
            // Are there enough results to event meet quorum?
          } catch (err) {
            _iterator63.e(err);
          } finally {
            _iterator63.f();
          }
          if (!(results.reduce(function (a, r) {
            return a + r.weight;
          }, 0) < this.quorum)) {
            _context244.next = 5;
            break;
          }
          return _context244.abrupt("return", undefined);
        case 5:
          _context244.t0 = req.method;
          _context244.next = _context244.t0 === "getBlockNumber" ? 8 : _context244.t0 === "getGasPrice" ? 14 : _context244.t0 === "estimateGas" ? 14 : _context244.t0 === "getBlock" ? 15 : _context244.t0 === "call" ? 18 : _context244.t0 === "chainId" ? 18 : _context244.t0 === "getBalance" ? 18 : _context244.t0 === "getTransactionCount" ? 18 : _context244.t0 === "getCode" ? 18 : _context244.t0 === "getStorage" ? 18 : _context244.t0 === "getTransaction" ? 18 : _context244.t0 === "getTransactionReceipt" ? 18 : _context244.t0 === "getLogs" ? 18 : _context244.t0 === "broadcastTransaction" ? 19 : 20;
          break;
        case 8:
          // We need to get the bootstrap block height
          if (_classPrivateFieldGet(this, _height) === -2) {
            _classPrivateFieldSet(this, _height, Math.ceil(getNumber(getMedian(this.quorum, _classPrivateFieldGet(this, _configs).map(function (c) {
              return {
                value: c.blockNumber,
                tag: getNumber(c.blockNumber).toString(),
                weight: c.weight
              };
            })))));
          }
          // Find the mode across all the providers, allowing for
          // a little drift between block heights
          mode = getFuzzyMode(this.quorum, results);
          if (!(mode === undefined)) {
            _context244.next = 12;
            break;
          }
          return _context244.abrupt("return", undefined);
        case 12:
          if (mode > _classPrivateFieldGet(this, _height)) {
            _classPrivateFieldSet(this, _height, mode);
          }
          return _context244.abrupt("return", _classPrivateFieldGet(this, _height));
        case 14:
          return _context244.abrupt("return", getMedian(this.quorum, results));
        case 15:
          if (!("blockTag" in req && req.blockTag === "pending")) {
            _context244.next = 17;
            break;
          }
          return _context244.abrupt("return", getAnyResult(this.quorum, results));
        case 17:
          return _context244.abrupt("return", checkQuorum(this.quorum, results));
        case 18:
          return _context244.abrupt("return", checkQuorum(this.quorum, results));
        case 19:
          return _context244.abrupt("return", getAnyResult(this.quorum, results));
        case 20:
          assert$1(false, "unsupported method", "UNSUPPORTED_OPERATION", {
            operation: "_perform(".concat(stringify(req.method), ")")
          });
        case 21:
        case "end":
          return _context244.stop();
      }
    }, _callee241, this);
  }));
  return _checkQuorum3.apply(this, arguments);
}
function _waitForQuorum2(_x306, _x307) {
  return _waitForQuorum3.apply(this, arguments);
}
function _waitForQuorum3() {
  _waitForQuorum3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee242(running, req) {
    var interesting, newRunners, _iterator64, _step64, runner, value, _i99;
    return _regeneratorRuntime().wrap(function _callee242$(_context245) {
      while (1) switch (_context245.prev = _context245.next) {
        case 0:
          if (!(running.size === 0)) {
            _context245.next = 2;
            break;
          }
          throw new Error("no runners?!");
        case 2:
          // Any promises that are interesting to watch for; an expired stall
          // or a successful perform
          interesting = [];
          newRunners = 0;
          _iterator64 = _createForOfIteratorHelper(running);
          _context245.prev = 5;
          _iterator64.s();
        case 7:
          if ((_step64 = _iterator64.n()).done) {
            _context245.next = 19;
            break;
          }
          runner = _step64.value;
          // No responses, yet; keep an eye on it
          if (runner.perform) {
            interesting.push(runner.perform);
          }
          // Still stalling...
          if (!runner.staller) {
            _context245.next = 13;
            break;
          }
          interesting.push(runner.staller);
          return _context245.abrupt("continue", 17);
        case 13:
          if (!runner.didBump) {
            _context245.next = 15;
            break;
          }
          return _context245.abrupt("continue", 17);
        case 15:
          // Got a response (result or error) or stalled; kick off another runner
          runner.didBump = true;
          newRunners++;
        case 17:
          _context245.next = 7;
          break;
        case 19:
          _context245.next = 24;
          break;
        case 21:
          _context245.prev = 21;
          _context245.t0 = _context245["catch"](5);
          _iterator64.e(_context245.t0);
        case 24:
          _context245.prev = 24;
          _iterator64.f();
          return _context245.finish(24);
        case 27:
          _context245.next = 29;
          return _classPrivateMethodGet(this, _checkQuorum, _checkQuorum2).call(this, running, req);
        case 29:
          value = _context245.sent;
          if (!(value !== undefined)) {
            _context245.next = 34;
            break;
          }
          if (!(value instanceof Error)) {
            _context245.next = 33;
            break;
          }
          throw value;
        case 33:
          return _context245.abrupt("return", value);
        case 34:
          // Add any new runners, because a staller timed out or a result
          // or error response came in.
          for (_i99 = 0; _i99 < newRunners; _i99++) {
            _classPrivateMethodGet(this, _addRunner, _addRunner2).call(this, running, req);
          }
          // All providers have returned, and we have no result
          assert$1(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
            request: "%sub-requests",
            info: {
              request: req,
              results: Array.from(running).map(function (r) {
                return stringify(r.result);
              })
            }
          });
          // Wait for someone to either complete its perform or stall out
          _context245.next = 38;
          return Promise.race(interesting);
        case 38:
          _context245.next = 40;
          return _classPrivateMethodGet(this, _waitForQuorum, _waitForQuorum2).call(this, running, req);
        case 40:
          return _context245.abrupt("return", _context245.sent);
        case 41:
        case "end":
          return _context245.stop();
      }
    }, _callee242, this, [[5, 21, 24, 27]]);
  }));
  return _waitForQuorum3.apply(this, arguments);
}
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
function getDefaultProvider(network, options) {
  if (options == null) {
    options = {};
  }
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new JsonRpcProvider(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
    return new WebSocketProvider(network);
  }
  var providers = [];
  if (options.alchemy !== "-") {
    try {
      providers.push(new AlchemyProvider(network, options.alchemy));
    } catch (error) {
      console.log(error);
    }
  }
  if (options.ankr !== "-") {
    try {
      providers.push(new AnkrProvider(network, options.ankr));
    } catch (error) {
      console.log(error);
    }
  }
  if (options.cloudflare !== "-") {
    try {
      providers.push(new CloudflareProvider(network));
    } catch (error) {
      console.log(error);
    }
  }
  if (options.etherscan !== "-") {
    try {
      providers.push(new EtherscanProvider(network, options.etherscan));
    } catch (error) {
      console.log(error);
    }
  }
  if (options.infura !== "-") {
    try {
      var projectId = options.infura;
      var projectSecret = undefined;
      if (_typeof(projectId) === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network, projectId, projectSecret));
    } catch (error) {
      console.log(error);
    }
  }
  /*
      if (options.pocket !== "-") {
          try {
              let appId = options.pocket;
              let secretKey: undefined | string = undefined;
              let loadBalancer: undefined | boolean = undefined;
              if (typeof(appId) === "object") {
                  loadBalancer = !!appId.loadBalancer;
                  secretKey = appId.secretKey;
                  appId = appId.appId;
              }
              providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));
          } catch (error) { console.log(error); }
      }
  */
  if (options.quicknode !== "-") {
    try {
      var token = options.quicknode;
      providers.push(new QuickNodeProvider(network, token));
    } catch (error) {
      console.log(error);
    }
  }
  assert$1(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  return new FallbackProvider(providers);
}
var _noncePromise = /*#__PURE__*/new WeakMap();
var _delta = /*#__PURE__*/new WeakMap();
var NonceManager = /*#__PURE__*/function (_AbstractSigner3) {
  _inherits(NonceManager, _AbstractSigner3);
  var _super66 = _createSuper(NonceManager);
  function NonceManager(signer) {
    var _this91;
    _classCallCheck(this, NonceManager);
    _this91 = _super66.call(this, signer.provider);
    _defineProperty(_assertThisInitialized(_this91), "signer", void 0);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this91), _noncePromise, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this91), _delta, {
      writable: true,
      value: void 0
    });
    defineProperties(_assertThisInitialized(_this91), {
      signer: signer
    });
    _classPrivateFieldSet(_assertThisInitialized(_this91), _noncePromise, null);
    _classPrivateFieldSet(_assertThisInitialized(_this91), _delta, 0);
    return _this91;
  }
  _createClass(NonceManager, [{
    key: "getAddress",
    value: function () {
      var _getAddress5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee178() {
        return _regeneratorRuntime().wrap(function _callee178$(_context178) {
          while (1) switch (_context178.prev = _context178.next) {
            case 0:
              return _context178.abrupt("return", this.signer.getAddress());
            case 1:
            case "end":
              return _context178.stop();
          }
        }, _callee178, this);
      }));
      function getAddress() {
        return _getAddress5.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new NonceManager(this.signer.connect(provider));
    }
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee179(blockTag) {
        return _regeneratorRuntime().wrap(function _callee179$(_context179) {
          while (1) switch (_context179.prev = _context179.next) {
            case 0:
              if (!(blockTag === "pending")) {
                _context179.next = 7;
                break;
              }
              if (_classPrivateFieldGet(this, _noncePromise) == null) {
                _classPrivateFieldSet(this, _noncePromise, _get(_getPrototypeOf(NonceManager.prototype), "getNonce", this).call(this, "pending"));
              }
              _context179.next = 4;
              return _classPrivateFieldGet(this, _noncePromise);
            case 4:
              _context179.t0 = _context179.sent;
              _context179.t1 = _classPrivateFieldGet(this, _delta);
              return _context179.abrupt("return", _context179.t0 + _context179.t1);
            case 7:
              return _context179.abrupt("return", _get(_getPrototypeOf(NonceManager.prototype), "getNonce", this).call(this, blockTag));
            case 8:
            case "end":
              return _context179.stop();
          }
        }, _callee179, this);
      }));
      function getNonce(_x249) {
        return _getNonce2.apply(this, arguments);
      }
      return getNonce;
    }()
  }, {
    key: "increment",
    value: function increment() {
      var _this$delta, _this$delta2;
      _classPrivateFieldSet(this, _delta, (_this$delta = _classPrivateFieldGet(this, _delta), _this$delta2 = _this$delta++, _this$delta)), _this$delta2;
    }
  }, {
    key: "reset",
    value: function reset() {
      _classPrivateFieldSet(this, _delta, 0);
      _classPrivateFieldSet(this, _noncePromise, null);
    }
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee180(tx) {
        var noncePromise;
        return _regeneratorRuntime().wrap(function _callee180$(_context180) {
          while (1) switch (_context180.prev = _context180.next) {
            case 0:
              noncePromise = this.getNonce("pending");
              this.increment();
              _context180.next = 4;
              return this.signer.populateTransaction(tx);
            case 4:
              tx = _context180.sent;
              _context180.next = 7;
              return noncePromise;
            case 7:
              tx.nonce = _context180.sent;
              _context180.next = 10;
              return this.signer.sendTransaction(tx);
            case 10:
              return _context180.abrupt("return", _context180.sent);
            case 11:
            case "end":
              return _context180.stop();
          }
        }, _callee180, this);
      }));
      function sendTransaction(_x250) {
        return _sendTransaction3.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }, {
    key: "signTransaction",
    value: function signTransaction(tx) {
      return this.signer.signTransaction(tx);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message) {
      return this.signer.signMessage(message);
    }
  }, {
    key: "signTypedData",
    value: function signTypedData(domain, types, value) {
      return this.signer.signTypedData(domain, types, value);
    }
  }]);
  return NonceManager;
}(AbstractSigner);
exports.NonceManager = NonceManager;
;
var _request3 = /*#__PURE__*/new WeakMap();
var BrowserProvider = /*#__PURE__*/function (_JsonRpcApiPollingPro2) {
  _inherits(BrowserProvider, _JsonRpcApiPollingPro2);
  var _super67 = _createSuper(BrowserProvider);
  function BrowserProvider(ethereum, network) {
    var _this92;
    _classCallCheck(this, BrowserProvider);
    _this92 = _super67.call(this, network, {
      batchMaxCount: 1
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this92), _request3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this92), _request3, /*#__PURE__*/function () {
      var _ref44 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee181(method, params) {
        var payload, result, error;
        return _regeneratorRuntime().wrap(function _callee181$(_context181) {
          while (1) switch (_context181.prev = _context181.next) {
            case 0:
              payload = {
                method: method,
                params: params
              };
              _this92.emit("debug", {
                action: "sendEip1193Request",
                payload: payload
              });
              _context181.prev = 2;
              _context181.next = 5;
              return ethereum.request(payload);
            case 5:
              result = _context181.sent;
              _this92.emit("debug", {
                action: "receiveEip1193Result",
                result: result
              });
              return _context181.abrupt("return", result);
            case 10:
              _context181.prev = 10;
              _context181.t0 = _context181["catch"](2);
              error = new Error(_context181.t0.message);
              error.code = _context181.t0.code;
              error.data = _context181.t0.data;
              error.payload = payload;
              _this92.emit("debug", {
                action: "receiveEip1193Error",
                error: error
              });
              throw error;
            case 18:
            case "end":
              return _context181.stop();
          }
        }, _callee181, null, [[2, 10]]);
      }));
      return function (_x251, _x252) {
        return _ref44.apply(this, arguments);
      };
    }());
    return _this92;
  }
  _createClass(BrowserProvider, [{
    key: "send",
    value: function () {
      var _send8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee182(method, params) {
        return _regeneratorRuntime().wrap(function _callee182$(_context182) {
          while (1) switch (_context182.prev = _context182.next) {
            case 0:
              _context182.next = 2;
              return this._start();
            case 2:
              _context182.next = 4;
              return _get(_getPrototypeOf(BrowserProvider.prototype), "send", this).call(this, method, params);
            case 4:
              return _context182.abrupt("return", _context182.sent);
            case 5:
            case "end":
              return _context182.stop();
          }
        }, _callee182, this);
      }));
      function send(_x253, _x254) {
        return _send8.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee183(payload) {
        var result;
        return _regeneratorRuntime().wrap(function _callee183$(_context183) {
          while (1) switch (_context183.prev = _context183.next) {
            case 0:
              assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
              _context183.prev = 1;
              _context183.next = 4;
              return _classPrivateFieldGet(this, _request3).call(this, payload.method, payload.params || []);
            case 4:
              result = _context183.sent;
              return _context183.abrupt("return", [{
                id: payload.id,
                result: result
              }]);
            case 8:
              _context183.prev = 8;
              _context183.t0 = _context183["catch"](1);
              return _context183.abrupt("return", [{
                id: payload.id,
                error: {
                  code: _context183.t0.code,
                  data: _context183.t0.data,
                  message: _context183.t0.message
                }
              }]);
            case 11:
            case "end":
              return _context183.stop();
          }
        }, _callee183, this, [[1, 8]]);
      }));
      function _send(_x255) {
        return _send9.apply(this, arguments);
      }
      return _send;
    }()
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, error) {
      error = JSON.parse(JSON.stringify(error));
      // EIP-1193 gives us some machine-readable error codes, so rewrite
      // them into 
      switch (error.error.code || -1) {
        case 4001:
          error.error.message = "ethers-user-denied: ".concat(error.error.message);
          break;
        case 4200:
          error.error.message = "ethers-unsupported: ".concat(error.error.message);
          break;
      }
      return _get(_getPrototypeOf(BrowserProvider.prototype), "getRpcError", this).call(this, payload, error);
    }
  }, {
    key: "hasSigner",
    value: function () {
      var _hasSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee184(address) {
        var accounts;
        return _regeneratorRuntime().wrap(function _callee184$(_context184) {
          while (1) switch (_context184.prev = _context184.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              _context184.next = 3;
              return this.send("eth_accounts", []);
            case 3:
              accounts = _context184.sent;
              if (!(typeof address === "number")) {
                _context184.next = 6;
                break;
              }
              return _context184.abrupt("return", accounts.length > address);
            case 6:
              address = address.toLowerCase();
              return _context184.abrupt("return", accounts.filter(function (a) {
                return a.toLowerCase() === address;
              }).length !== 0);
            case 8:
            case "end":
              return _context184.stop();
          }
        }, _callee184, this);
      }));
      function hasSigner(_x256) {
        return _hasSigner.apply(this, arguments);
      }
      return hasSigner;
    }()
  }, {
    key: "getSigner",
    value: function () {
      var _getSigner2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee185(address) {
        var payload;
        return _regeneratorRuntime().wrap(function _callee185$(_context185) {
          while (1) switch (_context185.prev = _context185.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              _context185.next = 3;
              return this.hasSigner(address);
            case 3:
              if (_context185.sent) {
                _context185.next = 13;
                break;
              }
              _context185.prev = 4;
              _context185.next = 7;
              return _classPrivateFieldGet(this, _request3).call(this, "eth_requestAccounts", []);
            case 7:
              _context185.next = 13;
              break;
            case 9:
              _context185.prev = 9;
              _context185.t0 = _context185["catch"](4);
              payload = _context185.t0.payload;
              throw this.getRpcError(payload, {
                id: payload.id,
                error: _context185.t0
              });
            case 13:
              _context185.next = 15;
              return _get(_getPrototypeOf(BrowserProvider.prototype), "getSigner", this).call(this, address);
            case 15:
              return _context185.abrupt("return", _context185.sent);
            case 16:
            case "end":
              return _context185.stop();
          }
        }, _callee185, this, [[4, 9]]);
      }));
      function getSigner(_x257) {
        return _getSigner2.apply(this, arguments);
      }
      return getSigner;
    }()
  }]);
  return BrowserProvider;
}(JsonRpcApiPollingProvider);
/**
 *  [[link-pocket]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Polygon (``matic``)
 *  - Arbitrum (``arbitrum``)
 *
 *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]
 */
exports.BrowserProvider = BrowserProvider;
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "maticmum":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
}
/**
 *  The **PocketProvider** connects to the [[link-pocket]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-pocket-signup).
 */
var PocketProvider = /*#__PURE__*/function (_JsonRpcProvider6) {
  _inherits(PocketProvider, _JsonRpcProvider6);
  var _super68 = _createSuper(PocketProvider);
  /**
   *  The Application ID for the Pocket connection.
   */

  /**
   *  The Application Secret for making authenticated requests
   *  to the Pocket connection.
   */

  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  function PocketProvider(_network, applicationId, applicationSecret) {
    var _this93;
    _classCallCheck(this, PocketProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    var options = {
      staticNetwork: network
    };
    var request = PocketProvider.getRequest(network, applicationId, applicationSecret);
    _this93 = _super68.call(this, request, network, options);
    _defineProperty(_assertThisInitialized(_this93), "applicationId", void 0);
    _defineProperty(_assertThisInitialized(_this93), "applicationSecret", void 0);
    defineProperties(_assertThisInitialized(_this93), {
      applicationId: applicationId,
      applicationSecret: applicationSecret
    });
    return _this93;
  }
  _createClass(PocketProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
      } catch (error) {}
      return _get(_getPrototypeOf(PocketProvider.prototype), "_getProvider", this).call(this, chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%applicationId%%.
     */
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.applicationId === defaultApplicationId;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, applicationId, applicationSecret) {
      if (applicationId == null) {
        applicationId = defaultApplicationId;
      }
      var request = new FetchRequest("https://".concat(getHost(network.name), "/v1/lb/").concat(applicationId));
      request.allowGzip = true;
      if (applicationSecret) {
        request.setCredentials("", applicationSecret);
      }
      if (applicationId === defaultApplicationId) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref45 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee186(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee186$(_context186) {
              while (1) switch (_context186.prev = _context186.next) {
                case 0:
                  showThrottleMessage("PocketProvider");
                  return _context186.abrupt("return", true);
                case 2:
                case "end":
                  return _context186.stop();
              }
            }, _callee186);
          }));
          return function (_x258, _x259, _x260) {
            return _ref45.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
  return PocketProvider;
}(JsonRpcProvider);
exports.PocketProvider = PocketProvider;
var IpcSocketProvider = undefined;

/**
 *  About providers.
 *
 *  @_section: api/providers:Providers  [about-providers]
 */

/**
 *  The **BaseWallet** is a stream-lined implementation of a
 *  [[Signer]] that operates with a private key.
 *
 *  It is preferred to use the [[Wallet]] class, as it offers
 *  additional functionality and simplifies loading a variety
 *  of JSON formats, Mnemonic Phrases, etc.
 *
 *  This class may be of use for those attempting to implement
 *  a minimal Signer.
 */
exports.IpcSocketProvider = IpcSocketProvider;
var _signingKey = /*#__PURE__*/new WeakMap();
var BaseWallet = /*#__PURE__*/function (_AbstractSigner4) {
  _inherits(BaseWallet, _AbstractSigner4);
  var _super69 = _createSuper(BaseWallet);
  /**
   *  The wallet address.
   */

  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  function BaseWallet(privateKey, provider) {
    var _this94;
    _classCallCheck(this, BaseWallet);
    _this94 = _super69.call(this, provider);
    _defineProperty(_assertThisInitialized(_this94), "address", void 0);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this94), _signingKey, {
      writable: true,
      value: void 0
    });
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    _classPrivateFieldSet(_assertThisInitialized(_this94), _signingKey, privateKey);
    var address = computeAddress(_this94.signingKey.publicKey);
    defineProperties(_assertThisInitialized(_this94), {
      address: address
    });
    return _this94;
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  _createClass(BaseWallet, [{
    key: "signingKey",
    get: function get() {
      return _classPrivateFieldGet(this, _signingKey);
    }
    /**
     *  The private key for this wallet.
     */
  }, {
    key: "privateKey",
    get: function get() {
      return this.signingKey.privateKey;
    }
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee187() {
        return _regeneratorRuntime().wrap(function _callee187$(_context187) {
          while (1) switch (_context187.prev = _context187.next) {
            case 0:
              return _context187.abrupt("return", this.address);
            case 1:
            case "end":
              return _context187.stop();
          }
        }, _callee187, this);
      }));
      function getAddress() {
        return _getAddress6.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new BaseWallet(_classPrivateFieldGet(this, _signingKey), provider);
    }
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee188(tx) {
        var _yield$resolvePropert12, to, from, btx;
        return _regeneratorRuntime().wrap(function _callee188$(_context188) {
          while (1) switch (_context188.prev = _context188.next) {
            case 0:
              _context188.next = 2;
              return resolveProperties({
                to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,
                from: tx.from ? resolveAddress(tx.from, this.provider) : undefined
              });
            case 2:
              _yield$resolvePropert12 = _context188.sent;
              to = _yield$resolvePropert12.to;
              from = _yield$resolvePropert12.from;
              if (to != null) {
                tx.to = to;
              }
              if (from != null) {
                tx.from = from;
              }
              if (tx.from != null) {
                assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
                delete tx.from;
              }
              // Build the transaction
              btx = Transaction.from(tx);
              btx.signature = this.signingKey.sign(btx.unsignedHash);
              return _context188.abrupt("return", btx.serialized);
            case 11:
            case "end":
              return _context188.stop();
          }
        }, _callee188, this);
      }));
      function signTransaction(_x261) {
        return _signTransaction3.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee189(message) {
        return _regeneratorRuntime().wrap(function _callee189$(_context189) {
          while (1) switch (_context189.prev = _context189.next) {
            case 0:
              return _context189.abrupt("return", this.signMessageSync(message));
            case 1:
            case "end":
              return _context189.stop();
          }
        }, _callee189, this);
      }));
      function signMessage(_x262) {
        return _signMessage3.apply(this, arguments);
      }
      return signMessage;
    }() // @TODO: Add a secialized signTx and signTyped sync that enforces
    // all parameters are known?
    /**
     *  Returns the signature for %%message%% signed with this wallet.
     */
  }, {
    key: "signMessageSync",
    value: function signMessageSync(message) {
      return this.signingKey.sign(hashMessage(message)).serialized;
    }
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee191(domain, types, value) {
        var _this95 = this;
        var populated;
        return _regeneratorRuntime().wrap(function _callee191$(_context191) {
          while (1) switch (_context191.prev = _context191.next) {
            case 0:
              _context191.next = 2;
              return TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                var _ref46 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee190(name) {
                  var address;
                  return _regeneratorRuntime().wrap(function _callee190$(_context190) {
                    while (1) switch (_context190.prev = _context190.next) {
                      case 0:
                        // @TODO: this should use resolveName; addresses don't
                        //        need a provider
                        assert$1(_this95.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                          operation: "resolveName",
                          info: {
                            name: name
                          }
                        });
                        _context190.next = 3;
                        return _this95.provider.resolveName(name);
                      case 3:
                        address = _context190.sent;
                        assert$1(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                          value: name
                        });
                        return _context190.abrupt("return", address);
                      case 6:
                      case "end":
                        return _context190.stop();
                    }
                  }, _callee190);
                }));
                return function (_x266) {
                  return _ref46.apply(this, arguments);
                };
              }());
            case 2:
              populated = _context191.sent;
              return _context191.abrupt("return", this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized);
            case 4:
            case "end":
              return _context191.stop();
          }
        }, _callee191, this);
      }));
      function signTypedData(_x263, _x264, _x265) {
        return _signTypedData3.apply(this, arguments);
      }
      return signTypedData;
    }()
  }]);
  return BaseWallet;
}(AbstractSigner);
exports.BaseWallet = BaseWallet;
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words, sep) {
  var initial = 97;
  return words.reduce(function (accum, word) {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
/**
 *  @_ignore
 */
function decode(data, subs) {
  // Replace all the substitutions with their expanded form
  for (var _i57 = subsChrs.length - 1; _i57 >= 0; _i57--) {
    data = data.split(subsChrs[_i57]).join(subs.substring(2 * _i57, 2 * _i57 + 2));
  }
  // Get all tle clumps; each suffix, first-increment and second-increment
  var clumps = [];
  var leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, function (all, item, semi, word) {
    if (semi) {
      for (var _i58 = parseInt(semi); _i58 >= 0; _i58--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  /* c8 ignore start */
  if (leftover) {
    throw new Error("leftovers: ".concat(JSON.stringify(leftover)));
  }
  /* c8 ignore stop */
  return unfold(unfold(clumps, ";"), ":");
}
/**
 *  @_ignore
 */
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}

/**
 *  A Wordlist represents a collection of language-specific
 *  words used to encode and devoce [[link-bip-39]] encoded data
 *  by mapping words to 11-bit values and vice versa.
 */
var Wordlist = /*#__PURE__*/function () {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  function Wordlist(locale) {
    _classCallCheck(this, Wordlist);
    _defineProperty(this, "locale", void 0);
    defineProperties(this, {
      locale: locale
    });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  _createClass(Wordlist, [{
    key: "split",
    value: function split(phrase) {
      return phrase.toLowerCase().split(/\s+/g);
    }
    /**
     *  Sub-classes may override this to provider a language-specific
     *  method for joining %%words%% into a phrase.
     *
     *  By default, %%words%% are joined by a single space.
     */
  }, {
    key: "join",
    value: function join(words) {
      return words.join(" ");
    }
  }]);
  return Wordlist;
}(); // Use the encode-latin.js script to create the necessary
/**
 *  An OWL format Wordlist is an encoding method that exploits
 *  the general locality of alphabetically sorted words to
 *  achieve a simple but effective means of compression.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on ASCII-7 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create these necessary data.
 */
exports.Wordlist = Wordlist;
var _data5 = /*#__PURE__*/new WeakMap();
var _checksum = /*#__PURE__*/new WeakMap();
var _words = /*#__PURE__*/new WeakMap();
var _loadWords = /*#__PURE__*/new WeakSet();
var WordlistOwl = /*#__PURE__*/function (_Wordlist) {
  _inherits(WordlistOwl, _Wordlist);
  var _super70 = _createSuper(WordlistOwl);
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  function WordlistOwl(locale, data, _checksum2) {
    var _this96;
    _classCallCheck(this, WordlistOwl);
    _this96 = _super70.call(this, locale);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this96), _loadWords);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this96), _data5, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this96), _checksum, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(_assertThisInitialized(_this96), _words, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this96), _data5, data);
    _classPrivateFieldSet(_assertThisInitialized(_this96), _checksum, _checksum2);
    _classPrivateFieldSet(_assertThisInitialized(_this96), _words, null);
    return _this96;
  }
  _createClass(WordlistOwl, [{
    key: "_data",
    get: function get() {
      return _classPrivateFieldGet(this, _data5);
    }
  }, {
    key: "_decodeWords",
    value: function _decodeWords() {
      return decodeOwl(_classPrivateFieldGet(this, _data5));
    }
  }, {
    key: "getWord",
    value: function getWord(index) {
      var words = _classPrivateMethodGet(this, _loadWords, _loadWords2).call(this);
      assertArgument(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
      return words[index];
    }
  }, {
    key: "getWordIndex",
    value: function getWordIndex(word) {
      return _classPrivateMethodGet(this, _loadWords, _loadWords2).call(this).indexOf(word);
    }
  }]);
  return WordlistOwl;
}(Wordlist);
exports.WordlistOwl = WordlistOwl;
function _loadWords2() {
  if (_classPrivateFieldGet(this, _words) == null) {
    var _words2 = this._decodeWords();
    // Verify the computed list matches the official list
    var _checksum3 = id(_words2.join("\n") + "\n");
    /* c8 ignore start */
    if (_checksum3 !== _classPrivateFieldGet(this, _checksum)) {
      throw new Error("BIP39 Wordlist for ".concat(this.locale, " FAILED"));
    }
    /* c8 ignore stop */
    _classPrivateFieldSet(this, _words, _words2);
  }
  return _classPrivateFieldGet(this, _words);
}
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var _wordlist = null;
/**
 *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
var LangEn = /*#__PURE__*/function (_WordlistOwl) {
  _inherits(LangEn, _WordlistOwl);
  var _super71 = _createSuper(LangEn);
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  function LangEn() {
    _classCallCheck(this, LangEn);
    return _super71.call(this, "en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  _createClass(LangEn, null, [{
    key: "wordlist",
    value: function wordlist() {
      if (_wordlist == null) {
        _wordlist = new LangEn();
      }
      return _wordlist;
    }
  }]);
  return LangEn;
}(WordlistOwl); // Returns a byte with the MSB bits set
exports.LangEn = LangEn;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 0xff;
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
  return (1 << bits) - 1 & 0xff;
}
function mnemonicToEntropy(mnemonic, wordlist) {
  assertNormalize("NFKD");
  if (wordlist == null) {
    wordlist = LangEn.wordlist();
  }
  var words = wordlist.split(mnemonic);
  assertArgument(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  var entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
  var offset = 0;
  for (var _i59 = 0; _i59 < words.length; _i59++) {
    var index = wordlist.getWordIndex(words[_i59].normalize("NFKD"));
    assertArgument(index >= 0, "invalid mnemonic word at index ".concat(_i59), "mnemonic", "[ REDACTED ]");
    for (var bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  var entropyBits = 32 * words.length / 3;
  var checksumBits = words.length / 3;
  var checksumMask = getUpperMask(checksumBits);
  var checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist == null) {
    wordlist = LangEn.wordlist();
  }
  var indices = [0];
  var remainingBits = 11;
  for (var _i60 = 0; _i60 < entropy.length; _i60++) {
    // Consume the whole byte (with still more to go)
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[_i60];
      remainingBits -= 8;
      // This byte will complete an 11-bit index
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[_i60] >> 8 - remainingBits;
      // Start the next word
      indices.push(entropy[_i60] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  // Compute the checksum bits
  var checksumBits = entropy.length / 4;
  var checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  // Shift the checksum into the word indices
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist.join(indices.map(function (index) {
    return wordlist.getWord(index);
  }));
}
var _guard$1 = {};
/**
 *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]
 *  seeds and convert between phrases and entropy.
 */
var Mnemonic = /*#__PURE__*/function () {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */

  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */

  /**
   *  The wordlist for this mnemonic.
   */

  /**
   *  The underlying entropy which the mnemonic encodes.
   */

  /**
   *  @private
   */
  function Mnemonic(guard, entropy, phrase, password, wordlist) {
    _classCallCheck(this, Mnemonic);
    _defineProperty(this, "phrase", void 0);
    _defineProperty(this, "password", void 0);
    _defineProperty(this, "wordlist", void 0);
    _defineProperty(this, "entropy", void 0);
    if (password == null) {
      password = "";
    }
    if (wordlist == null) {
      wordlist = LangEn.wordlist();
    }
    assertPrivate(guard, _guard$1, "Mnemonic");
    defineProperties(this, {
      phrase: phrase,
      password: password,
      wordlist: wordlist,
      entropy: entropy
    });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  _createClass(Mnemonic, [{
    key: "computeSeed",
    value: function computeSeed() {
      var salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
      return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
    }
    /**
     *  Creates a new Mnemonic for the %%phrase%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
  }], [{
    key: "fromPhrase",
    value: function fromPhrase(phrase, password, wordlist) {
      // Normalize the case and space; throws if invalid
      var entropy = mnemonicToEntropy(phrase, wordlist);
      phrase = entropyToMnemonic(getBytes(entropy), wordlist);
      return new Mnemonic(_guard$1, entropy, phrase, password, wordlist);
    }
    /**
     *  Create a new **Mnemonic** from the %%entropy%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
  }, {
    key: "fromEntropy",
    value: function fromEntropy(_entropy, password, wordlist) {
      var entropy = getBytes(_entropy, "entropy");
      var phrase = entropyToMnemonic(entropy, wordlist);
      return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist);
    }
    /**
     *  Returns the phrase for %%mnemonic%%.
     */
  }, {
    key: "entropyToPhrase",
    value: function entropyToPhrase(_entropy, wordlist) {
      var entropy = getBytes(_entropy, "entropy");
      return entropyToMnemonic(entropy, wordlist);
    }
    /**
     *  Returns the entropy for %%phrase%%.
     */
  }, {
    key: "phraseToEntropy",
    value: function phraseToEntropy(phrase, wordlist) {
      return mnemonicToEntropy(phrase, wordlist);
    }
    /**
     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
     *
     *  This checks all the provided words belong to the %%wordlist%%,
     *  that the length is valid and the checksum is correct.
     */
  }, {
    key: "isValidMnemonic",
    value: function isValidMnemonic(phrase, wordlist) {
      try {
        mnemonicToEntropy(phrase, wordlist);
        return true;
      } catch (error) {}
      return false;
    }
  }]);
  return Mnemonic;
}();
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
exports.Mnemonic = Mnemonic;
var __classPrivateFieldSet$4 = window && window.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$4 = window && window.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AES_key, _AES_Kd, _AES_Ke;
// Number of rounds by keysize
var numberOfRounds = {
  16: 10,
  24: 12,
  32: 14
};
// Round constant words
var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
// S-box and Inverse S-box (S is for Substitution)
var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
// Transformations for encryption
var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
// Transformations for decryption
var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
// Transformations for decryption key expansion
var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
function convertToInt32(bytes) {
  var result = [];
  for (var _i61 = 0; _i61 < bytes.length; _i61 += 4) {
    result.push(bytes[_i61] << 24 | bytes[_i61 + 1] << 16 | bytes[_i61 + 2] << 8 | bytes[_i61 + 3]);
  }
  return result;
}
var AES = /*#__PURE__*/function () {
  function AES(key) {
    _classCallCheck(this, AES);
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error('AES must be instanitated with `new`');
    }
    __classPrivateFieldSet$4(this, _AES_key, new Uint8Array(key), "f");
    var rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
    }
    // encryption round keys
    __classPrivateFieldSet$4(this, _AES_Ke, [], "f");
    // decryption round keys
    __classPrivateFieldSet$4(this, _AES_Kd, [], "f");
    for (var _i62 = 0; _i62 <= rounds; _i62++) {
      __classPrivateFieldGet$4(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$4(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    var roundKeyCount = (rounds + 1) * 4;
    var KC = this.key.length / 4;
    // convert the key into ints
    var tk = convertToInt32(this.key);
    // copy values into round key arrays
    var index;
    for (var _i63 = 0; _i63 < KC; _i63++) {
      index = _i63 >> 2;
      __classPrivateFieldGet$4(this, _AES_Ke, "f")[index][_i63 % 4] = tk[_i63];
      __classPrivateFieldGet$4(this, _AES_Kd, "f")[rounds - index][_i63 % 4] = tk[_i63];
    }
    // key expansion (fips-197 section 5.2)
    var rconpointer = 0;
    var t = KC,
      tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      // key expansion (for non-256 bit)
      if (KC != 8) {
        for (var _i64 = 1; _i64 < KC; _i64++) {
          tk[_i64] ^= tk[_i64 - 1];
        }
        // key expansion for 256-bit keys is "slightly different" (fips-197)
      } else {
        for (var _i65 = 1; _i65 < KC / 2; _i65++) {
          tk[_i65] ^= tk[_i65 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
        for (var _i66 = KC / 2 + 1; _i66 < KC; _i66++) {
          tk[_i66] ^= tk[_i66 - 1];
        }
      }
      // copy values into round key arrays
      var _i67 = 0,
        _r10 = void 0,
        c = void 0;
      while (_i67 < KC && t < roundKeyCount) {
        _r10 = t >> 2;
        c = t % 4;
        __classPrivateFieldGet$4(this, _AES_Ke, "f")[_r10][c] = tk[_i67];
        __classPrivateFieldGet$4(this, _AES_Kd, "f")[rounds - _r10][c] = tk[_i67++];
        t++;
      }
    }
    // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
    for (var _r11 = 1; _r11 < rounds; _r11++) {
      for (var _c = 0; _c < 4; _c++) {
        tt = __classPrivateFieldGet$4(this, _AES_Kd, "f")[_r11][_c];
        __classPrivateFieldGet$4(this, _AES_Kd, "f")[_r11][_c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
      }
    }
  }
  _createClass(AES, [{
    key: "key",
    get: function get() {
      return __classPrivateFieldGet$4(this, _AES_key, "f").slice();
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length != 16) {
        throw new TypeError('invalid plaintext size (must be 16 bytes)');
      }
      var rounds = __classPrivateFieldGet$4(this, _AES_Ke, "f").length - 1;
      var a = [0, 0, 0, 0];
      // convert plaintext to (ints ^ key)
      var t = convertToInt32(plaintext);
      for (var _i68 = 0; _i68 < 4; _i68++) {
        t[_i68] ^= __classPrivateFieldGet$4(this, _AES_Ke, "f")[0][_i68];
      }
      // apply round transforms
      for (var _r12 = 1; _r12 < rounds; _r12++) {
        for (var _i69 = 0; _i69 < 4; _i69++) {
          a[_i69] = T1[t[_i69] >> 24 & 0xff] ^ T2[t[(_i69 + 1) % 4] >> 16 & 0xff] ^ T3[t[(_i69 + 2) % 4] >> 8 & 0xff] ^ T4[t[(_i69 + 3) % 4] & 0xff] ^ __classPrivateFieldGet$4(this, _AES_Ke, "f")[_r12][_i69];
        }
        t = a.slice();
      }
      // the last round is special
      var result = new Uint8Array(16);
      var tt = 0;
      for (var _i70 = 0; _i70 < 4; _i70++) {
        tt = __classPrivateFieldGet$4(this, _AES_Ke, "f")[rounds][_i70];
        result[4 * _i70] = (S[t[_i70] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * _i70 + 1] = (S[t[(_i70 + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * _i70 + 2] = (S[t[(_i70 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * _i70 + 3] = (S[t[(_i70 + 3) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length != 16) {
        throw new TypeError('invalid ciphertext size (must be 16 bytes)');
      }
      var rounds = __classPrivateFieldGet$4(this, _AES_Kd, "f").length - 1;
      var a = [0, 0, 0, 0];
      // convert plaintext to (ints ^ key)
      var t = convertToInt32(ciphertext);
      for (var _i71 = 0; _i71 < 4; _i71++) {
        t[_i71] ^= __classPrivateFieldGet$4(this, _AES_Kd, "f")[0][_i71];
      }
      // apply round transforms
      for (var _r13 = 1; _r13 < rounds; _r13++) {
        for (var _i72 = 0; _i72 < 4; _i72++) {
          a[_i72] = T5[t[_i72] >> 24 & 0xff] ^ T6[t[(_i72 + 3) % 4] >> 16 & 0xff] ^ T7[t[(_i72 + 2) % 4] >> 8 & 0xff] ^ T8[t[(_i72 + 1) % 4] & 0xff] ^ __classPrivateFieldGet$4(this, _AES_Kd, "f")[_r13][_i72];
        }
        t = a.slice();
      }
      // the last round is special
      var result = new Uint8Array(16);
      var tt = 0;
      for (var _i73 = 0; _i73 < 4; _i73++) {
        tt = __classPrivateFieldGet$4(this, _AES_Kd, "f")[rounds][_i73];
        result[4 * _i73] = (Si[t[_i73] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * _i73 + 1] = (Si[t[(_i73 + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * _i73 + 2] = (Si[t[(_i73 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * _i73 + 3] = (Si[t[(_i73 + 1) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    }
  }]);
  return AES;
}();
_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();
var ModeOfOperation = /*#__PURE__*/_createClass(function ModeOfOperation(name, key, cls) {
  _classCallCheck(this, ModeOfOperation);
  if (cls && !(this instanceof cls)) {
    throw new Error("".concat(name, " must be instantiated with \"new\""));
  }
  Object.defineProperties(this, {
    aes: {
      enumerable: true,
      value: new AES(key)
    },
    name: {
      enumerable: true,
      value: name
    }
  });
}); // Cipher Block Chaining
var __classPrivateFieldSet$3 = window && window.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$3 = window && window.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
var CBC = /*#__PURE__*/function (_ModeOfOperation) {
  _inherits(CBC, _ModeOfOperation);
  var _super72 = _createSuper(CBC);
  function CBC(key, iv) {
    var _this97;
    _classCallCheck(this, CBC);
    _this97 = _super72.call(this, "ECC", key, CBC);
    _CBC_iv.set(_assertThisInitialized(_this97), void 0);
    _CBC_lastBlock.set(_assertThisInitialized(_this97), void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$3(_assertThisInitialized(_this97), _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$3(_assertThisInitialized(_this97), _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$3(_assertThisInitialized(_this97), _CBC_lastBlock, _this97.iv, "f");
    return _this97;
  }
  _createClass(CBC, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet$3(this, _CBC_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = new Uint8Array(plaintext.length);
      for (var _i74 = 0; _i74 < plaintext.length; _i74 += 16) {
        for (var _j7 = 0; _j7 < 16; _j7++) {
          __classPrivateFieldGet$3(this, _CBC_lastBlock, "f")[_j7] ^= plaintext[_i74 + _j7];
        }
        __classPrivateFieldSet$3(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$3(this, _CBC_lastBlock, "f")), "f");
        ciphertext.set(__classPrivateFieldGet$3(this, _CBC_lastBlock, "f"), _i74);
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = new Uint8Array(ciphertext.length);
      for (var _i75 = 0; _i75 < ciphertext.length; _i75 += 16) {
        var block = this.aes.decrypt(ciphertext.subarray(_i75, _i75 + 16));
        for (var _j8 = 0; _j8 < 16; _j8++) {
          plaintext[_i75 + _j8] = block[_j8] ^ __classPrivateFieldGet$3(this, _CBC_lastBlock, "f")[_j8];
          __classPrivateFieldGet$3(this, _CBC_lastBlock, "f")[_j8] = ciphertext[_i75 + _j8];
        }
      }
      return plaintext;
    }
  }]);
  return CBC;
}(ModeOfOperation);
_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();

// Cipher Feedback
var __classPrivateFieldSet$2 = window && window.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$2 = window && window.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
var CFB = /*#__PURE__*/function (_ModeOfOperation2) {
  _inherits(CFB, _ModeOfOperation2);
  var _super73 = _createSuper(CFB);
  function CFB(key, iv) {
    var _this98;
    var segmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    _classCallCheck(this, CFB);
    _this98 = _super73.call(this, "CFB", key, CFB);
    _CFB_instances.add(_assertThisInitialized(_this98));
    _CFB_iv.set(_assertThisInitialized(_this98), void 0);
    _CFB_shiftRegister.set(_assertThisInitialized(_this98), void 0);
    // This library currently only handles byte-aligned segmentSize
    if (!Number.isInteger(segmentSize) || segmentSize % 8) {
      throw new TypeError("invalid segmentSize");
    }
    Object.defineProperties(_assertThisInitialized(_this98), {
      segmentSize: {
        enumerable: true,
        value: segmentSize
      }
    });
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$2(_assertThisInitialized(_this98), _CFB_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$2(_assertThisInitialized(_this98), _CFB_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$2(_assertThisInitialized(_this98), _CFB_shiftRegister, _this98.iv, "f");
    return _this98;
  }
  _createClass(CFB, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet$2(this, _CFB_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (8 * plaintext.length % this.segmentSize) {
        throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
      }
      var segmentSize = this.segmentSize / 8;
      var ciphertext = new Uint8Array(plaintext);
      for (var _i76 = 0; _i76 < ciphertext.length; _i76 += segmentSize) {
        var xorSegment = this.aes.encrypt(__classPrivateFieldGet$2(this, _CFB_shiftRegister, "f"));
        for (var _j9 = 0; _j9 < segmentSize; _j9++) {
          ciphertext[_i76 + _j9] ^= xorSegment[_j9];
        }
        __classPrivateFieldGet$2(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(_i76));
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (8 * ciphertext.length % this.segmentSize) {
        throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
      }
      var segmentSize = this.segmentSize / 8;
      var plaintext = new Uint8Array(ciphertext);
      for (var _i77 = 0; _i77 < plaintext.length; _i77 += segmentSize) {
        var xorSegment = this.aes.encrypt(__classPrivateFieldGet$2(this, _CFB_shiftRegister, "f"));
        for (var _j10 = 0; _j10 < segmentSize; _j10++) {
          plaintext[_i77 + _j10] ^= xorSegment[_j10];
        }
        __classPrivateFieldGet$2(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(_i77));
      }
      return plaintext;
    }
  }]);
  return CFB;
}(ModeOfOperation);
_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {
  var segmentSize = this.segmentSize / 8;
  // Shift the register
  __classPrivateFieldGet$2(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet$2(this, _CFB_shiftRegister, "f").subarray(segmentSize));
  __classPrivateFieldGet$2(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};

// Counter Mode
var __classPrivateFieldSet$1 = window && window.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = window && window.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
var CTR = /*#__PURE__*/function (_ModeOfOperation3) {
  _inherits(CTR, _ModeOfOperation3);
  var _super74 = _createSuper(CTR);
  function CTR(key, initialValue) {
    var _this99;
    _classCallCheck(this, CTR);
    _this99 = _super74.call(this, "CTR", key, CTR);
    // Remaining bytes for the one-time pad
    _CTR_remaining.set(_assertThisInitialized(_this99), void 0);
    _CTR_remainingIndex.set(_assertThisInitialized(_this99), void 0);
    // The current counter
    _CTR_counter.set(_assertThisInitialized(_this99), void 0);
    __classPrivateFieldSet$1(_assertThisInitialized(_this99), _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet$1(_assertThisInitialized(_this99), _CTR_counter, "f").fill(0);
    __classPrivateFieldSet$1(_assertThisInitialized(_this99), _CTR_remaining, __classPrivateFieldGet$1(_assertThisInitialized(_this99), _CTR_counter, "f"), "f"); // This will be discarded immediately
    __classPrivateFieldSet$1(_assertThisInitialized(_this99), _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      _this99.setCounterValue(initialValue);
    } else {
      _this99.setCounterBytes(initialValue);
    }
    return _this99;
  }
  _createClass(CTR, [{
    key: "counter",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet$1(this, _CTR_counter, "f"));
    }
  }, {
    key: "setCounterValue",
    value: function setCounterValue(value) {
      if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("invalid counter initial integer value");
      }
      for (var index = 15; index >= 0; --index) {
        __classPrivateFieldGet$1(this, _CTR_counter, "f")[index] = value % 256;
        value = Math.floor(value / 256);
      }
    }
  }, {
    key: "setCounterBytes",
    value: function setCounterBytes(value) {
      if (value.length !== 16) {
        throw new TypeError("invalid counter initial Uint8Array value length");
      }
      __classPrivateFieldGet$1(this, _CTR_counter, "f").set(value);
    }
  }, {
    key: "increment",
    value: function increment() {
      for (var _i78 = 15; _i78 >= 0; _i78--) {
        if (__classPrivateFieldGet$1(this, _CTR_counter, "f")[_i78] === 255) {
          __classPrivateFieldGet$1(this, _CTR_counter, "f")[_i78] = 0;
        } else {
          __classPrivateFieldGet$1(this, _CTR_counter, "f")[_i78]++;
          break;
        }
      }
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      var _a, _b;
      var crypttext = new Uint8Array(plaintext);
      for (var _i79 = 0; _i79 < crypttext.length; _i79++) {
        if (__classPrivateFieldGet$1(this, _CTR_remainingIndex, "f") === 16) {
          __classPrivateFieldSet$1(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet$1(this, _CTR_counter, "f")), "f");
          __classPrivateFieldSet$1(this, _CTR_remainingIndex, 0, "f");
          this.increment();
        }
        crypttext[_i79] ^= __classPrivateFieldGet$1(this, _CTR_remaining, "f")[(__classPrivateFieldSet$1(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet$1(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a)];
      }
      return crypttext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      return this.encrypt(ciphertext);
    }
  }]);
  return CTR;
}(ModeOfOperation);
_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();

// Electronic Code Book
var ECB = /*#__PURE__*/function (_ModeOfOperation4) {
  _inherits(ECB, _ModeOfOperation4);
  var _super75 = _createSuper(ECB);
  function ECB(key) {
    _classCallCheck(this, ECB);
    return _super75.call(this, "ECB", key, ECB);
  }
  _createClass(ECB, [{
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var crypttext = new Uint8Array(plaintext.length);
      for (var _i80 = 0; _i80 < plaintext.length; _i80 += 16) {
        crypttext.set(this.aes.encrypt(plaintext.subarray(_i80, _i80 + 16)), _i80);
      }
      return crypttext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(crypttext) {
      if (crypttext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = new Uint8Array(crypttext.length);
      for (var _i81 = 0; _i81 < crypttext.length; _i81 += 16) {
        plaintext.set(this.aes.decrypt(crypttext.subarray(_i81, _i81 + 16)), _i81);
      }
      return plaintext;
    }
  }]);
  return ECB;
}(ModeOfOperation); // Output Feedback
var __classPrivateFieldSet = window && window.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = window && window.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
var OFB = /*#__PURE__*/function (_ModeOfOperation5) {
  _inherits(OFB, _ModeOfOperation5);
  var _super76 = _createSuper(OFB);
  function OFB(key, iv) {
    var _this100;
    _classCallCheck(this, OFB);
    _this100 = _super76.call(this, "OFB", key, OFB);
    _OFB_iv.set(_assertThisInitialized(_this100), void 0);
    _OFB_lastPrecipher.set(_assertThisInitialized(_this100), void 0);
    _OFB_lastPrecipherIndex.set(_assertThisInitialized(_this100), void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet(_assertThisInitialized(_this100), _OFB_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet(_assertThisInitialized(_this100), _OFB_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet(_assertThisInitialized(_this100), _OFB_lastPrecipher, _this100.iv, "f");
    __classPrivateFieldSet(_assertThisInitialized(_this100), _OFB_lastPrecipherIndex, 16, "f");
    return _this100;
  }
  _createClass(OFB, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      var _a, _b;
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = new Uint8Array(plaintext);
      for (var _i82 = 0; _i82 < ciphertext.length; _i82++) {
        if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f") === 16) {
          __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, "f")), "f");
          __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, "f");
        }
        ciphertext[_i82] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, "f")[(__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f"), _a = _b++, _b), "f"), _a)];
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      return this.encrypt(ciphertext);
    }
  }]);
  return OFB;
}(ModeOfOperation);
_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();
function pkcs7Pad(data) {
  var padder = 16 - data.length % 16;
  var result = new Uint8Array(data.length + padder);
  result.set(data);
  for (var _i83 = data.length; _i83 < result.length; _i83++) {
    result[_i83] = padder;
  }
  return result;
}
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError('PKCS#7 invalid length');
  }
  var padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError('PKCS#7 padding byte out of range');
  }
  var length = data.length - padder;
  for (var _i84 = 0; _i84 < padder; _i84++) {
    if (data[length + _i84] !== padder) {
      throw new TypeError('PKCS#7 invalid padding byte');
    }
  }
  return new Uint8Array(data.subarray(0, length));
}

/**
 *  @_ignore
 */
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = '0' + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === 'string') {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object, _path) {
  var match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  var path = match[1];
  var type = match[3];
  var reqd = match[4] === "!";
  var cur = object;
  var _iterator52 = _createForOfIteratorHelper(path.toLowerCase().split('.')),
    _step52;
  try {
    for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
      var comp = _step52.value;
      // Search for a child object with a case-insensitive matching key
      if (Array.isArray(cur)) {
        if (!comp.match(/^[0-9]+$/)) {
          break;
        }
        cur = cur[parseInt(comp)];
      } else if (_typeof(cur) === "object") {
        var found = null;
        for (var key in cur) {
          if (key.toLowerCase() === comp) {
            found = cur[key];
            break;
          }
        }
        cur = found;
      } else {
        cur = null;
      }
      if (cur == null) {
        break;
      }
    }
  } catch (err) {
    _iterator52.e(err);
  } finally {
    _iterator52.f();
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === _typeof(cur)) {
      return cur;
    }
    assertArgument(false, "wrong type found for ".concat(type, " "), "path", path);
  }
  return cur;
}
/*
export function follow(object: any, path: string): null | string {
    let currentChild = object;

    for (const comp of path.toLowerCase().split('/')) {

        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
             if (key.toLowerCase() === comp) {
                 matchingChild = currentChild[key];
                 break;
             }
        }

        if (matchingChild === null) { return null; }

        currentChild = matchingChild;
    }

    return currentChild;
}

// "path/to/something:type!"
export function followRequired(data: any, path: string): string {
    const value = follow(data, path);
    if (value != null) { return value; }
    return logger.throwArgumentError("invalid value", `data:${ path }`,
    JSON.stringify(data));
}
*/
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
/*
export function uuidV4(randomBytes: BytesLike): string {
    const bytes = getBytes(randomBytes, "randomBytes");

    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;

    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;

    const value = hexlify(bytes);

    return [
       value.substring(2, 10),
       value.substring(10, 14),
       value.substring(14, 18),
       value.substring(18, 22),
       value.substring(22, 34),
    ].join("-");
}
*/

/**
 *  The JSON Wallet formats allow a simple way to store the private
 *  keys needed in Ethereum along with related information and allows
 *  for extensible forms of encryption.
 *
 *  These utilities facilitate decrypting and encrypting the most common
 *  JSON Wallet formats.
 *
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
var defaultPath$1 = "m/44'/60'/0'/0/0";
/**
 *  Returns true if %%json%% is a valid JSON Keystore Wallet.
 */
function isKeystoreJson(json) {
  try {
    var data = JSON.parse(json);
    var _version = data.version != null ? parseInt(data.version) : 0;
    if (_version === 3) {
      return true;
    }
  } catch (error) {}
  return false;
}
function decrypt(data, key, ciphertext) {
  var cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    var iv = spelunk(data, "crypto.cipherparams.iv:data!");
    var aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert$1(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  var key = getBytes(_key);
  var ciphertext = spelunk(data, "crypto.ciphertext:data!");
  var computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  var privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  var address = computeAddress(privateKey);
  if (data.address) {
    var check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  var account = {
    address: address,
    privateKey: privateKey
  };
  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
  var version = spelunk(data, "x-ethers.version:string");
  if (version === "0.1") {
    var mnemonicKey = key.slice(32, 64);
    var mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    var mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    var mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  var kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      var salt = spelunk(data, "crypto.kdfparams.salt:data!");
      var _N = spelunk(data, "crypto.kdfparams.n:int!");
      var _r14 = spelunk(data, "crypto.kdfparams.r:int!");
      var p = spelunk(data, "crypto.kdfparams.p:int!");
      // Make sure N is a power of 2
      assertArgument(_N > 0 && (_N & _N - 1) === 0, "invalid kdf.N", "kdf.N", _N);
      assertArgument(_r14 > 0 && p > 0, "invalid kdf", "kdf", kdf);
      var dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return {
        name: "scrypt",
        salt: salt,
        N: _N,
        r: _r14,
        p: p,
        dkLen: 64
      };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      var _salt2 = spelunk(data, "crypto.kdfparams.salt:data!");
      var prf = spelunk(data, "crypto.kdfparams.prf:string!");
      var algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      var count = spelunk(data, "crypto.kdfparams.c:int!");
      var _dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(_dkLen === 32, "invalid kdf.dklen", "kdf.dklen", _dkLen);
      return {
        name: "pbkdf2",
        salt: _salt2,
        count: count,
        dkLen: _dkLen,
        algorithm: algorithm
      };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
/**
 *  Returns the account details for the JSON Keystore Wallet %%json%%
 *  using %%password%%.
 *
 *  It is preferred to use the [async version](decryptKeystoreJson)
 *  instead, which allows a [[ProgressCallback]] to keep the user informed
 *  as to the decryption status.
 *
 *  This method will block the event loop (freezing all UI) until decryption
 *  is complete, which can take quite some time, depending on the wallet
 *  paramters and platform.
 */
function decryptKeystoreJsonSync(json, _password) {
  var data = JSON.parse(json);
  var password = getPassword(_password);
  var params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    var _salt3 = params.salt,
      count = params.count,
      _dkLen2 = params.dkLen,
      algorithm = params.algorithm;
    var _key21 = pbkdf2(password, _salt3, count, _dkLen2, algorithm);
    return getAccount(data, _key21);
  }
  assert$1(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
    params: params
  });
  var salt = params.salt,
    N = params.N,
    r = params.r,
    p = params.p,
    dkLen = params.dkLen;
  var key = scryptSync(password, salt, N, r, p, dkLen);
  return getAccount(data, key);
}
function stall$1(duration) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, duration);
  });
}
/**
 *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the
 *  %%password%%.
 *
 *  If provided, %%progress%% will be called periodically during the
 *  decrpytion to provide feedback, and if the function returns
 *  ``false`` will halt decryption.
 *
 *  The %%progressCallback%% will **always** receive ``0`` before
 *  decryption begins and ``1`` when complete.
 */
function decryptKeystoreJson(_x267, _x268, _x269) {
  return _decryptKeystoreJson.apply(this, arguments);
}
function _decryptKeystoreJson() {
  _decryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee223(json, _password, progress) {
    var data, password, params, _salt4, count, _dkLen3, algorithm, _key22, salt, N, r, p, dkLen, key;
    return _regeneratorRuntime().wrap(function _callee223$(_context226) {
      while (1) switch (_context226.prev = _context226.next) {
        case 0:
          data = JSON.parse(json);
          password = getPassword(_password);
          params = getDecryptKdfParams(data);
          if (!(params.name === "pbkdf2")) {
            _context226.next = 15;
            break;
          }
          if (!progress) {
            _context226.next = 8;
            break;
          }
          progress(0);
          _context226.next = 8;
          return stall$1(0);
        case 8:
          _salt4 = params.salt, count = params.count, _dkLen3 = params.dkLen, algorithm = params.algorithm;
          _key22 = pbkdf2(password, _salt4, count, _dkLen3, algorithm);
          if (!progress) {
            _context226.next = 14;
            break;
          }
          progress(1);
          _context226.next = 14;
          return stall$1(0);
        case 14:
          return _context226.abrupt("return", getAccount(data, _key22));
        case 15:
          assert$1(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
            params: params
          });
          salt = params.salt, N = params.N, r = params.r, p = params.p, dkLen = params.dkLen;
          _context226.next = 19;
          return scrypt(password, salt, N, r, p, dkLen, progress);
        case 19:
          key = _context226.sent;
          return _context226.abrupt("return", getAccount(data, key));
        case 21:
        case "end":
          return _context226.stop();
      }
    }, _callee223);
  }));
  return _decryptKeystoreJson.apply(this, arguments);
}
function getEncryptKdfParams(options) {
  // Check/generate the salt
  var salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes(32);
  // Override the scrypt password-based key derivation function parameters
  var N = 1 << 17,
    r = 8,
    p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N === "number" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return {
    name: "scrypt",
    dkLen: 32,
    salt: salt,
    N: N,
    r: r,
    p: p
  };
}
function _encryptKeystore(key, kdf, account, options) {
  var privateKey = getBytes(account.privateKey, "privateKey");
  // Override initialization vector
  var iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  // Override the uuid
  var uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  // This will be used to encrypt the wallet (as per Web3 secret storage)
  // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
  // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
  var derivedKey = key.slice(0, 16);
  var macPrefix = key.slice(16, 32);
  // Encrypt the private key
  var aesCtr = new CTR(derivedKey, iv);
  var ciphertext = getBytes(aesCtr.encrypt(privateKey));
  // Compute the message authentication code, used to check the password
  var mac = keccak256(concat([macPrefix, ciphertext]));
  // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
  var data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  // If we have a mnemonic, encrypt it into the JSON wallet
  if (account.mnemonic) {
    var client = options.client != null ? options.client : "ethers/".concat(version);
    var path = account.mnemonic.path || defaultPath$1;
    var locale = account.mnemonic.locale || "en";
    var mnemonicKey = key.slice(32, 64);
    var entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    var mnemonicIv = randomBytes(16);
    var mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    var mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    var now = new Date();
    var timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    var gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client: client,
      gethFilename: gethFilename,
      path: path,
      locale: locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
/**
 *  Return the JSON Keystore Wallet for %%account%% encrypted with
 *  %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used. Any provided [[ProgressCallback]] is ignord.
 */
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  var passwordBytes = getPassword(password);
  var kdf = getEncryptKdfParams(options);
  var key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
/**
 *  Resolved to the JSON Keystore Wallet for %%account%% encrypted
 *  with %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used and provide a [[ProgressCallback]] to receive periodic updates
 *  on the completion status..
 */
function encryptKeystoreJson(_x270, _x271, _x272) {
  return _encryptKeystoreJson.apply(this, arguments);
}
/**
 *  Explain HD Wallets..
 *
 *  @_subsection: api/wallet:HD Wallets  [hd-wallets]
 */
/**
 *  The default derivation path for Ethereum HD Nodes. (i.e. ``"m/44'/60'/0'/0/0"``)
 */
function _encryptKeystoreJson() {
  _encryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee224(account, password, options) {
    var passwordBytes, kdf, key;
    return _regeneratorRuntime().wrap(function _callee224$(_context227) {
      while (1) switch (_context227.prev = _context227.next) {
        case 0:
          if (options == null) {
            options = {};
          }
          passwordBytes = getPassword(password);
          kdf = getEncryptKdfParams(options);
          _context227.next = 5;
          return scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
        case 5:
          key = _context227.sent;
          return _context227.abrupt("return", _encryptKeystore(getBytes(key), kdf, account, options));
        case 7:
        case "end":
          return _context227.stop();
      }
    }, _callee224);
  }));
  return _encryptKeystoreJson.apply(this, arguments);
}
var defaultPath = "m/44'/60'/0'/0/0";
// "Bitcoin seed"
exports.defaultPath = defaultPath;
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 0x80000000;
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles = "0123456789abcdef";
function zpad(value, length) {
  var result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  var value = getBytes(_value);
  var check = dataSlice(sha256(sha256(value)), 0, 4);
  var bytes = concat([value, check]);
  return encodeBase58(bytes);
}
var _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  var data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert$1(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    // Data = 0x00 || ser_256(k_par)
    data.set(getBytes(privateKey), 1);
  } else {
    // Data = ser_p(point(k_par))
    data.set(getBytes(publicKey));
  }
  // Data += ser_32(i)
  for (var _i85 = 24; _i85 >= 0; _i85 -= 8) {
    data[33 + (_i85 >> 3)] = index >> 24 - _i85 & 0xff;
  }
  var I = getBytes(computeHmac("sha512", chainCode, data));
  return {
    IL: I.slice(0, 32),
    IR: I.slice(32)
  };
}
function _derivePath(node, path) {
  var components = path.split("/");
  assertArgument(components.length > 0 && (components[0] === "m" || node.depth > 0), "invalid path", "path", path);
  if (components[0] === "m") {
    components.shift();
  }
  var result = node;
  for (var _i86 = 0; _i86 < components.length; _i86++) {
    var component = components[_i86];
    if (component.match(/^[0-9]+'$/)) {
      var index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", "path[".concat(_i86, "]"), component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      var _index2 = parseInt(component);
      assertArgument(_index2 < HardenedBit, "invalid path index", "path[".concat(_i86, "]"), component);
      result = result.deriveChild(_index2);
    } else {
      assertArgument(false, "invalid path component", "path[".concat(_i86, "]"), component);
    }
  }
  return result;
}
/**
 *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived
 *  from an HD Node using the [[link-bip-32]] stantard.
 *
 *  An HD Node forms a hierarchal structure with each HD Node having a
 *  private key and the ability to derive child HD Nodes, defined by
 *  a path indicating the index of each child.
 */
var _account = /*#__PURE__*/new WeakSet();
var HDNodeWallet = /*#__PURE__*/function (_BaseWallet) {
  _inherits(HDNodeWallet, _BaseWallet);
  var _super77 = _createSuper(HDNodeWallet);
  /**
   *  The compressed public key.
   */

  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */

  /**
   *  The parent fingerprint.
   */

  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */

  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */

  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */

  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */

  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */

  /**
   *  @private
   */
  function HDNodeWallet(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    var _this101;
    _classCallCheck(this, HDNodeWallet);
    _this101 = _super77.call(this, signingKey, provider);
    _classPrivateMethodInitSpec(_assertThisInitialized(_this101), _account);
    _defineProperty(_assertThisInitialized(_this101), "publicKey", void 0);
    _defineProperty(_assertThisInitialized(_this101), "fingerprint", void 0);
    _defineProperty(_assertThisInitialized(_this101), "parentFingerprint", void 0);
    _defineProperty(_assertThisInitialized(_this101), "mnemonic", void 0);
    _defineProperty(_assertThisInitialized(_this101), "chainCode", void 0);
    _defineProperty(_assertThisInitialized(_this101), "path", void 0);
    _defineProperty(_assertThisInitialized(_this101), "index", void 0);
    _defineProperty(_assertThisInitialized(_this101), "depth", void 0);
    assertPrivate(guard, _guard, "HDNodeWallet");
    defineProperties(_assertThisInitialized(_this101), {
      publicKey: signingKey.compressedPublicKey
    });
    var fingerprint = dataSlice(ripemd160(sha256(_this101.publicKey)), 0, 4);
    defineProperties(_assertThisInitialized(_this101), {
      parentFingerprint: parentFingerprint,
      fingerprint: fingerprint,
      chainCode: chainCode,
      path: path,
      index: index,
      depth: depth
    });
    defineProperties(_assertThisInitialized(_this101), {
      mnemonic: mnemonic
    });
    return _this101;
  }
  _createClass(HDNodeWallet, [{
    key: "connect",
    value: function connect(provider) {
      return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
    }
  }, {
    key: "encrypt",
    value:
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee192(password, progressCallback) {
        return _regeneratorRuntime().wrap(function _callee192$(_context192) {
          while (1) switch (_context192.prev = _context192.next) {
            case 0:
              _context192.next = 2;
              return encryptKeystoreJson(_classPrivateMethodGet(this, _account, _account2).call(this), password, {
                progressCallback: progressCallback
              });
            case 2:
              return _context192.abrupt("return", _context192.sent);
            case 3:
            case "end":
              return _context192.stop();
          }
        }, _callee192, this);
      }));
      function encrypt(_x273, _x274) {
        return _encrypt.apply(this, arguments);
      }
      return encrypt;
    }()
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
  }, {
    key: "encryptSync",
    value: function encryptSync(password) {
      return encryptKeystoreJsonSync(_classPrivateMethodGet(this, _account, _account2).call(this), password);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpriv`` and can be used to
     *  reconstruct this HD Node to derive its children.
     */
  }, {
    key: "extendedKey",
    get: function get() {
      // We only support the mainnet values for now, but if anyone needs
      // testnet values, let me know. I believe current sentiment is that
      // we should always use mainnet, and use BIP-44 to derive the network
      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
      //   - Testnet: public=0x043587CF, private=0x04358394
      assert$1(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
        operation: "extendedKey"
      });
      return encodeBase58Check(concat(["0x0488ADE4", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, concat(["0x00", this.privateKey])]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
  }, {
    key: "hasPath",
    value: function hasPath() {
      return this.path != null;
    }
    /**
     *  Returns a neutered HD Node, which removes the private details
     *  of an HD Node.
     *
     *  A neutered node has no private key, but can be used to derive
     *  child addresses and other public data about the HD Node.
     */
  }, {
    key: "neuter",
    value: function neuter() {
      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
    }
    /**
     *  Return the child for %%index%%.
     */
  }, {
    key: "deriveChild",
    value: function deriveChild(_index) {
      var index = getNumber(_index, "index");
      assertArgument(index <= 0xffffffff, "invalid index", "index", index);
      // Base path
      var path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
        if (index & HardenedBit) {
          path += "'";
        }
      }
      var _ser_I = ser_I(index, this.chainCode, this.publicKey, this.privateKey),
        IR = _ser_I.IR,
        IL = _ser_I.IL;
      var ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
      return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
    }
    /**
     *  Return the HDNode for %%path%% from this node.
     */
  }, {
    key: "derivePath",
    value: function derivePath(path) {
      return _derivePath(this, path);
    }
  }], [{
    key: "fromExtendedKey",
    value:
    /**
     *  Creates a new HD Node from %%extendedKey%%.
     *
     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
     *  or full HD Node ([[HDNodeWallet) respectively.
     */
    function fromExtendedKey(extendedKey) {
      var bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact
      assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
      var depth = bytes[4];
      var parentFingerprint = hexlify(bytes.slice(5, 9));
      var index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
      var chainCode = hexlify(bytes.slice(13, 45));
      var key = bytes.slice(45, 78);
      switch (hexlify(bytes.slice(0, 4))) {
        // Public Key
        case "0x0488b21e":
        case "0x043587cf":
          {
            var publicKey = hexlify(key);
            return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
          }
        // Private Key
        case "0x0488ade4":
        case "0x04358394 ":
          if (key[0] !== 0) {
            break;
          }
          return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
      }
      assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
    }
    /**
     *  Creates a new random HDNode.
     */
  }, {
    key: "createRandom",
    value: function createRandom(password, path, wordlist) {
      if (password == null) {
        password = "";
      }
      if (path == null) {
        path = defaultPath;
      }
      if (wordlist == null) {
        wordlist = LangEn.wordlist();
      }
      var mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);
      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Create am HD Node from %%mnemonic%%.
     */
  }, {
    key: "fromMnemonic",
    value: function fromMnemonic(mnemonic, path) {
      if (!path) {
        path = defaultPath;
      }
      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a mnemonic %%phrase%%.
     */
  }, {
    key: "fromPhrase",
    value: function fromPhrase(phrase, password, path, wordlist) {
      if (password == null) {
        password = "";
      }
      if (path == null) {
        path = defaultPath;
      }
      if (wordlist == null) {
        wordlist = LangEn.wordlist();
      }
      var mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a %%seed%%.
     */
  }, {
    key: "fromSeed",
    value: function fromSeed(seed) {
      return _classStaticPrivateMethodGet(HDNodeWallet, HDNodeWallet, _fromSeed).call(HDNodeWallet, seed, null);
    }
  }]);
  return HDNodeWallet;
}(BaseWallet);
/**
 *  A **HDNodeVoidWallet** cannot sign, but provides access to
 *  the children nodes of a [[link-bip-32]] HD wallet addresses.
 *
 *  The can be created by using an extended ``xpub`` key to
 *  [[HDNodeWallet_fromExtendedKey]] or by
 *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].
 */
exports.HDNodeWallet = HDNodeWallet;
function _account2() {
  var account = {
    address: this.address,
    privateKey: this.privateKey
  };
  var m = this.mnemonic;
  if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m.entropy
    };
  }
  return account;
}
function _fromSeed(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  var seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  var I = getBytes(computeHmac("sha512", MasterSecret, seed));
  var signingKey = new SigningKey(hexlify(I.slice(0, 32)));
  return new HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
}
var HDNodeVoidWallet = /*#__PURE__*/function (_VoidSigner) {
  _inherits(HDNodeVoidWallet, _VoidSigner);
  var _super78 = _createSuper(HDNodeVoidWallet);
  /**
   *  The compressed public key.
   */

  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */

  /**
   *  The parent node fingerprint.
   */

  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */

  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */

  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */

  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */

  /**
   *  @private
   */
  function HDNodeVoidWallet(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    var _this102;
    _classCallCheck(this, HDNodeVoidWallet);
    _this102 = _super78.call(this, address, provider);
    _defineProperty(_assertThisInitialized(_this102), "publicKey", void 0);
    _defineProperty(_assertThisInitialized(_this102), "fingerprint", void 0);
    _defineProperty(_assertThisInitialized(_this102), "parentFingerprint", void 0);
    _defineProperty(_assertThisInitialized(_this102), "chainCode", void 0);
    _defineProperty(_assertThisInitialized(_this102), "path", void 0);
    _defineProperty(_assertThisInitialized(_this102), "index", void 0);
    _defineProperty(_assertThisInitialized(_this102), "depth", void 0);
    assertPrivate(guard, _guard, "HDNodeVoidWallet");
    defineProperties(_assertThisInitialized(_this102), {
      publicKey: publicKey
    });
    var fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
    defineProperties(_assertThisInitialized(_this102), {
      publicKey: publicKey,
      fingerprint: fingerprint,
      parentFingerprint: parentFingerprint,
      chainCode: chainCode,
      path: path,
      index: index,
      depth: depth
    });
    return _this102;
  }
  _createClass(HDNodeVoidWallet, [{
    key: "connect",
    value: function connect(provider) {
      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpub`` and can be used to
     *  reconstruct this neutered key to derive its children addresses.
     */
  }, {
    key: "extendedKey",
    get: function get() {
      // We only support the mainnet values for now, but if anyone needs
      // testnet values, let me know. I believe current sentiment is that
      // we should always use mainnet, and use BIP-44 to derive the network
      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
      //   - Testnet: public=0x043587CF, private=0x04358394
      assert$1(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
        operation: "extendedKey"
      });
      return encodeBase58Check(concat(["0x0488B21E", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
  }, {
    key: "hasPath",
    value: function hasPath() {
      return this.path != null;
    }
    /**
     *  Return the child for %%index%%.
     */
  }, {
    key: "deriveChild",
    value: function deriveChild(_index) {
      var index = getNumber(_index, "index");
      assertArgument(index <= 0xffffffff, "invalid index", "index", index);
      // Base path
      var path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
        if (index & HardenedBit) {
          path += "'";
        }
      }
      var _ser_I2 = ser_I(index, this.chainCode, this.publicKey, null),
        IR = _ser_I2.IR,
        IL = _ser_I2.IL;
      var Ki = SigningKey.addPoints(IL, this.publicKey, true);
      var address = computeAddress(Ki);
      return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
    }
    /**
     *  Return the signer for %%path%% from this node.
     */
  }, {
    key: "derivePath",
    value: function derivePath(path) {
      return _derivePath(this, path);
    }
  }]);
  return HDNodeVoidWallet;
}(VoidSigner);
/*
export class HDNodeWalletManager {
    #root: HDNodeWallet;

    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {
        if (password == null) { password = ""; }
        if (path == null) { path = "m/44'/60'/0'/0"; }
        if (locale == null) { locale = LangEn.wordlist(); }
        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);
    }

    getSigner(index?: number): HDNodeWallet {
        return this.#root.deriveChild((index == null) ? 0: index);
    }
}
*/
/**
 *  Returns the [[link-bip-32]] path for the acount at %%index%%.
 *
 *  This is the pattern used by wallets like Ledger.
 *
 *  There is also an [alternate pattern](getIndexedAccountPath) used by
 *  some software.
 */
exports.HDNodeVoidWallet = HDNodeVoidWallet;
function getAccountPath(_index) {
  var index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return "m/44'/60'/".concat(index, "'/0/0");
}
/**
 *  Returns the path using an alternative pattern for deriving accounts,
 *  at %%index%%.
 *
 *  This derivation path uses the //index// component rather than the
 *  //account// component to derive sequential accounts.
 *
 *  This is the pattern used by wallets like MetaMask.
 */
function getIndexedAccountPath(_index) {
  var index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return "m/44'/60'/0'/0/".concat(index);
}

/**
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
/**
 *  Returns true if %%json%% is a valid JSON Crowdsale wallet.
 */
function isCrowdsaleJson(json) {
  try {
    var data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {}
  return false;
}
// See: https://github.com/ethereum/pyethsaletool
/**
 *  Before Ethereum launched, it was necessary to create a wallet
 *  format for backers to use, which would be used to receive ether
 *  as a reward for contributing to the project.
 *
 *  The [[link-crowdsale]] format is now obsolete, but it is still
 *  useful to support and the additional code is fairly trivial as
 *  all the primitives required are used through core portions of
 *  the library.
 */
function decryptCrowdsaleJson(json, _password) {
  var data = JSON.parse(json);
  var password = getPassword(_password);
  // Ethereum Address
  var address = getAddress(spelunk(data, "ethaddr:string!"));
  // Encrypted Seed
  var encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  var key = getBytes(pbkdf2(password, password, 2000, 32, "sha256")).slice(0, 16);
  var iv = encseed.slice(0, 16);
  var encryptedSeed = encseed.slice(16);
  // Decrypt the seed
  var aesCbc = new CBC(key, iv);
  var seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  // This wallet format is weird... Convert the binary encoded hex to a string.
  var seedHex = "";
  for (var _i87 = 0; _i87 < seed.length; _i87++) {
    seedHex += String.fromCharCode(seed[_i87]);
  }
  return {
    address: address,
    privateKey: id(seedHex)
  };
}
function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, duration);
  });
}
/**
 *  A **Wallet** manages a single private key which is used to sign
 *  transactions, messages and other common payloads.
 *
 *  This class is generally the main entry point for developers
 *  that wish to use a private key directly, as it can create
 *  instances from a large variety of common sources, including
 *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON
 *  wallets.
 */
var Wallet = /*#__PURE__*/function (_BaseWallet2) {
  _inherits(Wallet, _BaseWallet2);
  var _super79 = _createSuper(Wallet);
  /**
   *  Create a new wallet for the %%privateKey%%, optionally connected
   *  to %%provider%%.
   */
  function Wallet(key, provider) {
    _classCallCheck(this, Wallet);
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    var signingKey = typeof key === "string" ? new SigningKey(key) : key;
    return _super79.call(this, signingKey, provider);
  }
  _createClass(Wallet, [{
    key: "connect",
    value: function connect(provider) {
      return new Wallet(this.signingKey, provider);
    }
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee193(password, progressCallback) {
        var account;
        return _regeneratorRuntime().wrap(function _callee193$(_context193) {
          while (1) switch (_context193.prev = _context193.next) {
            case 0:
              account = {
                address: this.address,
                privateKey: this.privateKey
              };
              _context193.next = 3;
              return encryptKeystoreJson(account, password, {
                progressCallback: progressCallback
              });
            case 3:
              return _context193.abrupt("return", _context193.sent);
            case 4:
            case "end":
              return _context193.stop();
          }
        }, _callee193, this);
      }));
      function encrypt(_x275, _x276) {
        return _encrypt2.apply(this, arguments);
      }
      return encrypt;
    }()
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
  }, {
    key: "encryptSync",
    value: function encryptSync(password) {
      var account = {
        address: this.address,
        privateKey: this.privateKey
      };
      return encryptKeystoreJsonSync(account, password);
    }
  }], [{
    key: "fromEncryptedJson",
    value:
    /**
     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
     *  with %%password%%.
     *
     *  If %%progress%% is provided, it is called periodically during
     *  decryption so that any UI can be updated.
     */
    function () {
      var _fromEncryptedJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee194(json, password, progress) {
        var account;
        return _regeneratorRuntime().wrap(function _callee194$(_context194) {
          while (1) switch (_context194.prev = _context194.next) {
            case 0:
              account = null;
              if (!isKeystoreJson(json)) {
                _context194.next = 7;
                break;
              }
              _context194.next = 4;
              return decryptKeystoreJson(json, password, progress);
            case 4:
              account = _context194.sent;
              _context194.next = 17;
              break;
            case 7:
              if (!isCrowdsaleJson(json)) {
                _context194.next = 17;
                break;
              }
              if (!progress) {
                _context194.next = 12;
                break;
              }
              progress(0);
              _context194.next = 12;
              return stall(0);
            case 12:
              account = decryptCrowdsaleJson(json, password);
              if (!progress) {
                _context194.next = 17;
                break;
              }
              progress(1);
              _context194.next = 17;
              return stall(0);
            case 17:
              return _context194.abrupt("return", _classStaticPrivateMethodGet(Wallet, Wallet, _fromAccount).call(Wallet, account));
            case 18:
            case "end":
              return _context194.stop();
          }
        }, _callee194);
      }));
      function fromEncryptedJson(_x277, _x278, _x279) {
        return _fromEncryptedJson.apply(this, arguments);
      }
      return fromEncryptedJson;
    }()
    /**
     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
     *
     *  The [[fromEncryptedJson]] method is preferred, as this method
     *  will lock up and freeze the UI during decryption, which may take
     *  some time.
     */
  }, {
    key: "fromEncryptedJsonSync",
    value: function fromEncryptedJsonSync(json, password) {
      var account = null;
      if (isKeystoreJson(json)) {
        account = decryptKeystoreJsonSync(json, password);
      } else if (isCrowdsaleJson(json)) {
        account = decryptCrowdsaleJson(json, password);
      } else {
        assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
      }
      return _classStaticPrivateMethodGet(Wallet, Wallet, _fromAccount).call(Wallet, account);
    }
    /**
     *  Creates a new random [[HDNodeWallet]] using the avavilable
     *  [cryptographic random source](randomBytes).
     *
     *  If there is no crytographic random source, this will throw.
     */
  }, {
    key: "createRandom",
    value: function createRandom(provider) {
      var wallet = HDNodeWallet.createRandom();
      if (provider) {
        return wallet.connect(provider);
      }
      return wallet;
    }
    /**
     *  Creates a [[HDNodeWallet]] for %%phrase%%.
     */
  }, {
    key: "fromPhrase",
    value: function fromPhrase(phrase, provider) {
      var wallet = HDNodeWallet.fromPhrase(phrase);
      if (provider) {
        return wallet.connect(provider);
      }
      return wallet;
    }
  }]);
  return Wallet;
}(BaseWallet);
/**
 *  When interacting with Ethereum, it is necessary to use a private
 *  key authenticate actions by signing a payload.
 *
 *  Wallets are the simplest way to expose the concept of an
 *  //Externally Owner Account// (EOA) as it wraps a private key
 *  and supports high-level methods to sign common types of interaction
 *  and send transactions.
 *
 *  The class most developers will want to use is [[Wallet]], which
 *  can load a private key directly or from any common wallet format.
 *
 *  The [[HDNodeWallet]] can be used when it is necessary to access
 *  low-level details of how an HD wallets are derived, exported
 *  or imported.
 *
 *  @_section: api/wallet:Wallets  [about-wallets]
 */
exports.Wallet = Wallet;
function _fromAccount(account) {
  assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
  if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
    var mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
    var _wallet = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
    if (_wallet.address === account.address && _wallet.privateKey === account.privateKey) {
      return _wallet;
    }
    console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
  }
  var wallet = new Wallet(account.privateKey);
  assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
  return wallet;
}
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
/**
 *  @_ignore
 */
function decodeBits(width, data) {
  var maxValue = (1 << width) - 1;
  var result = [];
  var accum = 0,
    bits = 0,
    flood = 0;
  for (var _i88 = 0; _i88 < data.length; _i88++) {
    // Accumulate 6 bits of data
    accum = accum << 6 | Base64.indexOf(data[_i88]);
    bits += 6;
    // While we have enough for a word...
    while (bits >= width) {
      // ...read the word
      var value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      // A value of 0 indicates we exceeded maxValue, it
      // floods over into the next value
      if (value === 0) {
        flood += maxValue;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}

/**
 *  @_ignore
 */
function decodeOwlA(data, accents) {
  var words = decodeOwl(data).join(",");
  // Inject the accents
  accents.split(/,/g).forEach(function (accent) {
    var match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    var posOffset = 0;
    var positions = decodeBits(parseInt(match[3]), match[4]);
    var charCode = parseInt(match[2]);
    var regex = new RegExp("([".concat(match[1], "])"), "g");
    words = words.replace(regex, function (all, letter) {
      var rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words.split(",");
}

/**
 *  An OWL-A format Wordlist extends the OWL format to add an
 *  overlay onto an OWL format Wordlist to support diacritic
 *  marks.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on latin-1 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create these necessary data.
 */
var _accent = /*#__PURE__*/new WeakMap();
var WordlistOwlA = /*#__PURE__*/function (_WordlistOwl2) {
  _inherits(WordlistOwlA, _WordlistOwl2);
  var _super80 = _createSuper(WordlistOwlA);
  function WordlistOwlA(locale, data, accent, checksum) {
    var _this103;
    _classCallCheck(this, WordlistOwlA);
    _this103 = _super80.call(this, locale, data, checksum);
    _classPrivateFieldInitSpec(_assertThisInitialized(_this103), _accent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(_assertThisInitialized(_this103), _accent, accent);
    return _this103;
  }
  _createClass(WordlistOwlA, [{
    key: "_accent",
    get: function get() {
      return _classPrivateFieldGet(this, _accent);
    }
  }, {
    key: "_decodeWords",
    value: function _decodeWords() {
      return decodeOwlA(this._data, this._accent);
    }
  }]);
  return WordlistOwlA;
}(WordlistOwl);
exports.WordlistOwlA = WordlistOwlA;
var wordlists = {
  en: LangEn.wordlist()
};

/**
 *  A Wordlist is a set of 2048 words used to encode private keys
 *  (or other binary data) that is easier for humans to write down,
 *  transcribe and dictate.
 *
 *  The [[link-bip-39]] standard includes several checksum bits,
 *  depending on the size of the mnemonic phrase.
 *
 *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For
 *  most purposes 12 word mnemonics should be used, as including
 *  additional words increases the difficulty and potential for
 *  mistakes and does not offer any effective improvement on security.
 *
 *  There are a variety of [[link-bip39-wordlists]] for different
 *  languages, but for maximal compatibility, the
 *  [English Wordlist](LangEn) is recommended.
 *
 *  @_section: api/wordlists:Wordlists [about-wordlists]
 */

/////////////////////////////

var ethers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  version: version,
  decodeBytes32String: decodeBytes32String,
  encodeBytes32String: encodeBytes32String,
  AbiCoder: AbiCoder,
  ConstructorFragment: ConstructorFragment,
  ErrorFragment: ErrorFragment,
  EventFragment: EventFragment,
  Fragment: Fragment,
  FunctionFragment: FunctionFragment,
  ParamType: ParamType,
  checkResultErrors: checkResultErrors,
  Indexed: Indexed,
  Interface: Interface,
  LogDescription: LogDescription,
  Result: Result,
  TransactionDescription: TransactionDescription,
  Typed: Typed,
  getAddress: getAddress,
  getIcapAddress: getIcapAddress,
  getCreateAddress: getCreateAddress,
  getCreate2Address: getCreate2Address,
  isAddressable: isAddressable,
  isAddress: isAddress,
  resolveAddress: resolveAddress,
  ZeroAddress: ZeroAddress,
  WeiPerEther: WeiPerEther,
  MaxUint256: MaxUint256,
  MinInt256: MinInt256,
  MaxInt256: MaxInt256,
  N: N$1,
  ZeroHash: ZeroHash,
  EtherSymbol: EtherSymbol,
  MessagePrefix: MessagePrefix,
  BaseContract: BaseContract,
  Contract: Contract,
  ContractFactory: ContractFactory,
  ContractEventPayload: ContractEventPayload,
  ContractTransactionReceipt: ContractTransactionReceipt,
  ContractTransactionResponse: ContractTransactionResponse,
  EventLog: EventLog,
  computeHmac: computeHmac,
  randomBytes: randomBytes,
  keccak256: keccak256,
  ripemd160: ripemd160,
  sha256: sha256,
  sha512: sha512,
  pbkdf2: pbkdf2,
  scrypt: scrypt,
  scryptSync: scryptSync,
  lock: lock,
  Signature: Signature,
  SigningKey: SigningKey,
  id: id,
  ensNormalize: ensNormalize,
  isValidName: isValidName,
  namehash: namehash,
  dnsEncode: dnsEncode,
  hashMessage: hashMessage,
  verifyMessage: verifyMessage,
  solidityPacked: solidityPacked,
  solidityPackedKeccak256: solidityPackedKeccak256,
  solidityPackedSha256: solidityPackedSha256,
  TypedDataEncoder: TypedDataEncoder,
  getDefaultProvider: getDefaultProvider,
  Block: Block,
  FeeData: FeeData,
  Log: Log,
  TransactionReceipt: TransactionReceipt,
  TransactionResponse: TransactionResponse,
  AbstractSigner: AbstractSigner,
  NonceManager: NonceManager,
  VoidSigner: VoidSigner,
  AbstractProvider: AbstractProvider,
  FallbackProvider: FallbackProvider,
  JsonRpcApiProvider: JsonRpcApiProvider,
  JsonRpcProvider: JsonRpcProvider,
  JsonRpcSigner: JsonRpcSigner,
  BrowserProvider: BrowserProvider,
  AlchemyProvider: AlchemyProvider,
  AnkrProvider: AnkrProvider,
  CloudflareProvider: CloudflareProvider,
  EtherscanProvider: EtherscanProvider,
  InfuraProvider: InfuraProvider,
  PocketProvider: PocketProvider,
  QuickNodeProvider: QuickNodeProvider,
  IpcSocketProvider: IpcSocketProvider,
  SocketProvider: SocketProvider,
  WebSocketProvider: WebSocketProvider,
  EnsResolver: EnsResolver,
  Network: Network,
  accessListify: accessListify,
  computeAddress: computeAddress,
  recoverAddress: recoverAddress,
  Transaction: Transaction,
  decodeBase58: decodeBase58,
  encodeBase58: encodeBase58,
  decodeBase64: decodeBase64,
  encodeBase64: encodeBase64,
  concat: concat,
  dataLength: dataLength,
  dataSlice: dataSlice,
  getBytes: getBytes,
  getBytesCopy: getBytesCopy,
  hexlify: hexlify,
  isHexString: isHexString,
  isBytesLike: isBytesLike,
  stripZerosLeft: stripZerosLeft,
  zeroPadBytes: zeroPadBytes,
  zeroPadValue: zeroPadValue,
  defineProperties: defineProperties,
  assert: assert$1,
  assertArgument: assertArgument,
  assertArgumentCount: assertArgumentCount,
  assertNormalize: assertNormalize,
  assertPrivate: assertPrivate,
  makeError: makeError,
  isCallException: isCallException,
  isError: isError,
  FetchRequest: FetchRequest,
  FetchResponse: FetchResponse,
  FetchCancelSignal: FetchCancelSignal,
  FixedNumber: FixedNumber,
  getBigInt: getBigInt,
  getNumber: getNumber,
  getUint: getUint,
  toBeArray: toBeArray,
  toBigInt: toBigInt,
  toBeHex: toBeHex,
  toNumber: toNumber,
  toQuantity: toQuantity,
  fromTwos: fromTwos,
  toTwos: toTwos,
  mask: mask,
  formatEther: formatEther,
  parseEther: parseEther,
  formatUnits: formatUnits,
  parseUnits: parseUnits,
  toUtf8Bytes: toUtf8Bytes,
  toUtf8CodePoints: toUtf8CodePoints,
  toUtf8String: toUtf8String,
  Utf8ErrorFuncs: Utf8ErrorFuncs,
  decodeRlp: decodeRlp,
  encodeRlp: encodeRlp,
  Mnemonic: Mnemonic,
  BaseWallet: BaseWallet,
  HDNodeWallet: HDNodeWallet,
  HDNodeVoidWallet: HDNodeVoidWallet,
  Wallet: Wallet,
  defaultPath: defaultPath,
  getAccountPath: getAccountPath,
  isCrowdsaleJson: isCrowdsaleJson,
  isKeystoreJson: isKeystoreJson,
  decryptCrowdsaleJson: decryptCrowdsaleJson,
  decryptKeystoreJsonSync: decryptKeystoreJsonSync,
  decryptKeystoreJson: decryptKeystoreJson,
  encryptKeystoreJson: encryptKeystoreJson,
  encryptKeystoreJsonSync: encryptKeystoreJsonSync,
  Wordlist: Wordlist,
  LangEn: LangEn,
  WordlistOwl: WordlistOwl,
  WordlistOwlA: WordlistOwlA
});

/**
 *  The Application Programming Interface (API) is the collection of
 *  functions, classes and types offered by the Ethers library.
 *
 *  @_section: api:Application Programming Interface  [about-api]
 *  @_navTitle: API
 */
exports.ethers = ethers;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":1}],3:[function(require,module,exports){
(function (global){(function (){
"use strict";

global.ethers = require('./ethers.js')["default"];

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ethers.js":2}]},{},[3]);
